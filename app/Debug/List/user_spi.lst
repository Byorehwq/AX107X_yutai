##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   29/Jun/2018  19:55:14 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  near                                              #
#    Data model         =  large                                             #
#    Calling convention =  extended stack reentrant                          #
#    Constant location  =  code                                              #
#    Extended stack     =  enabled                                           #
#    Dptr setup         =  1,16                                              #
#    Source file        =  I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\user\user_spi.c #
#    Command line       =  -I E:\software\8051\INC\ -I                       #
#                          E:\software\8051\INC\CLIB\ -I                     #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\COMMON\ -I      #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\INC\ -I         #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\config\ -I      #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\api\ -I         #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\fm\ -I          #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\fat\ -I         #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\display\ -I     #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\display\theme_d #
#                          efault\ -I I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073 #
#                          A_”ÓÃ©_AX1071_xxxxxxxx_20180629_Merlin_1\app\disp #
#                          lay\led\ -I I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC07 #
#                          3A_”ÓÃ©_AX1071_xxxxxxxx_20180629_Merlin_1\app\dis #
#                          play\lcd\ -I I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC0 #
#                          73A_”ÓÃ©_AX1071_xxxxxxxx_20180629_Merlin_1\app\ta #
#                          sk\ -I I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”Ó #
#                          Ã©_AX1071_xxxxxxxx_20180629_Merlin_1\app\user\    #
#                          -I I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_A #
#                          X1071_xxxxxxxx_20180629_Merlin_1\app\mem\ -I      #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\module\ -I      #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\key\ -I         #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\startmusic\ -I  #
#                          I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\spi\ -D         #
#                          AX107X_TAG -lC I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18B #
#                          C073A_”ÓÃ©_AX1071_xxxxxxxx_20180629_Merlin_1\app\ #
#                          Debug\List\ -o I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18B #
#                          C073A_”ÓÃ©_AX1071_xxxxxxxx_20180629_Merlin_1\app\ #
#                          Debug\Obj\ -e -z9 --core=plain --dptr=16,1        #
#                          --data_model=large --code_model=near              #
#                          --calling_convention=ext_stack_reentrant          #
#                          --place_constants=code --nr_virtual_regs 20       #
#                          --extended_stack I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\1 #
#                          8BC073A_”ÓÃ©_AX1071_xxxxxxxx_20180629_Merlin_1\ap #
#                          p\user\user_spi.c                                 #
#    List file          =  I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\Debug\List\user #
#                          _spi.lst                                          #
#    Object file        =  I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\Debug\Obj\user_ #
#                          spi.r51                                           #
#                                                                            #
#                                                                            #
##############################################################################

I:\a_wangqun\”ÓÃ©_ÀØ√ﬂ“«_KNP08\18BC073A_”ÓÃ©_AX1071_xxxxxxxx_20180629_Merlin_1\app\user\user_spi.c
      1          /*****************************************************************************
      2           * Module    : user
      3           * File      : user_spi.c
      4           * Author    : Hanny
      5           * Email     : coldney@yahoo.com.cn
      6           * Function  : ”√ªßµƒSPI≤Ÿ◊˜
      7           *****************************************************************************/
      8          #include "include.h"

   \                                 In segment SFR_AN, at 0x88
   \   unsigned char volatile __sfr SDCON0
   \                     SDCON0:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0x90
   \   unsigned char volatile __sfr P1
   \                     P1:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xd6
   \   unsigned char volatile __sfr SPI0CON
   \                     SPI0CON:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xf7
   \   unsigned char volatile __sfr WDTCON
   \                     WDTCON:
   \   000000                DS 1
      9          #include "spi.h"
     10          

   \                                 In segment XDATA_N, align 1, root
     11          IAR_XDATA_A type_user_spi u_spi;
   \                     u_spi:
   \   000000                DS 3

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
     12          u8 flash_chipnum;                      //flash–Ú∫≈
   \                     flash_chipnum:
   \   000000                DS 1
     13          extern u8 dec_bs[512+6];               //DECbuf£¨”√”⁄‘›¥Êflash ˝æ›
     14          extern  u8 flash_music_total_tbl[7];
     15          extern u16 get_dirstart(void);
     16          

   \                                 In segment CODE_C, align 1
     17          IAR_CONST u8 ReadIDCMD[4] =
   \                     ReadIDCMD:
   \   000000   9F90AB15     DB 159, 144, 171, 21
     18          {
     19          	0x9F,0x90,0xAB,0x15               //∂¡»°flashID√¸¡Ó
     20          };
     21          
     22          //SPI IO≥ı ºªØ
     23          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
     24          void spi_port_init(void)
   \                     spi_port_init:
     25          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     26          #if !SOFT_SPI    
     27          	SPI_PORT_SEL();
   \   000000   903058       MOV     DPTR,#0x3058
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C2E4         CLR     0xE0 /* A   */.4
   \   000006   F0           MOVX    @DPTR,A
   \   000007   75D610       MOV     0xd6,#0x10
     28          #endif
     29              
     30          
     31          #if (USE_SD_CLK_DET && USE_SDCMD_IIC_SPIDAT)
     32          	SPI_CLK_DIR |= BIT(SPI_CLK_PIN);
     33          #else
     34          	SPI_CLK_DIR &= ~BIT(SPI_CLK_PIN);       //CLK
   \   00000A   53BBDF       ANL     0xbb,#0xdf
     35          #endif
     36          	SPI_DO_DIR &= ~BIT(SPI_DO_PIN);         //DO
   \   00000D   53BBBF       ANL     0xbb,#0xbf
     37          	SPI_CS_DIR &= ~BIT(SPI_CS_PIN);         //CS
   \   000010   53BB7F       ANL     0xbb,#0x7f
     38          #if (SPI_MODE_SEL == SPI_THREE_WIRES_MODE)
     39          	SPI_DI_DIR |=  BIT(SPI_DI_PIN);         //DI
     40          #endif
     41          
     42          #if !SOFT_SPI
     43          	spi_init();
   \   000013                ; Setup parameters for call to function spi_init
   \   000013   12....       LCALL   spi_init
     44          #endif
     45          }
   \   000016   22           RET
     46          
     47          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
     48          void spi_sd_mux_enter(void)
   \                     spi_sd_mux_enter:
     49          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     50          	SDCON0 = 0;
   \   000000   758800       MOV     0x88,#0x0
     51          }
   \   000003   22           RET
     52          
     53          
     54          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
     55          void spi_sd_mux_exit(void)
   \                     spi_sd_mux_exit:
     56          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     57          	if(device_is_online(DEVICE_SDMMC)||device_is_online(DEVICE_SDMMC1))
   \   000000                ; Setup parameters for call to function device_is_online
   \   000000   7900         MOV     R1,#0x0
   \   000002   12....       LCALL   device_is_online
   \   000005   4007         JC      ??spi_sd_mux_exit_0
   \   000007                ; Setup parameters for call to function device_is_online
   \   000007   7901         MOV     R1,#0x1
   \   000009   12....       LCALL   device_is_online
   \   00000C   5003         JNC     ??spi_sd_mux_exit_1
     58          	{
     59          		SDCON0 = 1;
   \                     ??spi_sd_mux_exit_0:
   \   00000E   758801       MOV     0x88,#0x1
     60          	}
     61          }
   \                     ??spi_sd_mux_exit_1:
   \   000011   22           RET
     62          
     63          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
     64          void spi_cs_enable(void)
   \                     spi_cs_enable:
     65          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     66          	switch(flash_chipnum)
   \   000000   90....       MOV     DPTR,#flash_chipnum
   \   000003   E0           MOVX    A,@DPTR
   \   000004   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for spi_cs_enable>_0`:
   \   000007   01           DB        1
   \   000008   00           DB        0
   \   000009   ....         DW        ??spi_cs_enable_0
   \   00000B   ....         DW        ??spi_cs_enable_1
     67          	{
     68          	case 0x01:
     69          		SPI_CS_PORT &= ~BIT(SPI_CS_PIN);
   \                     ??spi_cs_enable_1:
   \   00000D   C297         CLR     0x90.7
     70          		break;
     71          	default:
     72          		break;
     73          	}
     74          }
   \                     ??spi_cs_enable_0:
   \   00000F   22           RET
     75          
     76          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
     77          void spi_cs_disable(void)
   \                     spi_cs_disable:
     78          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     79          	switch(flash_chipnum)
   \   000000   90....       MOV     DPTR,#flash_chipnum
   \   000003   E0           MOVX    A,@DPTR
   \   000004   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for spi_cs_disable>_0`:
   \   000007   01           DB        1
   \   000008   00           DB        0
   \   000009   ....         DW        ??spi_cs_disable_0
   \   00000B   ....         DW        ??spi_cs_disable_1
     80          	{
     81          	case 0x01:
     82          		SPI_CS_PORT |= BIT(SPI_CS_PIN);
   \                     ??spi_cs_disable_1:
   \   00000D   D297         SETB    0x90.7
     83          		break;
     84          	default:
     85          		break;
     86          	}
     87          }
   \                     ??spi_cs_disable_0:
   \   00000F   22           RET
     88          //»Ìº˛SPI–¥»Î“ªByte
     89          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
     90          void spi_write_byte_soft(u8 data)
   \                     spi_write_byte_soft:
     91          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     92          	u8 i;
     93          	if(SPI_MODE_SEL == SPI_THREE_WIRES_MODE)
     94          	{
     95          		for(i=0; i<8; i++)
     96          		{
     97          			SPI_CLK_PORT &= ~BIT(SPI_CLK_PIN);
     98          			if(data & 0x80)
     99          			{
    100          				SPI_DO_PORT |= BIT(SPI_DO_PIN);
    101          			}
    102          			else
    103          			{
    104          				SPI_DO_PORT &= ~BIT(SPI_DO_PIN);
    105          			}
    106          			SPI_CLK_PORT |= BIT(SPI_CLK_PIN);//…œ…˝—ÿ
    107          			data <<= 1;
    108          		}
    109          	}
    110          	else
    111          	{
    112          		SPI_2Wire_TX();
   \   000000   53BBBF       ANL     0xbb,#0xbf
   \   000003   53D6DF       ANL     0xd6,#0xdf
    113          		for(i=0; i<8; i++)
   \   000006   7A08         MOV     R2,#0x8
    114          		{
    115          			SPI_CLK_PORT &= ~BIT(SPI_CLK_PIN);
   \                     ??spi_write_byte_soft_0:
   \   000008   C295         CLR     0x90.5
    116          		#if 1
    117          			asm("MOV	A,R1");
   \   00000A   E9           MOV     A,R1
    118          			asm("MOV	C,ACC.7");
   \   00000B   A2E7         MOV     C,ACC.7
    119          			asm("MOV	P1.3,C");
   \   00000D   92..         MOV     P1.3,C
    120          			asm("CLR	C");
   \   00000F   C3           CLR     C
    121          			asm("RLC	A");
   \   000010   33           RLC     A
    122          			asm("MOV	R1,A");
   \   000011   F9           MOV     R1,A
    123          		#else
    124          			if(data & 0x80)
    125          			{
    126          				SPI_DO_PORT |= BIT(SPI_DO_PIN);
    127          			}
    128          			else
    129          			{
    130          				SPI_DO_PORT &= ~BIT(SPI_DO_PIN);
    131          			}
    132          		#endif
    133          			SPI_CLK_PORT |= BIT(SPI_CLK_PIN);//…œ…˝—ÿ
   \   000012   D295         SETB    0x90.5
    134          			data <<= 1;
    135          		}
   \   000014   1A           DEC     R2
   \   000015   EA           MOV     A,R2
   \   000016   70F0         JNZ     ??spi_write_byte_soft_0
    136          	}
    137          }
   \   000018   22           RET
    138          
    139          //»Ìº˛SPI∂¡»°“ªByte
    140          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    141          u8 spi_read_byte_soft(void)
   \                     spi_read_byte_soft:
    142          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    143          	u8 ch,i;
    144          	ch = 0;
   \   000000   7900         MOV     R1,#0x0
    145          #if (SPI_MODE_SEL == SPI_THREE_WIRES_MODE)
    146          	for(i=0; i<8; i++)
    147          	{
    148          		ch <<= 1;
    149          		SPI_CLK_PORT |= BIT(SPI_CLK_PIN);//œ¬Ωµ—ÿ
    150          		asm("nop");
    151          		asm("nop");
    152          		asm("nop");
    153          		SPI_CLK_PORT &= ~BIT(SPI_CLK_PIN);
    154          		asm("nop");
    155          		if(SPI_DI_PORT & BIT(SPI_DI_PIN))
    156          		{
    157          			ch |= 0x01;
    158          		}
    159          		else
    160          		{
    161          			ch &= ~0x01;
    162          		}
    163          	}
    164          #else
    165          	SPI_2Wire_RX();
   \   000002   43BB40       ORL     0xbb,#0x40
   \   000005   43D620       ORL     0xd6,#0x20
    166          	for(i=0; i<8; i++)
   \   000008   7A08         MOV     R2,#0x8
    167          	{
    168          		SPI_CLK_PORT |= BIT(SPI_CLK_PIN);//œ¬Ωµ—ÿ
   \                     ??spi_read_byte_soft_0:
   \   00000A   D295         SETB    0x90.5
    169          		ch <<= 1;
   \   00000C   E9           MOV     A,R1
   \   00000D   C3           CLR     C
   \   00000E   33           RLC     A
   \   00000F   F9           MOV     R1,A
    170          	//	asm("nop");
    171          	//	asm("nop");
    172          	//	asm("nop");
    173          		SPI_CLK_PORT &= ~BIT(SPI_CLK_PIN);
   \   000010   C295         CLR     0x90.5
    174          		asm("nop");
   \   000012   00           nop
    175          		if(SPI_DO_PORT & BIT(SPI_DO_PIN))
   \   000013   A296         MOV     C,0x90.6
   \   000015   5003         JNC     ??spi_read_byte_soft_1
    176          		{
    177          			ch |= 0x01;
   \   000017   D2E0         SETB    0xE0 /* A   */.0
   \   000019   F9           MOV     R1,A
    178          		}
    179          		else
    180          		{
    181          	//		ch &= ~0x01;
    182          		}
    183          	}
   \                     ??spi_read_byte_soft_1:
   \   00001A   1A           DEC     R2
   \   00001B   EA           MOV     A,R2
   \   00001C   70EC         JNZ     ??spi_read_byte_soft_0
    184          #endif
    185          	return ch;
   \   00001E   22           RET
    186          }
    187          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    188          u8 spi_read_byte(void)
   \                     spi_read_byte:
    189          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    190          	u8 temp;
    191          #if SOFT_SPI
    192          	temp = spi_read_byte_soft();
    193          #else
    194          	temp = spi_read_byte_hard();
    195          #endif
    196          	return temp;
   \   000000                ; Setup parameters for call to function spi_read_byte_hard
   \   000000   12....       LCALL   spi_read_byte_hard
   \   000003   22           RET
    197          }
    198          
    199          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    200          void spi_write_byte(u8 data)
   \                     spi_write_byte:
    201          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    202          #if SOFT_SPI
    203          	spi_write_byte_soft(data);
    204          #else
    205          	spi_write_byte_hard(data);
   \   000000                ; Setup parameters for call to function spi_write_byte_hard
   \   000000   12....       LCALL   spi_write_byte_hard
    206          #endif
    207          }
   \   000003   22           RET
    208          
    209          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    210          void spi_write_soft(u8 *buf, u32 addr,u16 len)
   \                     spi_write_soft:
    211          {
   \   000000   7408         MOV     A,#0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   7582EE       MOV     DPL,#-0x12
   \   000010   7583FF       MOV     DPH,#-0x1
   \   000013   12....       LCALL   ?EXT_STACK_DISP0_16
   \   000016   78..         MOV     R0,#?V0 + 4
   \   000018   12....       LCALL   ?L_MOV_X
    212          #if (USE_SD_CLK_DET && USE_SDCMD_IIC_SPIDAT)
    213          	SPI_CLK_DIR &= ~BIT(SPI_CLK_PIN);
    214          	SPI_CLK_PU &= ~BIT(SPI_CLK_PIN);          //πÿ±’…œ¿≠
    215          #endif
    216          	spi_wait_busy();
   \   00001B                ; Setup parameters for call to function spi_wait_busy
   \   00001B   12....       LCALL   spi_wait_busy
    217          	spi_write_en();
   \   00001E                ; Setup parameters for call to function spi_write_en
   \   00001E   12....       LCALL   spi_write_en
    218          	spi_cs_enable();
   \   000021                ; Setup parameters for call to function spi_cs_enable
   \   000021   12....       LCALL   spi_cs_enable
    219          	spi_write_byte(0x02);
   \   000024                ; Setup parameters for call to function spi_write_byte_hard
   \   000024   7902         MOV     R1,#0x2
   \   000026   12....       LCALL   ?Subroutine0
    220          	spi_send_addr_2(addr);
    221          	for(u16 i = 0; i < len; i++)
   \                     ??CrossCallReturnLabel_0:
   \   000029   800B         SJMP    ??CrossCallReturnLabel_2
    222          	{
    223          		spi_write_byte(*(buf+i));          //∑¢ÀÕ ˝æ›
   \                     ??spi_write_soft_0:
   \   00002B                ; Setup parameters for call to function spi_write_byte_hard
   \   00002B   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_4:
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   F9           MOV     R1,A
   \   000030   12....       LCALL   spi_write_byte_hard
    224          	}
   \   000033   12....       LCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_2:
   \   000036   C3           CLR     C
   \   000037   E5..         MOV     A,?V0 + 2
   \   000039   95..         SUBB    A,?V0 + 0
   \   00003B   E5..         MOV     A,?V0 + 3
   \   00003D   95..         SUBB    A,?V0 + 1
   \   00003F   40EA         JC      ??spi_write_soft_0
    225          	spi_cs_disable();
   \   000041                ; Setup parameters for call to function spi_cs_disable
   \   000041                REQUIRE ?Subroutine4
   \   000041                ; // Fall through to label ?Subroutine4
    226          #if (USE_SD_CLK_DET && USE_SDCMD_IIC_SPIDAT)
    227          	SPI_CLK_DIR |= BIT(SPI_CLK_PIN);
    228          	SPI_CLK_PU  |= BIT(SPI_CLK_PIN);          //¥Úø™…œ¿≠
    229          #endif
    230          }

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL   spi_cs_disable
   \                     ??Subroutine4_0:
   \   000003   7F08         MOV     R7,#0x8
   \   000005   02....       LJMP    ?FUNC_LEAVE_SP

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   E5..         MOV     A,?V0 + 2
   \   000002   2401         ADD     A,#0x1
   \   000004   F5..         MOV     ?V0 + 2,A
   \   000006   E5..         MOV     A,?V0 + 3
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F5..         MOV     ?V0 + 3,A
   \   00000C   22           RET

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   12....       LCALL   spi_write_byte_hard
   \   000003                ; Setup parameters for call to function spi_send_addr_2
   \   000003                ; Setup parameters for call to function spi_send_addr_2
   \   000003   AA..         MOV     R2,?V0 + 4
   \   000005   AB..         MOV     R3,?V0 + 5
   \   000007   AC..         MOV     R4,?V0 + 6
   \   000009   AD..         MOV     R5,?V0 + 7
   \   00000B   12....       LCALL   spi_send_addr_2
   \   00000E   75..00       MOV     ?V0 + 2,#0x0
   \   000011   75..00       MOV     ?V0 + 3,#0x0
   \   000014   22           RET
    231          
    232          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    233          void spi_read_soft(u8 *buf, u32 addr, u16 len)
   \                     spi_read_soft:
    234          {
   \   000000   7408         MOV     A,#0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   8C..         MOV     ?V0 + 0,R4
   \   00000B   8D..         MOV     ?V0 + 1,R5
   \   00000D   7582EE       MOV     DPL,#-0x12
   \   000010   7583FF       MOV     DPH,#-0x1
   \   000013   12....       LCALL   ?EXT_STACK_DISP0_16
   \   000016   78..         MOV     R0,#?V0 + 4
   \   000018   12....       LCALL   ?L_MOV_X
    235          #if (USE_SD_CLK_DET && USE_SDCMD_IIC_SPIDAT)
    236          	SPI_CLK_DIR &= ~BIT(SPI_CLK_PIN);
    237          	SPI_CLK_PU &= ~BIT(SPI_CLK_PIN);          //πÿ±’…œ¿≠
    238          #endif
    239          
    240          	spi_wait_busy();
   \   00001B                ; Setup parameters for call to function spi_wait_busy
   \   00001B   12....       LCALL   spi_wait_busy
    241          	spi_cs_enable();
   \   00001E                ; Setup parameters for call to function spi_cs_enable
   \   00001E   12....       LCALL   spi_cs_enable
    242          	spi_write_byte(0x03);
   \   000021                ; Setup parameters for call to function spi_write_byte_hard
   \   000021   7903         MOV     R1,#0x3
   \   000023   12....       LCALL   ?Subroutine0
    243          	spi_send_addr_2(addr);
    244          	for(u16 i = 0; i < len; i++)
   \                     ??CrossCallReturnLabel_1:
   \   000026   800B         SJMP    ??CrossCallReturnLabel_3
    245          	{
    246          		*(buf + i) = spi_read_byte();
   \                     ??spi_read_soft_0:
   \   000028                ; Setup parameters for call to function spi_read_byte
   \   000028   12....       LCALL   spi_read_byte
   \   00002B   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_5:
   \   00002E   E9           MOV     A,R1
   \   00002F   F0           MOVX    @DPTR,A
    247          	}
   \   000030   12....       LCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_3:
   \   000033   C3           CLR     C
   \   000034   E5..         MOV     A,?V0 + 2
   \   000036   95..         SUBB    A,?V0 + 0
   \   000038   E5..         MOV     A,?V0 + 3
   \   00003A   95..         SUBB    A,?V0 + 1
   \   00003C   40EA         JC      ??spi_read_soft_0
    248          	spi_cs_disable();
   \   00003E                ; Setup parameters for call to function spi_cs_disable
   \   00003E   80..         SJMP    ?Subroutine4
    249          #if (USE_SD_CLK_DET && USE_SDCMD_IIC_SPIDAT)
    250          	SPI_CLK_DIR |= BIT(SPI_CLK_PIN);
    251          	SPI_CLK_PU  |= BIT(SPI_CLK_PIN);          //¥Úø™…œ¿≠
    252          #endif
    253          }

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   EE           MOV     A,R6
   \   000001   25..         ADD     A,?V0 + 2
   \   000003   F582         MOV     DPL,A
   \   000005   EF           MOV     A,R7
   \   000006   35..         ADDC    A,?V0 + 3
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET
    254          
    255          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    256          void spi_write(u8 *buf, u32 addr,u16 len)
   \                     spi_write:
    257          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004   C0..         PUSH    ?V0 + 2
   \   000006   C0..         PUSH    ?V0 + 3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
   \   000008   7582F5       MOV     DPL,#-0xb
   \   00000B   7583FF       MOV     DPH,#-0x1
   \   00000E   12....       LCALL   ?EXT_STACK_DISP0_16
   \   000011   78..         MOV     R0,#?V0 + 0
   \   000013   12....       LCALL   ?L_MOV_X
    258          #if SOFT_SPI
    259          	spi_write_soft(buf, addr,len);
    260          #else
    261          	spi_write_hard(buf, addr,len);
   \   000016                ; Setup parameters for call to function spi_write_hard
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   12....       LCALL   ?PUSH_ISTACK_I_FOUR
   \   00001B   12....       LCALL   spi_write_hard
   \   00001E                REQUIRE ?Subroutine3
   \   00001E                ; // Fall through to label ?Subroutine3
    262          #endif
    263          }

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   74FC         MOV     A,#-0x4
   \   000002   12....       LCALL   ?DEALLOC_EXT_STACK8
   \   000005   D0..         POP     ?V0 + 3
   \   000007   D0..         POP     ?V0 + 2
   \   000009   D0..         POP     ?V0 + 1
   \   00000B   D0..         POP     ?V0 + 0
   \   00000D   22           RET
    264          
    265          
    266          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    267          void spi_read(u8 *buf, u32 addr, u16 len)
   \                     spi_read:
    268          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004   C0..         PUSH    ?V0 + 2
   \   000006   C0..         PUSH    ?V0 + 3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
   \   000008   7582F5       MOV     DPL,#-0xb
   \   00000B   7583FF       MOV     DPH,#-0x1
   \   00000E   12....       LCALL   ?EXT_STACK_DISP0_16
   \   000011   78..         MOV     R0,#?V0 + 0
   \   000013   12....       LCALL   ?L_MOV_X
    269          #if 0	// dump index read
    270          	//if(addr < 0x400L)
    271          	{
    272          	//	printf("\n%04X,%03X_",(u16)addr, (u16)flash_music.pos);
    273          		printf("\n%04X_", (u16)flash_music.pos);
    274          	}
    275          #endif
    276          
    277          #if SOFT_SPI
    278          	spi_read_soft(buf, addr,len);
    279          #else
    280          	spi_read_hard(buf, addr,len);
   \   000016                ; Setup parameters for call to function spi_read_hard
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   12....       LCALL   ?PUSH_ISTACK_I_FOUR
   \   00001B   12....       LCALL   spi_read_hard
   \   00001E   80..         SJMP    ?Subroutine3
    281          #endif
    282          
    283          #if 0
    284          	if((sys_ctl.mode_play == ITEM_LOOP_SINGLE) &&
    285          		(flash_music.len == flash_music.pos+2) &&
    286          		(music_get_status() == STATUS_PLAY_PLAYING)
    287          		)
    288          		flash_music.pos = 0;
    289          #endif
    290          }
    291          
    292          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    293          u32 spi_readID(u8 bCmd)
   \                     spi_readID:
    294          {
   \   000000   7409         MOV     A,#0x9
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   7404         MOV     A,#0x4
   \   000007   12....       LCALL   ?ALLOC_EXT_STACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
    295          	u8 cmd[4],i;
    296          	u32 dwFlashID = 0;
   \   00000C   90....       MOV     DPTR,#__Constant_0
   \   00000F   78..         MOV     R0,#?V0 + 4
   \   000011   12....       LCALL   ?L_MOV_C
    297          	spi_cs_enable();
   \   000014                ; Setup parameters for call to function spi_cs_enable
   \   000014   12....       LCALL   spi_cs_enable
    298          	//printf("bCmd = 0x%x!!!\n", bCmd );
    299          	if((bCmd == 0x90) || (bCmd == 0xAB))
   \   000017   7490         MOV     A,#-0x70
   \   000019   6E           XRL     A,R6
   \   00001A   6005         JZ      ??spi_readID_0
   \   00001C   74AB         MOV     A,#-0x55
   \   00001E   6E           XRL     A,R6
   \   00001F   7013         JNZ     ??spi_readID_1
    300          	{
    301          		spi_write_byte(bCmd);
   \                     ??spi_readID_0:
   \   000021                ; Setup parameters for call to function spi_write_byte_hard
   \   000021   EE           MOV     A,R6
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   spi_write_byte_hard
    302          		spi_write_byte(0x00);
   \   000026                ; Setup parameters for call to function spi_write_byte_hard
   \   000026   7900         MOV     R1,#0x0
   \   000028   12....       LCALL   spi_write_byte_hard
    303          		spi_write_byte(0x00);
   \   00002B                ; Setup parameters for call to function spi_write_byte_hard
   \   00002B   7900         MOV     R1,#0x0
   \   00002D   12....       LCALL   spi_write_byte_hard
    304          		spi_write_byte(0x00);
   \   000030                ; Setup parameters for call to function spi_write_byte_hard
   \   000030   7900         MOV     R1,#0x0
   \   000032   8002         SJMP    ??spi_readID_2
    305          	}
    306          	else
    307          	{
    308          		spi_write_byte(bCmd);
   \                     ??spi_readID_1:
   \   000034                ; Setup parameters for call to function spi_write_byte_hard
   \   000034   EE           MOV     A,R6
   \   000035   F9           MOV     R1,A
   \                     ??spi_readID_2:
   \   000036   12....       LCALL   spi_write_byte_hard
    309          	}
    310          
    311          	for(i=0; i<4; i++)
   \   000039   75..00       MOV     ?V0 + 8,#0x0
    312          	{
    313          		cmd[i] = spi_read_byte();
   \                     ??spi_readID_3:
   \   00003C   85....       MOV     ?V0 + 0,?V0 + 8
   \   00003F   7582FB       MOV     DPL,#-0x5
   \   000042   7583FF       MOV     DPH,#-0x1
   \   000045   12....       LCALL   ?EXT_STACK_DISP0_16
   \   000048   E582         MOV     A,DPL
   \   00004A   25..         ADD     A,?V0 + 0
   \   00004C   FE           MOV     R6,A
   \   00004D   E583         MOV     A,DPH
   \   00004F   3400         ADDC    A,#0x0
   \   000051   FF           MOV     R7,A
   \   000052                ; Setup parameters for call to function spi_read_byte
   \   000052   12....       LCALL   spi_read_byte
   \   000055   E9           MOV     A,R1
   \   000056   8E82         MOV     DPL,R6
   \   000058   8F83         MOV     DPH,R7
   \   00005A   F0           MOVX    @DPTR,A
    314          		dwFlashID = (dwFlashID<<8) + cmd[i];
   \   00005B   7408         MOV     A,#0x8
   \   00005D   78..         MOV     R0,#?V0 + 4
   \   00005F   12....       LCALL   ?L_SHL
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F5..         MOV     ?V0 + 0,A
   \   000065   75..00       MOV     ?V0 + 1,#0x0
   \   000068   75..00       MOV     ?V0 + 2,#0x0
   \   00006B   75..00       MOV     ?V0 + 3,#0x0
   \   00006E   78..         MOV     R0,#?V0 + 4
   \   000070   79..         MOV     R1,#?V0 + 0
   \   000072   12....       LCALL   ?L_ADD
    315          	}
   \   000075   05..         INC     ?V0 + 8
   \   000077   E5..         MOV     A,?V0 + 8
   \   000079   C3           CLR     C
   \   00007A   9404         SUBB    A,#0x4
   \   00007C   40BE         JC      ??spi_readID_3
    316          	spi_cs_disable();
   \   00007E                ; Setup parameters for call to function spi_cs_disable
   \   00007E   12....       LCALL   spi_cs_disable
    317          	//printf("CUS spi_readID:[0x%8lx]\n",dwFlashID);
    318          	return dwFlashID;
   \   000081   AA..         MOV     R2,?V0 + 4
   \   000083   AB..         MOV     R3,?V0 + 5
   \   000085   AC..         MOV     R4,?V0 + 6
   \   000087   AD..         MOV     R5,?V0 + 7
   \   000089   74FC         MOV     A,#-0x4
   \   00008B   12....       LCALL   ?DEALLOC_EXT_STACK8
   \   00008E   7F09         MOV     R7,#0x9
   \   000090   02....       LJMP    ?FUNC_LEAVE_SP
    319          }
    320          
    321          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    322          bool spi_flash_init(void)
   \                     spi_flash_init:
    323          {
   \   000000   7404         MOV     A,#0x4
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
    324          #if (USE_SD_CLK_DET && USE_SDCMD_IIC_SPIDAT)
    325          	SPI_CLK_DIR &= ~BIT(SPI_CLK_PIN);
    326          	SPI_CLK_PU  &= ~BIT(SPI_CLK_PIN);          //πÿ±’…œ¿≠
    327          #endif
    328          	u8 i;
    329          	u32 FlashID;
    330          	bool ret_state;
    331          
    332          	/*if(!(SD1_CHECK_PORT & BIT(SD1_CHECK_PIN)))        //SDø®≤Â»ÎºÏ≤‚IOª·±ª¿≠µÕ
    333          	{	// ”– SDø® ±ŒﬁSPI-Flash
    334          		printf("Have SD Card\n");
    335          		return false;
    336          	}*/
    337          
    338          #if (SPI_MODE_SEL == SPI_TWO_WIRES_MODE)
    339          	SPI_2Wire_RX();
   \   000005   43BB40       ORL     0xbb,#0x40
   \   000008   43D620       ORL     0xd6,#0x20
    340          #endif
    341          	flash_chipnum = 0x01;               //ƒ¨»œŒ™µ⁄“ªøÈflash
   \   00000B   7401         MOV     A,#0x1
   \   00000D   90....       MOV     DPTR,#flash_chipnum
   \   000010   F0           MOVX    @DPTR,A
    342          	for(ret_state = false, i=0; i<4; i++)
   \   000011   C2..         CLR     ?VB.0
    343          	{
    344          		FlashID = spi_readID(ReadIDCMD[i]);
   \                     ??spi_flash_init_0:
   \   000013                ; Setup parameters for call to function spi_readID
   \   000013   8E..         MOV     ?V0 + 0,R6
   \   000015   E5..         MOV     A,?V0 + 0
   \   000017   24..         ADD     A,#(ReadIDCMD & 0xff)
   \   000019   F582         MOV     DPL,A
   \   00001B   E4           CLR     A
   \   00001C   34..         ADDC    A,#((ReadIDCMD >> 8) & 0xff)
   \   00001E   F583         MOV     DPH,A
   \   000020   E4           CLR     A
   \   000021   93           MOVC    A,@A+DPTR
   \   000022   F9           MOV     R1,A
   \   000023   12....       LCALL   spi_readID
   \   000026   8A..         MOV     ?V0 + 0,R2
   \   000028   8B..         MOV     ?V0 + 1,R3
   \   00002A   8C..         MOV     ?V0 + 2,R4
   \   00002C   8D..         MOV     ?V0 + 3,R5
    345          		//printf("ID:%xH,%08lxH\n",ReadIDCMD[i],FlashID);   //≤Èø¥ «∑ÒºÏ≤ÈµΩflash
    346          		if((FlashID != 0xFFFFFFFF) && (FlashID != 0x0) && ((FlashID & 0x00FFFFFF) != 0x00FFFFFF))
   \   00002E   90....       MOV     DPTR,#__Constant_ffffffff
   \   000031   78..         MOV     R0,#?V0 + 0
   \   000033   12....       LCALL   ?L_EQ_C
   \   000036   601D         JZ      ??spi_flash_init_1
   \   000038   90....       MOV     DPTR,#__Constant_0
   \   00003B   78..         MOV     R0,#?V0 + 0
   \   00003D   12....       LCALL   ?L_EQ_C
   \   000040   6013         JZ      ??spi_flash_init_1
   \   000042   90....       MOV     DPTR,#__Constant_ffffff
   \   000045   78..         MOV     R0,#?V0 + 0
   \   000047   12....       LCALL   ?L_AND_C
   \   00004A   78..         MOV     R0,#?V0 + 0
   \   00004C   12....       LCALL   ?L_EQ_C
   \   00004F   6004         JZ      ??spi_flash_init_1
    347          		{
    348          #if (USE_SD_CLK_DET && USE_SDCMD_IIC_SPIDAT)
    349          			SPI_CLK_DIR |= BIT(SPI_CLK_PIN);
    350          			SPI_CLK_PU  |= BIT(SPI_CLK_PIN);          //πÿ±’…œ¿≠
    351          #endif
    352          			ret_state = true;
   \   000051   D2..         SETB    ?VB.0
    353          			break;
   \   000053   800E         SJMP    ??spi_flash_init_2
    354          		}
    355          	}
   \                     ??spi_flash_init_1:
   \   000055   0E           INC     R6
   \   000056   EE           MOV     A,R6
   \   000057   C3           CLR     C
   \   000058   9404         SUBB    A,#0x4
   \   00005A   40B7         JC      ??spi_flash_init_0
    356          	if(ret_state == false)
    357          		printf("Error\n");
   \   00005C                ; Setup parameters for call to function my_printf
   \   00005C   7A..         MOV     R2,#(`?<Constant "Error\\n">` & 0xff)
   \   00005E   7B..         MOV     R3,#((`?<Constant "Error\\n">` >> 8) & 0xff)
   \   000060   12....       LCALL   my_printf
    358          #if (USE_SD_CLK_DET && USE_SDCMD_IIC_SPIDAT)
    359          	SPI_CLK_DIR |= BIT(SPI_CLK_PIN);
    360          	SPI_CLK_PU  |= BIT(SPI_CLK_PIN);	//πÿ±’…œ¿≠
    361          #endif
    362          	return ret_state;
   \                     ??spi_flash_init_2:
   \   000063   A2..         MOV     C,?VB.0
   \   000065   7F04         MOV     R7,#0x4
   \   000067   02....       LJMP    ?FUNC_LEAVE_SP
    363          }
    364          
    365          //spi–¥»Î“ªsector ˝æ›
    366          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    367          bool spi_sector_write(u32 sect,void *buf)//÷∏∂®…»«¯£¨–¥512byte ˝æ›
   \                     spi_sector_write:
    368          {
   \   000000   740C         MOV     A,#0xc
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   7582EC       MOV     DPL,#-0x14
   \   000010   7583FF       MOV     DPH,#-0x1
   \   000013   12....       LCALL   ?EXT_STACK_DISP0_16
   \   000016   E0           MOVX    A,@DPTR
   \   000017   F8           MOV     R0,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   F9           MOV     R1,A
   \   00001B   E8           MOV     A,R0
   \   00001C   FE           MOV     R6,A
   \   00001D   E9           MOV     A,R1
   \   00001E   FF           MOV     R7,A
    369          	u32 i,temp1,temp2,addr;
    370          	u8 *temp3;
    371          	u8 *buf_addr;
    372          
    373          	buf_addr = (u8 *)buf;
    374          
    375          	temp1 = sect/8;
    376          	temp2 = sect;
    377          	temp2 = temp2 * 0x200UL;
   \   00001F   7409         MOV     A,#0x9
   \   000021   78..         MOV     R0,#?V0 + 0
   \   000023   12....       LCALL   ?L_SHL
   \   000026   F5..         MOV     ?V0 + 4,A
   \   000028   85....       MOV     ?V0 + 5,?V0 + 1
   \   00002B   85....       MOV     ?V0 + 6,?V0 + 2
   \   00002E   85....       MOV     ?V0 + 7,?V0 + 3
    378          
    379          	addr = temp1 * 0x1000UL;
   \   000031   90....       MOV     DPTR,#__Constant_fffff000
   \   000034   78..         MOV     R0,#?V0 + 0
   \   000036   12....       LCALL   ?L_AND_C
    380          	if(addr > 8 * 1024 * 1024UL)     //≥¨π˝SPI Flashµƒ»›¡ø
   \   000039   90....       MOV     DPTR,#__Constant_800001
   \   00003C   78..         MOV     R0,#?V0 + 8
   \   00003E   12....       LCALL   ?L_MOV_C
   \   000041   78..         MOV     R0,#?V0 + 8
   \   000043   79..         MOV     R1,#?V0 + 0
   \   000045   12....       LCALL   ?UL_GT
   \   000048   4003         JC      ??spi_sector_write_0
    381          	{
    382          		return false;
   \   00004A   C3           CLR     C
   \   00004B   8054         SJMP    ??spi_sector_write_1
    383          	}
    384          	spi_sector_erase(addr);
   \                     ??spi_sector_write_0:
   \   00004D                ; Setup parameters for call to function spi_sector_erase
   \   00004D   AA..         MOV     R2,?V0 + 0
   \   00004F   AB..         MOV     R3,?V0 + 1
   \   000051   AC..         MOV     R4,?V0 + 2
   \   000053   AD..         MOV     R5,?V0 + 3
   \   000055   12....       LCALL   spi_sector_erase
    385          
    386          	for(i = 0; i < 2; i++)
   \   000058   90....       MOV     DPTR,#__Constant_0
   \   00005B   78..         MOV     R0,#?V0 + 8
   \   00005D   12....       LCALL   ?L_MOV_C
    387          	{
    388          		temp3 = buf_addr + (i * 0x100);
    389          		spi_write(temp3,temp2,256);
   \                     ??spi_sector_write_2:
   \   000060                ; Setup parameters for call to function spi_write_hard
   \   000060   78..         MOV     R0,#?V0 + 4
   \   000062   12....       LCALL   ?PUSH_ISTACK_I_FOUR
   \   000065   FC           MOV     R4,A
   \   000066   7D01         MOV     R5,#0x1
   \   000068   85....       MOV     ?V0 + 0,?V0 + 8
   \   00006B   E5..         MOV     A,?V0 + 0
   \   00006D   F5..         MOV     ?V0 + 1,A
   \   00006F   EE           MOV     A,R6
   \   000070   2400         ADD     A,#0x0
   \   000072   FA           MOV     R2,A
   \   000073   EF           MOV     A,R7
   \   000074   35..         ADDC    A,?V0 + 1
   \   000076   FB           MOV     R3,A
   \   000077   12....       LCALL   spi_write_hard
   \   00007A   74FC         MOV     A,#-0x4
   \   00007C   12....       LCALL   ?DEALLOC_EXT_STACK8
    390          		temp2 = temp2 + 0x100;
   \   00007F   90....       MOV     DPTR,#__Constant_100
   \   000082   78..         MOV     R0,#?V0 + 4
   \   000084   12....       LCALL   ?L_ADD_C
    391          	}
   \   000087   90....       MOV     DPTR,#__Constant_1
   \   00008A   78..         MOV     R0,#?V0 + 8
   \   00008C   12....       LCALL   ?L_ADD_C
   \   00008F   90....       MOV     DPTR,#__Constant_2
   \   000092   78..         MOV     R0,#?V0 + 0
   \   000094   12....       LCALL   ?L_MOV_C
   \   000097   78..         MOV     R0,#?V0 + 0
   \   000099   79..         MOV     R1,#?V0 + 8
   \   00009B   12....       LCALL   ?UL_GT
   \   00009E   40C0         JC      ??spi_sector_write_2
    392          	return true;
   \   0000A0   D3           SETB    C
   \                     ??spi_sector_write_1:
   \   0000A1   7F0C         MOV     R7,#0xc
   \   0000A3   02....       LJMP    ?FUNC_LEAVE_SP
    393          }
    394          
    395          
    396          //spi∂¡»°“ªsector ˝æ›
    397          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    398          bool spi_sector_read(u32 sect,void *buf)
   \                     spi_sector_read:
    399          {
   \   000000   7408         MOV     A,#0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
   \   00000D   7582F0       MOV     DPL,#-0x10
   \   000010   7583FF       MOV     DPH,#-0x1
   \   000013   12....       LCALL   ?EXT_STACK_DISP0_16
   \   000016   E0           MOVX    A,@DPTR
   \   000017   FA           MOV     R2,A
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FB           MOV     R3,A
    400          	u32 addr = sect * 0x200UL;
   \   00001B   7409         MOV     A,#0x9
   \   00001D   78..         MOV     R0,#?V0 + 0
   \   00001F   12....       LCALL   ?L_SHL
    401          	if(addr > 8 * 1024 * 1024UL)           //≥¨π˝SPI Flashµƒ»›¡ø
   \   000022   90....       MOV     DPTR,#__Constant_800001
   \   000025   78..         MOV     R0,#?V0 + 4
   \   000027   12....       LCALL   ?L_MOV_C
   \   00002A   78..         MOV     R0,#?V0 + 4
   \   00002C   79..         MOV     R1,#?V0 + 0
   \   00002E   12....       LCALL   ?UL_GT
   \   000031   400A         JC      ??spi_sector_read_0
    402          	{
    403          		printf("return\n");
   \   000033                ; Setup parameters for call to function my_printf
   \   000033   7A..         MOV     R2,#(`?<Constant "return\\n">` & 0xff)
   \   000035   7B..         MOV     R3,#((`?<Constant "return\\n">` >> 8) & 0xff)
   \   000037   12....       LCALL   my_printf
    404          		return false;
   \   00003A   C3           CLR     C
   \   00003B   8011         SJMP    ??spi_sector_read_1
    405          	}
    406          	
    407          	spi_read(buf,addr,512);
   \                     ??spi_sector_read_0:
   \   00003D                ; Setup parameters for call to function spi_read_hard
   \   00003D   78..         MOV     R0,#?V0 + 0
   \   00003F   12....       LCALL   ?PUSH_ISTACK_I_FOUR
   \   000042   FC           MOV     R4,A
   \   000043   7D02         MOV     R5,#0x2
   \   000045   12....       LCALL   spi_read_hard
   \   000048   74FC         MOV     A,#-0x4
   \   00004A   12....       LCALL   ?DEALLOC_EXT_STACK8
    408          
    409          	return true;
   \   00004D   D3           SETB    C
   \                     ??spi_sector_read_1:
   \   00004E   02....       LJMP    ??Subroutine4_0
    410          }
    411          
    412          
    413          //µ»¥˝≤•∑≈
    414          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    415          void spi_music_wait(void)
   \                     spi_music_wait:
    416          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8006         SJMP    ??spi_music_wait_0
    417          	while(music_get_status()> STATUS_PLAY_STOPPING)
    418          	{
    419          		WATCHDOG_CLR();
   \                     ??spi_music_wait_1:
   \   000002   43F720       ORL     0xf7,#0x20
    420          		music_event();
   \   000005                ; Setup parameters for call to function music_event
   \   000005   12....       LCALL   music_event
    421          	}
   \                     ??spi_music_wait_0:
   \   000008                ; Setup parameters for call to function music_get_status
   \   000008   12....       LCALL   music_get_status
   \   00000B   E9           MOV     A,R1
   \   00000C   C3           CLR     C
   \   00000D   9402         SUBB    A,#0x2
   \   00000F   50F1         JNC     ??spi_music_wait_1
    422          	music_stop();
   \   000011                ; Setup parameters for call to function music_stop
   \   000011   12....       LCALL   music_stop
    423          	u_spi.spi_music_flag = 0;
   \   000014   E4           CLR     A
   \   000015   90....       MOV     DPTR,#u_spi
   \   000018   F0           MOVX    @DPTR,A
    424          }
   \   000019   22           RET
    425          
    426          //SPI MP3 ”Ô“Ù≤•±®
    427          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    428          void mp3_res_play(u8 music_name)
   \                     mp3_res_play:
    429          {
   \   000000   EE           MOV     A,R6
   \   000001   C0E0         PUSH    A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
   \   000003   E9           MOV     A,R1
   \   000004   FE           MOV     R6,A
    430          
    431          	music_stop();
   \   000005                ; Setup parameters for call to function music_stop
   \   000005   12....       LCALL   music_stop
    432          	u_spi.spi_music_flag = 1;
   \   000008   7401         MOV     A,#0x1
   \   00000A   90....       MOV     DPTR,#u_spi
   \   00000D   F0           MOVX    @DPTR,A
    433          	spi_mp3_index_read(music_name);//∂¡»°Flash“Ù¿÷À˜“˝–≈œ¢
   \   00000E                ; Setup parameters for call to function spi_mp3_index_read_program
   \   00000E   EE           MOV     A,R6
   \   00000F   F9           MOV     R1,A
   \   000010   12....       LCALL   spi_mp3_index_read_program
    434          	music_init();
   \   000013                ; Setup parameters for call to function music_init
   \   000013   12....       LCALL   music_init
    435          	music_play();
   \   000016                ; Setup parameters for call to function music_play
   \   000016   12....       LCALL   music_play
    436          #if LED_EN
    437          	ocx.led_sta = LED_STA_FAST_GLITTER;
    438          #endif
    439          }
   \   000019   D0E0         POP     A
   \   00001B   FE           MOV     R6,A
   \   00001C   22           RET
    440          
    441          //µ»¥˝SPI MP3 ”Ô“Ù≤•∑≈ÕÍ≥…
    442          // music_name from 0 to N
    443          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    444          void mp3_res_play_wait(u8 music_name)
   \                     mp3_res_play_wait:
    445          {
   \   000000   EE           MOV     A,R6
   \   000001   C0E0         PUSH    A
   \   000003   C0..         PUSH    ?V0 + 0
   \   000005   C0..         PUSH    ?V0 + 1
   \   000007                ; Saved register size: 3
   \   000007                ; Auto size: 0
    446          	u8 music_num;
    447          	music_num = (u8)get_dirstart();
   \   000007                ; Setup parameters for call to function get_dirstart
   \   000007   12....       LCALL   get_dirstart
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
    448          	printf("res cur num:%d\n",music_num);
   \   00000C                ; Setup parameters for call to function my_printf
   \   00000C   8E..         MOV     ?V0 + 0,R6
   \   00000E   75..00       MOV     ?V0 + 1,#0x0
   \   000011   C0..         PUSH    ?V0 + 0
   \   000013   C0..         PUSH    ?V0 + 1
   \   000015   7A..         MOV     R2,#(`?<Constant "res cur num:%d\\n">` & 0xff)
   \   000017   7B..         MOV     R3,#((`?<Constant "res cur num:%d\\n">` >> 8) & 0xff)
   \   000019   12....       LCALL   my_printf
   \   00001C   D0E0         POP     A
   \   00001E   D0E0         POP     A
    449          	mp3_res_play(music_num);
   \   000020                ; Setup parameters for call to function mp3_res_play
   \   000020   EE           MOV     A,R6
   \   000021   F9           MOV     R1,A
   \   000022   12....       LCALL   mp3_res_play
    450          	spi_music_wait();
   \   000025                ; Setup parameters for call to function spi_music_wait
   \   000025   12....       LCALL   spi_music_wait
    451          }
   \   000028   D0..         POP     ?V0 + 1
   \   00002A   D0..         POP     ?V0 + 0
   \   00002C   D0E0         POP     A
   \   00002E   FE           MOV     R6,A
   \   00002F   22           RET
    452          
    453          
    454          // music_name from 0 to N
    455          #pragma location="USER_SPI_SEG"

   \                                 In segment USER_SPI_SEG, align 1, keep-with-next
    456          void spi_mp3_index_read(u8 music_name)
   \                     spi_mp3_index_read:
    457          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    458          #if SPI_PC_DOWNLOAD
    459          	spi_mp3_index_read_pc(music_name);
    460          #else
    461          	spi_mp3_index_read_program(music_name);
   \   000000                ; Setup parameters for call to function spi_mp3_index_read_program
   \   000000   12....       LCALL   spi_mp3_index_read_program
    462          #endif
    463          }
   \   000003   22           RET
    464          
    465          
    466          extern bool usb_host_mass_read_do(void *buf, u32 lba, u8 offset);
    467          extern void usb_host_set_fail(void);

   \                                 In segment NEAR_CODE, align 1, keep-with-next
    468          bool usb_read1(void *buf, u32 lba)
   \                     usb_read1:
    469          {
   \   000000   7404         MOV     A,#0x4
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
   \   000005   7582F2       MOV     DPL,#-0xe
   \   000008   7583FF       MOV     DPH,#-0x1
   \   00000B   12....       LCALL   ?EXT_STACK_DISP0_16
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   12....       LCALL   ?L_MOV_X
    470          	u8 offset = 0;
    471          	bool res = usb_host_mass_read_do(buf, lba, offset);
   \   000013                ; Setup parameters for call to function usb_host_mass_read_do
   \   000013   78..         MOV     R0,#?V0 + 0
   \   000015   12....       LCALL   ?PUSH_ISTACK_I_FOUR
   \   000018   12....       LCALL   usb_host_mass_read_do
   \   00001B   74FC         MOV     A,#-0x4
   \   00001D   12....       LCALL   ?DEALLOC_EXT_STACK8
   \   000020   92..         MOV     ?VB.0,C
    472          	if(!res)
   \   000022   4003         JC      ??usb_read1_0
    473          	{
    474          		usb_host_set_fail();
   \   000024                ; Setup parameters for call to function usb_host_set_fail
   \   000024   12....       LCALL   usb_host_set_fail
    475          	}
    476          	return !res;
   \                     ??usb_read1_0:
   \   000027   A2..         MOV     C,?VB.0
   \   000029   B3           CPL     C
   \   00002A   7F04         MOV     R7,#0x4
   \   00002C   02....       LJMP    ?FUNC_LEAVE_SP
    477          }

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "Error\\n">`:
   \   000000   4572726F     DB "Error\012"
   \            720A00  

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "return\\n">`:
   \   000000   72657475     DB "return\012"
   \            726E0A00

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "res cur num:%d\\n">`:
   \   000000   72657320     DB "res cur num:%d\012"
   \            63757220
   \            6E756D3A
   \            25640A00

   \                                 In segment CODE_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In segment CODE_C, align 1
   \                     __Constant_ffffffff:
   \   000000   FFFFFFFF     DD 4294967295

   \                                 In segment CODE_C, align 1
   \                     __Constant_ffffff:
   \   000000   FFFFFF00     DD 16777215

   \                                 In segment CODE_C, align 1
   \                     __Constant_fffff000:
   \   000000   00F0FFFF     DD 4294963200

   \                                 In segment CODE_C, align 1
   \                     __Constant_800001:
   \   000000   01008000     DD 8388609

   \                                 In segment CODE_C, align 1
   \                     __Constant_100:
   \   000000   00010000     DD 256

   \                                 In segment CODE_C, align 1
   \                     __Constant_1:
   \   000000   01000000     DD 1

   \                                 In segment CODE_C, align 1
   \                     __Constant_2:
   \   000000   02000000     DD 2
    478          

   Maximum stack usage in bytes:

     Function                       EXT_STACK PSTACK XSTACK
     --------                       --------- ------ ------
     mp3_res_play                          4      0      0
       -> music_stop                       2      0      0
       -> spi_mp3_index_read_program
                                           2      0      0
       -> music_init                       2      0      0
       -> music_play                       2      0      0
     mp3_res_play_wait                     5      0      0
       -> get_dirstart                     6      0      0
       -> my_printf                       10      0      0
       -> mp3_res_play                     6      0      0
       -> spi_music_wait                   6      0      0
     spi_cs_disable                       16      0      0
     spi_cs_enable                        16      0      0
     spi_flash_init                        7      0      0
       -> spi_readID                      14      0      0
       -> my_printf                       14      0      0
     spi_mp3_index_read                    0      0      0
       -> spi_mp3_index_read_program
                                           0      0      0
     spi_music_wait                        3      0      0
       -> music_event                      0      0      0
       -> music_get_status                 0      0      0
       -> music_stop                       0      0      0
     spi_port_init                         0      0      0
       -> spi_init                         0      0      0
     spi_read                             12      0      0
       -> spi_read_hard                   16      0      0
     spi_readID                           24      0      0
       -> spi_cs_enable                   32      0      0
       -> spi_write_byte_hard             32      0      0
       -> spi_write_byte_hard             32      0      0
       -> spi_write_byte_hard             32      0      0
       -> spi_write_byte_hard             32      0      0
       -> spi_write_byte_hard             32      0      0
       -> spi_read_byte                   32      0      0
       -> spi_cs_disable                  32      0      0
     spi_read_byte                        16      0      0
       -> spi_read_byte_hard               0      0      0
     spi_read_byte_soft                    0      0      0
     spi_read_soft                        16      0      0
       -> spi_wait_busy                   22      0      0
       -> spi_cs_enable                   22      0      0
       -> spi_write_byte_hard             22      0      0
       -> spi_send_addr_2                 22      0      0
       -> spi_read_byte                   22      0      0
       -> spi_cs_disable                  22      0      0
     spi_sd_mux_enter                      0      0      0
     spi_sd_mux_exit                       0      0      0
       -> device_is_online                 0      0      0
       -> device_is_online                 0      0      0
     spi_sector_read                      17      0      0
       -> my_printf                       22      0      0
       -> spi_read_hard                   30      0      0
     spi_sector_write                     21      0      0
       -> spi_sector_erase                30      0      0
       -> spi_write_hard                  38      0      0
     spi_write                            12      0      0
       -> spi_write_hard                  16      0      0
     spi_write_byte                        0      0      0
       -> spi_write_byte_hard              0      0      0
     spi_write_byte_soft                   0      0      0
     spi_write_soft                       15      0      0
       -> spi_wait_busy                   22      0      0
       -> spi_write_en                    22      0      0
       -> spi_cs_enable                   22      0      0
       -> spi_write_byte_hard             22      0      0
       -> spi_send_addr_2                 22      0      0
       -> spi_write_byte_hard             22      0      0
       -> spi_cs_disable                  22      0      0
     usb_read1                            15      0      0
       -> usb_host_mass_read_do           22      0      0
       -> usb_host_set_fail               14      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     SDCON0                            1
     P1                                1
     P1DIR                             1
     SPI0CON                           1
     WDTCON                            1
     u_spi                             3
     flash_chipnum                     1
     ReadIDCMD                         4
     spi_port_init                    23
     spi_sd_mux_enter                  4
     spi_sd_mux_exit                  18
     spi_cs_enable                    16
     spi_cs_disable                   16
     spi_write_byte_soft              25
     spi_read_byte_soft               31
     spi_read_byte                     4
     spi_write_byte                    4
     spi_write_soft                   65
     ?Subroutine4                      8
     ?Subroutine1                     13
     ?Subroutine0                     21
     spi_read_soft                    64
     ?Subroutine2                     11
     spi_write                        30
     ?Subroutine3                     14
     spi_read                         32
     spi_readID                      147
     spi_flash_init                  106
     spi_sector_write                166
     spi_sector_read                  81
     spi_music_wait                   26
     mp3_res_play                     29
     mp3_res_play_wait                48
     spi_mp3_index_read                4
     usb_read1                        47
     ?<Constant "Error\n">             7
     ?<Constant "return\n">            8
     ?<Constant "res cur num:%d\n">   16
     __Constant_0                      4
     __Constant_ffffffff               4
     __Constant_ffffff                 4
     __Constant_fffff000               4
     __Constant_800001                 4
     __Constant_100                    4
     __Constant_1                      4
     __Constant_2                      4

 
    67 bytes in segment CODE_C
    47 bytes in segment NEAR_CODE
     5 bytes in segment SFR_AN
 1 006 bytes in segment USER_SPI_SEG
     3 bytes in segment XDATA_N
     1 byte  in segment XDATA_Z
 
 1 088 bytes of CODE  memory (+ 32 bytes shared)
     0 bytes of DATA  memory (+  5 bytes shared)
     4 bytes of XDATA memory

Errors: none
Warnings: none
