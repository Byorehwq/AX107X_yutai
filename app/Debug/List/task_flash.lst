##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   29/Jun/2018  19:55:10 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  near                                              #
#    Data model         =  large                                             #
#    Calling convention =  extended stack reentrant                          #
#    Constant location  =  code                                              #
#    Extended stack     =  enabled                                           #
#    Dptr setup         =  1,16                                              #
#    Source file        =  I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\task\task_flash #
#                          .c                                                #
#    Command line       =  -I E:\software\8051\INC\ -I                       #
#                          E:\software\8051\INC\CLIB\ -I                     #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\COMMON\ -I      #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\INC\ -I         #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\config\ -I      #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\api\ -I         #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\fm\ -I          #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\fat\ -I         #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\display\ -I     #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\display\theme_d #
#                          efault\ -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073 #
#                          A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\disp #
#                          lay\led\ -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC07 #
#                          3A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\dis #
#                          play\lcd\ -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC0 #
#                          73A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\ta #
#                          sk\ -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇 #
#                          泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\user\    #
#                          -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_A #
#                          X1071_xxxxxxxx_20180629_Merlin_1\app\mem\ -I      #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\module\ -I      #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\key\ -I         #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\startmusic\ -I  #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\spi\ -D         #
#                          AX107X_TAG -lC I:\a_wangqun\宇泰_睡眠仪_KNP08\18B #
#                          C073A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\ #
#                          Debug\List\ -o I:\a_wangqun\宇泰_睡眠仪_KNP08\18B #
#                          C073A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\ #
#                          Debug\Obj\ -e -z9 --core=plain --dptr=16,1        #
#                          --data_model=large --code_model=near              #
#                          --calling_convention=ext_stack_reentrant          #
#                          --place_constants=code --nr_virtual_regs 20       #
#                          --extended_stack I:\a_wangqun\宇泰_睡眠仪_KNP08\1 #
#                          8BC073A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\ap #
#                          p\task\task_flash.c                               #
#    List file          =  I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\Debug\List\task #
#                          _flash.lst                                        #
#    Object file        =  I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\Debug\Obj\task_ #
#                          flash.r51                                         #
#                                                                            #
#                                                                            #
##############################################################################

I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\task\task_flash.c
      1          /*****************************************************************************
      2           * Module    : Task
      3           * File      : task_mp3res.c
      4           * Author    : Hanny
      5           * Email     : coldney@yahoo.com.cn
      6           * Function  : SPI音乐播放任务流程
      7           *****************************************************************************/
      8          #include "include.h"

   \                                 In segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1
      9          #include "User_key.h"
     10          #include "spi.h"
     11          extern bool SD_FLAG;
     12          extern u8 count_1min;
     13          extern bool Timer1_flag;
     14          
     15          #if TASK_FLASH_EN
     16          extern bool first;
     17          //修改资源中各个分类的歌曲数目后需要修改此表
     18          #pragma constseg="TASK_FLASH_CONST"

   \                                 In segment TASK_FLASH_CONST, align 1
     19          IAR_CONST u8 flash_music_total_tbl[7] =
   \                     flash_music_total_tbl:
   \   000000   07020201     DB 7, 2, 2, 1, 4, 5, 6
   \            040506  
     20          {
     21          	VOICE_TOTAL,CHILDREN_TOTAL	,ENGLISH_TOTAL,STORY_TOTAL,HABIT_TOTAL,POEM_TOTAL,JOKE_TOTAL
     22          };
     23          
     24          #pragma constseg=default
     25          
     26          extern u8 t_pwn_duty1, t_pwn_duty2;   // Duty range from 0x00 to 0xFF
     27          
     28          extern u8 decext_buf[0x400];

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
     29          u16 flash_music_total=0;
   \                     flash_music_total:
   \   000000                DS 2

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
     30          u8  flash_long_change=0;
   \                     flash_long_change:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
     31          bool alarm_flag;
   \                     alarm_flag:
   \   000000                DS 1
     32          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
     33          void task_flash_music_display(void)
   \                     task_flash_music_display:
     34          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     35          	task_music_display();
   \   000000                ; Setup parameters for call to function task_music_display
   \   000000   12....       LCALL   task_music_display
     36          }
   \   000003   22           RET
     37          
     38          //获取当前文件所在目录的第一个文件
     39          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
     40          u16 get_dirstart(void)
   \                     get_dirstart:
     41          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     42          	printf("dir_start:%d\n",sys_ctl.flash_music_sta);
   \   000000                ; Setup parameters for call to function my_printf
   \   000000   90....       MOV     DPTR,#(sys_ctl + 9)
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F582         MOV     DPL,A
   \   000006   758300       MOV     DPH,#0x0
   \   000009   C082         PUSH    DPL
   \   00000B   C083         PUSH    DPH
   \   00000D   7A..         MOV     R2,#(`?<Constant "dir_start:%d\\n">` & 0xff)
   \   00000F   7B..         MOV     R3,#((`?<Constant "dir_start:%d\\n">` >> 8) & 0xff)
   \   000011   12....       LCALL   my_printf
   \   000014   D0E0         POP     A
   \   000016   D0E0         POP     A
     43          	if(!sys_ctl.flash_music_sta)
   \   000018   90....       MOV     DPTR,#(sys_ctl + 9)
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   7005         JNZ     ??get_dirstart_0
     44          	{
     45          		return 0;
   \   00001E   7A00         MOV     R2,#0x0
   \   000020   7B00         MOV     R3,#0x0
   \   000022   22           RET
     46          	}
     47          
     48          #if 1
     49          	return flash_music_total;
   \                     ??get_dirstart_0:
   \   000023   12....       LCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_14:
   \   000026   22           RET
     50          #else
     51          	u16 i, num=0;
     52          
     53          	for(i=0; i<sys_ctl.flash_music_sta; i++)
     54          	{
     55          		num += flash_music_total_tbl[i];
     56          		//printf("xx[%d]\n",num);
     57          	}
     58          	return num;
     59          #endif
     60          }

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   90....       MOV     DPTR,#flash_music_total
   \                     ??Subroutine6_0:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FA           MOV     R2,A
   \   000005   A3           INC     DPTR
   \   000006   E0           MOVX    A,@DPTR
   \   000007   FB           MOV     R3,A
   \   000008   22           RET
     61          
     62          
     63          //获取FLASH中曲目总数
     64          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
     65          u16 get_Flash_TotalFiles(void)
   \                     get_Flash_TotalFiles:
     66          {
   \   000000   7408         MOV     A,#0x8
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
     67          	u32 address;
     68          
     69          	flash_music_total = 0;
   \   000005   90....       MOV     DPTR,#flash_music_total
   \   000008   F0           MOVX    @DPTR,A
   \   000009   A3           INC     DPTR
   \   00000A   F0           MOVX    @DPTR,A
     70          
     71          	for(address = 0L; address < 8*256L; address += sizeof(decext_buf))
   \   00000B   90....       MOV     DPTR,#__Constant_0
   \   00000E   78..         MOV     R0,#?V0 + 4
   \   000010   12....       LCALL   ?L_MOV_C
     72          	{
     73          		register u8 value;
     74          		u16 read_offset;
     75          
     76          		spi_read(decext_buf, address, sizeof(decext_buf));
   \                     ??get_Flash_TotalFiles_0:
   \   000013                ; Setup parameters for call to function spi_read
   \   000013   78..         MOV     R0,#?V0 + 4
   \   000015   12....       LCALL   ?PUSH_ISTACK_I_FOUR
   \   000018   FC           MOV     R4,A
   \   000019   7D04         MOV     R5,#0x4
   \   00001B   7A..         MOV     R2,#(decext_buf & 0xff)
   \   00001D   7B..         MOV     R3,#((decext_buf >> 8) & 0xff)
   \   00001F   12....       LCALL   spi_read
   \   000022   74FC         MOV     A,#-0x4
   \   000024   12....       LCALL   ?DEALLOC_EXT_STACK8
     77          
     78          		//printf_array(decext_buf,64);
     79          
     80          		for(read_offset = 0, value = 0; read_offset < sizeof(decext_buf); read_offset++)
   \   000027   F8           MOV     R0,A
   \   000028   F9           MOV     R1,A
   \   000029   F5..         MOV     ?V0 + 0,A
     81          		{
     82          			// Rule:
     83          			//	Offset 0..3: 起始地址
     84          			//	offset 4..7: 数据长度 (以 0x100为单位)
     85          
     86          			// 软体分析有效的数据, 只分析数据长度不为 0的部份
     87          			if((read_offset & 0x07) == 0x04)
   \                     ??get_Flash_TotalFiles_1:
   \   00002B   E8           MOV     A,R0
   \   00002C   5407         ANL     A,#0x7
   \   00002E   FA           MOV     R2,A
   \   00002F   7404         MOV     A,#0x4
   \   000031   6A           XRL     A,R2
   \   000032   7002         JNZ     ??get_Flash_TotalFiles_2
     88          				value = 0;
   \   000034   8E..         MOV     ?V0 + 0,R6
     89          			value |= decext_buf[read_offset];
   \                     ??get_Flash_TotalFiles_2:
   \   000036   E8           MOV     A,R0
   \   000037   24..         ADD     A,#(decext_buf & 0xff)
   \   000039   F582         MOV     DPL,A
   \   00003B   E9           MOV     A,R1
   \   00003C   34..         ADDC    A,#((decext_buf >> 8) & 0xff)
   \   00003E   F583         MOV     DPH,A
   \   000040   E0           MOVX    A,@DPTR
   \   000041   42..         ORL     ?V0 + 0,A
     90          			if((read_offset & 0x07) == 0x07)
   \   000043   7407         MOV     A,#0x7
   \   000045   6A           XRL     A,R2
   \   000046   700D         JNZ     ??get_Flash_TotalFiles_3
     91          			{
     92          				if(value != 0x00)
   \   000048   E5..         MOV     A,?V0 + 0
   \   00004A   601A         JZ      ??get_Flash_TotalFiles_4
     93          					flash_music_total++;
   \   00004C   90....       MOV     DPTR,#flash_music_total
   \   00004F   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_5:
   \   000052   F0           MOVX    @DPTR,A
     94          				else
     95          				{
     96          					//printf("Find %d", flash_music_total);
     97          					//return flash_music_total;
     98          					break;
     99          				}
    100          				value = 0;
   \   000053   8E..         MOV     ?V0 + 0,R6
    101          			}
    102          		}
   \                     ??get_Flash_TotalFiles_3:
   \   000055   E8           MOV     A,R0
   \   000056   2401         ADD     A,#0x1
   \   000058   08           INC     R0
   \   000059   E9           MOV     A,R1
   \   00005A   3400         ADDC    A,#0x0
   \   00005C   F9           MOV     R1,A
   \   00005D   C3           CLR     C
   \   00005E   E8           MOV     A,R0
   \   00005F   9400         SUBB    A,#0x0
   \   000061   E9           MOV     A,R1
   \   000062   9404         SUBB    A,#0x4
   \   000064   40C5         JC      ??get_Flash_TotalFiles_1
    103          	}
   \                     ??get_Flash_TotalFiles_4:
   \   000066   90....       MOV     DPTR,#__Constant_400
   \   000069   78..         MOV     R0,#?V0 + 4
   \   00006B   12....       LCALL   ?L_ADD_C
   \   00006E   90....       MOV     DPTR,#__Constant_800
   \   000071   78..         MOV     R0,#?V0 + 0
   \   000073   12....       LCALL   ?L_MOV_C
   \   000076   78..         MOV     R0,#?V0 + 0
   \   000078   79..         MOV     R1,#?V0 + 4
   \   00007A   12....       LCALL   ?UL_GT
   \   00007D   4094         JC      ??get_Flash_TotalFiles_0
    104          	//printf("Find %d", flash_music_total);
    105          	return flash_music_total;
   \   00007F   12....       LCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_15:
   \   000082   7F08         MOV     R7,#0x8
   \   000084   02....       LJMP    ?FUNC_LEAVE_SP
    106          }

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2401         ADD     A,#0x1
   \   000003   F0           MOVX    @DPTR,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   22           RET
    107          
    108          
    109          //获取当前文件所在目录的文件总数
    110          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
    111          u16 get_dirtotal(void)
   \                     get_dirtotal:
    112          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    113          	//u16 flash_music_total = flash_music_total_tbl[sys_ctl.flash_music_sta];
    114          	//u16 flash_music_total = get_Flash_TotalFiles();
    115          
    116          	//printf("dir total:[%d]\n",flash_music_total);
    117          
    118          	return flash_music_total;
   \   000000   12....       LCALL   ?Subroutine6
   \                     ??CrossCallReturnLabel_16:
   \   000003   22           RET
    119          }
    120          
    121          
    122          //初始化第music_num首歌
    123          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
    124          bool task_flash_music_init(u16 music_num)
   \                     task_flash_music_init:
    125          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    126          	u_spi.spi_music_flag = 1;
   \   000000   7401         MOV     A,#0x1
   \   000002   90....       MOV     DPTR,#u_spi
   \   000005   F0           MOVX    @DPTR,A
    127          
    128          	SPI_CLK_DIR &= ~BIT(SPI_CLK_PIN);       //CLK
   \   000006   53BBDF       ANL     0xbb,#0xdf
    129          	SPI_CS_DIR &= ~BIT(SPI_CS_PIN);         //CS
   \   000009   53BB7F       ANL     0xbb,#0x7f
    130          
    131          	spi_mp3_index_read(music_num);   //读取Flash音乐索引信息
   \   00000C                ; Setup parameters for call to function spi_mp3_index_read
   \   00000C   EA           MOV     A,R2
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   spi_mp3_index_read
    132          
    133          	u_msc.music_type = music_init();
   \   000011                ; Setup parameters for call to function music_init
   \   000011   12....       LCALL   music_init
   \   000014   E9           MOV     A,R1
   \   000015   90....       MOV     DPTR,#(u_msc + 6)
   \   000018   F0           MOVX    @DPTR,A
    134          	if(TYPE_MP3 != u_msc.music_type)
   \   000019   6401         XRL     A,#0x1
   \   00001B   6002         JZ      ??task_flash_music_init_0
    135          	{
    136          		return false;
   \   00001D   C3           CLR     C
   \   00001E   22           RET
    137          	}
    138          	return true;
   \                     ??task_flash_music_init_0:
   \   00001F   D3           SETB    C
   \   000020   22           RET
    139          }
    140          
    141          //0:下一曲/1:上一曲
    142          #pragma location="TASK_MUSIC_SEG"

   \                                 In segment TASK_MUSIC_SEG, align 1, keep-with-next
    143          static void task_flash_music_direct(bool direct)
   \                     ??task_flash_music_direct:
    144          {
   \   000000   C0..         PUSH    ?VB
   \   000002                ; Saved register size: 1
   \   000002                ; Auto size: 0
   \   000002   A2F0         MOV     C,B.0
   \   000004   92..         MOV     ?VB.0,C
    145          #if (MUSIC_PLAYMODE && (PLAYMODE_NUM == PLAYMODE_FOUR))
    146          	u16 dir_start, dir_last;
    147          #endif
    148          
    149          	b_msc.file_change = 1;
    150          	b_msc.file_prev_next = direct;                       //设置方向，供解码出错时使用
   \   000006   92..         MOV     b_msc.2,C
   \   000008   D2..         SETB    b_msc.0
    151          
    152          	//printf("num=%d,total=%d\n", u_msc.music_num,u_msc.music_total);
    153          
    154          	switch(sys_ctl.mode_play)
   \   00000A   90....       MOV     DPTR,#sys_ctl
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for task_flash_music_direct>_0`:
   \   000011   00           DB        0
   \   000012   00           DB        0
   \   000013   ....         DW        ??task_flash_music_direct_1
   \   000015   ....         DW        ??task_flash_music_direct_2
    155          	{
    156          	case ITEM_LOOP_ALL:
    157          #if MUSIC_PLAYMODE
    158          	case ITEM_LOOP_SINGLE:
    159          #endif
    160          		if(direct)      //上一曲
    161          		{
    162          #if AUTO_CHANGE_DEVICE
    163          			if(u_msc.music_num == 1)
    164          			{
    165          				if(task_music_auto_device())
    166          				{
    167          					u_msc.music_num = u_msc.music_total;//自动上一曲到下一设备播放
    168          					b_msc.file_change = 1;              //需要打开一个新文件
    169          					return;
    170          				}
    171          			}
    172          #endif
    173          		}
    174          		else            //下一曲
    175          		{
    176          #if AUTO_CHANGE_DEVICE
    177          			if(u_msc.music_num == u_msc.music_total)
    178          			{
    179          				if(task_music_auto_device())
    180          				{
    181          					u_msc.music_num = 1;                //自动下一曲到下一设备播放
    182          					b_msc.file_change = 1;              //需要打开一个新文件
    183          					return;
    184          				}
    185          			}
    186          #endif
    187          		}
    188          		//全部循环
    189          		u_msc.music_num = loop_auto(direct, u_msc.music_num, 0, u_msc.music_total-1);
   \                     ??task_flash_music_direct_2:
   \   000017                ; Setup parameters for call to function loop_auto
   \   000017   90....       MOV     DPTR,#(u_msc + 4)
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   24FF         ADD     A,#-0x1
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   34FF         ADDC    A,#-0x1
   \   000022   F9           MOV     R1,A
   \   000023   E8           MOV     A,R0
   \   000024   C0E0         PUSH    A
   \   000026   E9           MOV     A,R1
   \   000027   C0E0         PUSH    A
   \   000029   7C00         MOV     R4,#0x0
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   90....       MOV     DPTR,#u_msc
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FA           MOV     R2,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FB           MOV     R3,A
   \   000035   A2..         MOV     C,?VB.0
   \   000037   92F0         MOV     B.0,C
   \   000039   12....       LCALL   loop_auto
   \   00003C   D0E0         POP     A
   \   00003E   D0E0         POP     A
   \   000040   90....       MOV     DPTR,#u_msc
   \   000043   EA           MOV     A,R2
   \   000044   F0           MOVX    @DPTR,A
   \   000045   A3           INC     DPTR
   \   000046   EB           MOV     A,R3
   \   000047   F0           MOVX    @DPTR,A
    190          		break;
    191          #if (MUSIC_PLAYMODE && (PLAYMODE_NUM == PLAYMODE_FOUR))
    192          	case ITEM_LOOP_FOLDER:
    193          		//目录循环
    194          		music_stop();
    195          		dir_start = f_get_dirstart();           //当前目录第一个文件的编号
    196          		dir_last = dir_start + f_get_dirtotal() - 1;
    197          		u_msc.music_num = loop_auto(direct, u_msc.music_num, dir_start, dir_last);
    198          		break;
    199          	case ITEM_LOOP_RAMDOM:
    200          #ifdef AX207X_TAG
    201          		u_msc.music_num = rand(u_msc.music_total) + 1;
    202          #else
    203          		u_msc.music_num = rand(u_msc.music_total, u_msc.music_num) + 1;
    204          #endif
    205          		break;
    206          #endif
    207          	}
    208          }
   \                     ??task_flash_music_direct_1:
   \   000048   D0..         POP     ?VB
   \   00004A   22           RET
    209          
    210          
    211          #if 0
    212          
    213          //上一曲
    214          #pragma location="TASK_FLASH_SEG"
    215          static void task_flash_music_prev(void)
    216          {
    217          	u16 dir_start, dir_last;
    218          	b_msc.file_change = 1;
    219          	b_msc.file_prev_next = 1;                       //设置方向，供解码出错时使用
    220          
    221          	u_msc.music_num--;
    222          	switch(u_spi.spi_play_mode)
    223          	{
    224          	case SINGLE_DIR:
    225          		dir_start = get_dirstart();                     //当前分类第一个文件的编号
    226          		dir_last = dir_start + get_dirtotal() - 1;
    227          		printf("dir_last:%d\n",dir_last);
    228          
    229          		if((u_msc.music_num < dir_start) || (u_msc.music_num > dir_last))
    230          		{
    231          			u_msc.music_num = dir_last;
    232          		}
    233          		break;
    234          	case ALL_DIR:
    235          		//if(!u_msc.music_num  || u_msc.music_num > ALL_MP3_TOTAL)
    236          		if(!u_msc.music_num  || u_msc.music_num > flash_music_total)
    237          		{
    238          			u_msc.music_num = 0;
    239          		}
    240          		break;
    241          	}
    242          }
    243          
    244          //下一曲
    245          #pragma location="TASK_FLASH_SEG"
    246          static void task_flash_music_next(void)
    247          {
    248          	u16 dir_start, dir_last;
    249          	b_msc.file_change = 1;
    250          	b_msc.file_prev_next = 0;                       //设置方向，供解码出错时使用
    251          
    252          	u_msc.music_num++;
    253          	switch(u_spi.spi_play_mode)
    254          	{
    255          	case SINGLE_DIR:
    256          		dir_start = get_dirstart();                     //当前分类第一个文件的编号
    257          		dir_last = dir_start + get_dirtotal() - 1;
    258          		printf("dir_last:%d\n",dir_last);
    259          
    260          		if(u_msc.music_num < dir_start || u_msc.music_num > dir_last)
    261          		{
    262          			u_msc.music_num = dir_start;
    263          		}
    264          		break;
    265          	case ALL_DIR:
    266          		//if(u_msc.music_num > ALL_MP3_TOTAL)
    267          		if(u_msc.music_num > flash_music_total)
    268          		{
    269          			u_msc.music_num = 0;
    270          		}
    271          		break;
    272          	}
    273          }
    274          #endif
    275          
    276          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
    277          void task_flash_music_sel_mode(void)
   \                     task_flash_music_sel_mode:
    278          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    279          	u16 dir_start/*, dir_last*/;
    280          	b_msc.file_change = 1;
    281          	b_msc.file_prev_next = 0;
   \   000004   C2..         CLR     b_msc.2
   \   000006   D2..         SETB    b_msc.0
    282          
    283          	dir_start = get_dirstart();                     //当前分类第一个文件的编号
    284          	//dir_last = dir_start + get_dirtotal()-1;
    285          	//printf("dir_last:%d\n",dir_last);
    286          	u_msc.music_num = dir_start+1;
   \   000008                ; Setup parameters for call to function get_dirstart
   \   000008   12....       LCALL   get_dirstart
   \   00000B   8A..         MOV     ?V0 + 0,R2
   \   00000D   8B..         MOV     ?V0 + 1,R3
   \   00000F   7401         MOV     A,#0x1
   \   000011   25..         ADD     A,?V0 + 0
   \   000013   F8           MOV     R0,A
   \   000014   E4           CLR     A
   \   000015   35..         ADDC    A,?V0 + 1
   \   000017   F9           MOV     R1,A
   \   000018   90....       MOV     DPTR,#u_msc
   \   00001B   E8           MOV     A,R0
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
   \   00001E   E9           MOV     A,R1
   \   00001F   F0           MOVX    @DPTR,A
    287          	printf("cur num:%d\n",u_msc.music_num);
   \   000020                ; Setup parameters for call to function my_printf
   \   000020   90....       MOV     DPTR,#u_msc
   \   000023   12....       LCALL   ?PUSH_ISTACK_X_TWO
   \   000026   7A..         MOV     R2,#(`?<Constant "cur num:%d\\n">` & 0xff)
   \   000028   7B..         MOV     R3,#((`?<Constant "cur num:%d\\n">` >> 8) & 0xff)
   \   00002A   12....       LCALL   my_printf
   \   00002D   D0E0         POP     A
   \   00002F   D0E0         POP     A
    288          }
   \   000031   02....       LJMP    ??Subroutine7_0

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   D0..         POP     ?V0 + 3
   \   000002   D0..         POP     ?V0 + 2
   \                     ??Subroutine7_0:
   \   000004   D0..         POP     ?V0 + 1
   \   000006   D0..         POP     ?V0 + 0
   \   000008   22           RET
    289          
    290          //打开一首新的音乐
    291          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
    292          void task_flash_music_new(void)
   \                     task_flash_music_new:
    293          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   8008         SJMP    ??task_flash_music_new_0
    294          	while(b_msc.file_change)
    295          	{
    296          		msc_ctl.mscfade_en = 1;	//使能调用dac淡出功能
    297          		music_stop();				// 停止播放器
    298          		b_msc.file_change = 0;                      //播放指定歌曲
    299          		//sound_ctl_clr();
    300          		if(task_flash_music_init(u_msc.music_num))
    301          		{
    302          			//printf("music_play\n");
    303          			//printf("flash play:%d\n",u_msc.music_num + 1);
    304          			//printf("flash##%lx, %lx, %lx\n", flash_music.addr, flash_music.len, flash_music.pos);
    305          			//dac_fade_in(0);
    306          			//music_fast_end();
    307          
    308          			music_play();
   \                     ??task_flash_music_new_1:
   \   000002                ; Setup parameters for call to function music_play
   \   000002   12....       LCALL   music_play
    309          			write_flash_num_rtcram();
   \   000005                ; Setup parameters for call to function write_flash_num_rtcram
   \   000005   12....       LCALL   write_flash_num_rtcram
    310          			//dac_set_volume_direct(sys_ctl.volume);
    311          			b_msc.pause = 0;
   \   000008   C2..         CLR     b_msc.1
    312          		}
   \                     ??task_flash_music_new_0:
   \   00000A   A2..         MOV     C,b_msc.0
   \   00000C   5022         JNC     ??task_flash_music_new_2
   \   00000E   7401         MOV     A,#0x1
   \   000010   90....       MOV     DPTR,#(msc_ctl + 26)
   \   000013   F0           MOVX    @DPTR,A
   \   000014                ; Setup parameters for call to function music_stop
   \   000014   12....       LCALL   music_stop
   \   000017   C2..         CLR     b_msc.0
   \   000019                ; Setup parameters for call to function task_flash_music_init
   \   000019   90....       MOV     DPTR,#u_msc
   \   00001C   12....       LCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_3:
   \   00001F   40E1         JC      ??task_flash_music_new_1
    313          		else
    314          		{
    315          			if(b_msc.file_prev_next)                //初始化失败，重新读取下一个文件
   \   000021   A2..         MOV     C,b_msc.2
   \   000023   5007         JNC     ??task_flash_music_new_3
    316          			{
    317          				task_flash_music_direct(1);
   \   000025                ; Setup parameters for call to function task_flash_music_direct
   \   000025   D2F0         SETB    B.0
   \                     ??task_flash_music_new_4:
   \   000027   12....       LCALL   ??task_flash_music_direct
   \   00002A   80DE         SJMP    ??task_flash_music_new_0
    318          			}
    319          			else
    320          			{
    321          				task_flash_music_direct(0);
   \                     ??task_flash_music_new_3:
   \   00002C                ; Setup parameters for call to function task_flash_music_direct
   \   00002C   C2F0         CLR     B.0
   \   00002E   80F7         SJMP    ??task_flash_music_new_4
    322          			}
    323          		}
    324          	}
    325          }
   \                     ??task_flash_music_new_2:
   \   000030   22           RET

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ??Subroutine6_0
   \                     ??CrossCallReturnLabel_17:
   \   000003   12....       LCALL   task_flash_music_init
   \   000006   22           RET
    326          
    327          //自动下一曲
    328          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
    329          void task_flash_music_auto_next(void)
   \                     task_flash_music_auto_next:
    330          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    331          #if !ADD_BY_WUPENGFEI
    332          	if(music_get_mtime() < 5)                   //播放不足500ms，认为本歌错误
    333          	{
    334          
    335          		if(b_msc.file_prev_next)                //初始化失败，重新读取下一个文件
    336          		{
    337          			task_flash_music_direct(1);
    338          		}
    339          		else
    340          		{
    341          			task_flash_music_direct(0);
    342          		}
    343          	}
    344          	else
    345          #endif
    346          	{
    347          		b_msc.file_prev_next = 0;                //清除方向
    348          		b_msc.file_change = 1;
   \   000000   C2..         CLR     b_msc.2
   \   000002   D2..         SETB    b_msc.0
    349          		if(sys_ctl.mode_play != ITEM_LOOP_SINGLE)
   \   000004   90....       MOV     DPTR,#sys_ctl
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6402         XRL     A,#0x2
   \   00000A   6005         JZ      ??task_flash_music_auto_next_0
    350          		{
    351          			task_flash_music_direct(0);
   \   00000C                ; Setup parameters for call to function task_flash_music_direct
   \   00000C   C2F0         CLR     B.0
   \   00000E   12....       LCALL   ??task_flash_music_direct
    352          		}
    353          	}
    354          }
   \                     ??task_flash_music_auto_next_0:
   \   000011   22           RET
    355          
    356          
    357          //任务消息处理
    358          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
    359          void task_flash_music_deal_msg(u8 msg)
   \                     task_flash_music_deal_msg:
    360          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004   C0..         PUSH    ?V0 + 2
   \   000006   C0..         PUSH    ?V0 + 3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
    361          	s8 whire_cnt;
    362          	/*
    363          	if(msg != NO_KEY)
    364          	{
    365          		//printf("F:%02x_", msg);
    366          		scan_ctl.now_msg = msg;
    367          		if(scan_ctl.now_msg == scan_ctl.last_msg)
    368          		{
    369          
    370          			return;
    371          		}else{
    372          			scan_ctl.last_msg = scan_ctl.now_msg;
    373          		}
    374          		printf("F:%02x_", msg);
    375          	}
    376          	*/
    377          	/*
    378          	if((sys_ctl.alarm_cnt == 1) && (sys_ctl.bat_sta_flag != 2))
    379          	{
    380          		printf("低电提示_");
    381          		if(u_msc.music_num < Low_Battery_Num)
    382          		u_msc.music_num_last = u_msc.music_num;
    383          		task_flash_music_direct(1);
    384          		u_msc.music_num = Low_Battery_Num;
    385          		sys_ctl.bat_sta_flag = 2;
    386          		alarm_flag = true;
    387          	}
    388          	*/
    389          	switch(msg)
   \   000008   E9           MOV     A,R1
   \   000009   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for task_flash_music_deal_msg>_0`:
   \   00000C   00           DB        0
   \   00000D   06           DB        6
   \   00000E   09           DB        9
   \   00000F   ....         DW        ??task_flash_music_deal_msg_0
   \   000011   0B           DB        11
   \   000012   ....         DW        ??task_flash_music_deal_msg_1
   \   000014   0D           DB        13
   \   000015   ....         DW        ??task_flash_music_deal_msg_2
   \   000017   7E           DB        126
   \   000018   ....         DW        ??task_flash_music_deal_msg_3
   \   00001A   86           DB        134
   \   00001B   ....         DW        ??task_flash_music_deal_msg_4
   \   00001D   B1           DB        177
   \   00001E   ....         DW        ??task_flash_music_deal_msg_4
   \   000020   ....         DW        ??task_flash_music_deal_msg_5
    390          	{
    391          	case T_KEY_SW1_WHIRL:	// A1B1 的转动处理
    392          		IE_EA = 0;	// 关闭中断, 後在读取转动值, 防止数据在中断中被重写, 导致计数误差
   \                     ??task_flash_music_deal_msg_0:
   \   000022   C2AF         CLR     0xa8.7
    393          		whire_cnt = SW1_WHIRL_cnt;
   \   000024   90....       MOV     DPTR,#SW1_WHIRL_cnt
   \   000027   12....       LCALL   ?Subroutine0
    394          		SW1_WHIRL_cnt = 0;
    395          		IE_EA = 1;	// 开启中断
    396          		if(whire_cnt != 0)							
   \                     ??CrossCallReturnLabel_0:
   \   00002A   7003         JNZ     $+5
   \   00002C   02....       LJMP    ??task_flash_music_deal_msg_6
    397          		{	// 这里进行 whire_cnt 的後续处理
    398          			if(scan_ctl.disp_light_set_flag == 0)	// 设置音量
   \   00002F   90....       MOV     DPTR,#(scan_ctl + 12)
   \   000032   E0           MOVX    A,@DPTR
   \   000033   7032         JNZ     ??task_flash_music_deal_msg_7
    399          			{
    400          				if(whire_cnt == Whire_Left)
   \   000035   90....       MOV     DPTR,#(sys_ctl + 2)
   \   000038   E0           MOVX    A,@DPTR
   \   000039   FB           MOV     R3,A
   \   00003A   74FF         MOV     A,#-0x1
   \   00003C   6A           XRL     A,R2
   \   00003D   7010         JNZ     ??task_flash_music_deal_msg_8
    401          				{
    402          					user_set_volume(sys_ctl.volume + 1);
   \   00003F                ; Setup parameters for call to function user_set_volume
   \   00003F   7401         MOV     A,#0x1
   \   000041   12....       LCALL   ?Subroutine4
    403          					deal_vol_msg();
    404          					//if(scan_ctl.hpdect_val < 200)	//耳机没有插入
    405          					//if(HP_CHECK_PORT & BIT(HP_CHECK_PIN))	//耳机没有插入
    406          					{
    407          						if(sys_ctl.volume >= 1)
   \                     ??CrossCallReturnLabel_10:
   \   000044   7003         JNZ     $+5
   \   000046   02....       LJMP    ??task_flash_music_deal_msg_6
    408          							UN_MUTE();
   \   000049                ; Setup parameters for call to function UN_MUTE
   \   000049   12....       LCALL   UN_MUTE
   \   00004C   02....       LJMP    ??task_flash_music_deal_msg_6
    409          					}
    410          					//printf("v+:%d ",sys_ctl.volume);
    411          				}else if(whire_cnt == Whire_Right)
   \                     ??task_flash_music_deal_msg_8:
   \   00004F   7401         MOV     A,#0x1
   \   000051   6A           XRL     A,R2
   \   000052   6003         JZ      $+5
   \   000054   02....       LJMP    ??task_flash_music_deal_msg_6
    412          				{
    413          					user_set_volume(sys_ctl.volume - 1);
   \   000057                ; Setup parameters for call to function user_set_volume
   \   000057   74FF         MOV     A,#-0x1
   \   000059   12....       LCALL   ?Subroutine4
    414          					deal_vol_msg();
    415          					if(sys_ctl.volume == 0)
   \                     ??CrossCallReturnLabel_11:
   \   00005C   6003         JZ      $+5
   \   00005E   02....       LJMP    ??task_flash_music_deal_msg_6
    416          					MUTE_EN();
   \   000061                ; Setup parameters for call to function MUTE_EN
   \   000061   12....       LCALL   MUTE_EN
   \   000064   02....       LJMP    ??task_flash_music_deal_msg_6
    417          					//printf("v-:%d ",sys_ctl.volume);
    418          				}
    419          			}else{				// 设置LED亮度
    420          				if(whire_cnt == Whire_Left)
   \                     ??task_flash_music_deal_msg_7:
   \   000067   74FF         MOV     A,#-0x1
   \   000069   6A           XRL     A,R2
   \   00006A   7027         JNZ     ??task_flash_music_deal_msg_9
    421          				{
    422          					if(t_pwn_duty1 == LED_LIGHT2)
   \   00006C   90....       MOV     DPTR,#t_pwn_duty1
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   647F         XRL     A,#0x7f
   \   000072   700A         JNZ     ??task_flash_music_deal_msg_10
    423          					{
    424          						t_pwn_duty1 = LED_LIGHT3;
   \                     ??task_flash_music_deal_msg_11:
   \   000074   74D4         MOV     A,#-0x2c
   \                     ??task_flash_music_deal_msg_12:
   \   000076   F0           MOVX    @DPTR,A
    425          						t_pwn_duty2 = LED_LIGHT3;
   \   000077   90....       MOV     DPTR,#t_pwn_duty2
   \                     ??task_flash_music_deal_msg_13:
   \   00007A   F0           MOVX    @DPTR,A
   \   00007B   02....       LJMP    ??task_flash_music_deal_msg_6
    426          					}else if(t_pwn_duty1 == LED_LIGHT3){
   \                     ??task_flash_music_deal_msg_10:
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   64D4         XRL     A,#0xd4
   \   000081   7004         JNZ     ??task_flash_music_deal_msg_14
    427          						t_pwn_duty1 = LED_LIGHT1;
   \                     ??task_flash_music_deal_msg_15:
   \   000083   742A         MOV     A,#0x2a
   \   000085   80EF         SJMP    ??task_flash_music_deal_msg_12
    428          						t_pwn_duty2 = LED_LIGHT1;
    429          					}else if(t_pwn_duty1 == LED_LIGHT1){
   \                     ??task_flash_music_deal_msg_14:
   \   000087   E0           MOVX    A,@DPTR
   \   000088   642A         XRL     A,#0x2a
   \   00008A   6003         JZ      $+5
   \   00008C   02....       LJMP    ??task_flash_music_deal_msg_6
    430          						t_pwn_duty1 = LED_LIGHT2;
   \                     ??task_flash_music_deal_msg_16:
   \   00008F   747F         MOV     A,#0x7f
   \   000091   80E3         SJMP    ??task_flash_music_deal_msg_12
    431          						t_pwn_duty2 = LED_LIGHT2;
    432          					}
    433          				}else if(whire_cnt == Whire_Right)
   \                     ??task_flash_music_deal_msg_9:
   \   000093   7401         MOV     A,#0x1
   \   000095   6A           XRL     A,R2
   \   000096   6003         JZ      $+5
   \   000098   02....       LJMP    ??task_flash_music_deal_msg_6
    434          				{
    435          					if(t_pwn_duty1 == LED_LIGHT2)
   \   00009B   90....       MOV     DPTR,#t_pwn_duty1
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   647F         XRL     A,#0x7f
   \   0000A1   60E0         JZ      ??task_flash_music_deal_msg_15
    436          					{
    437          						t_pwn_duty1 = LED_LIGHT1;
    438          						t_pwn_duty2 = LED_LIGHT1;
    439          					}else if(t_pwn_duty1 == LED_LIGHT1){
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   642A         XRL     A,#0x2a
   \   0000A6   60CC         JZ      ??task_flash_music_deal_msg_11
    440          						t_pwn_duty1 = LED_LIGHT3;
    441          						t_pwn_duty2 = LED_LIGHT3;
    442          					}else if(t_pwn_duty1 == LED_LIGHT3){
   \   0000A8   E0           MOVX    A,@DPTR
   \   0000A9   64D4         XRL     A,#0xd4
   \   0000AB   6003         JZ      $+5
   \   0000AD   02....       LJMP    ??task_flash_music_deal_msg_6
   \   0000B0   80DD         SJMP    ??task_flash_music_deal_msg_16
    443          						t_pwn_duty1 = LED_LIGHT2;
    444          						t_pwn_duty2 = LED_LIGHT2;
    445          					}
    446          				}
    447          			}
    448          		}
    449          		break;
    450          
    451          	case T_KEY_SW2_WHIRL:	// A2B2 的转动处理
    452          		IE_EA = 0;	// 关闭中断, 後在读取转动值, 防止数据在中断中被重写, 导致计数误差
   \                     ??task_flash_music_deal_msg_1:
   \   0000B2   C2AF         CLR     0xa8.7
    453          		whire_cnt = SW2_WHIRL_cnt;
   \   0000B4   90....       MOV     DPTR,#SW2_WHIRL_cnt
   \   0000B7   12....       LCALL   ?Subroutine0
    454          		SW2_WHIRL_cnt = 0;
    455          		IE_EA = 1;	// 开启中断
    456          		if(whire_cnt != 0)
   \                     ??CrossCallReturnLabel_1:
   \   0000BA   7003         JNZ     $+5
   \   0000BC   02....       LJMP    ??task_flash_music_deal_msg_6
    457          		{	// 这里进行 whire_cnt 的後续处理
    458          			//if(scan_ctl.timer_flag == 0)	// 第一次旋转
    459          			//	scan_ctl.timer_flag = 1;
    460          			if(scan_ctl.disp_clock_set_flag == 0)	// 设置定时
   \   0000BF   90....       MOV     DPTR,#(scan_ctl + 11)
   \   0000C2   E0           MOVX    A,@DPTR
   \   0000C3   703F         JNZ     ??task_flash_music_deal_msg_17
    461          			{
    462          				if(whire_cnt == Whire_Left)
   \   0000C5   90....       MOV     DPTR,#(scan_ctl + 14)
   \   0000C8   E0           MOVX    A,@DPTR
   \   0000C9   FB           MOV     R3,A
   \   0000CA   74FF         MOV     A,#-0x1
   \   0000CC   6A           XRL     A,R2
   \   0000CD   7016         JNZ     ??task_flash_music_deal_msg_18
    463          				{
    464          					if(scan_ctl.timer_flag < 4){
   \   0000CF   EB           MOV     A,R3
   \   0000D0   C3           CLR     C
   \   0000D1   9404         SUBB    A,#0x4
   \   0000D3   5004         JNC     ??task_flash_music_deal_msg_19
    465          						scan_ctl.timer_flag++;
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   04           INC     A
   \   0000D7   80A1         SJMP    ??task_flash_music_deal_msg_13
    466          					}else if(scan_ctl.timer_flag == 4){
   \                     ??task_flash_music_deal_msg_19:
   \   0000D9   7404         MOV     A,#0x4
   \   0000DB   6B           XRL     A,R3
   \   0000DC   6003         JZ      $+5
   \   0000DE   02....       LJMP    ??task_flash_music_deal_msg_6
    467          						scan_ctl.timer_flag = 1;
   \   0000E1   7401         MOV     A,#0x1
   \   0000E3   8095         SJMP    ??task_flash_music_deal_msg_13
    468          					}
    469          				}else if(whire_cnt == Whire_Right)
   \                     ??task_flash_music_deal_msg_18:
   \   0000E5   7401         MOV     A,#0x1
   \   0000E7   6A           XRL     A,R2
   \   0000E8   6003         JZ      $+5
   \   0000EA   02....       LJMP    ??task_flash_music_deal_msg_6
    470          				{
    471          					if(scan_ctl.timer_flag > 1){
   \   0000ED   EB           MOV     A,R3
   \   0000EE   C3           CLR     C
   \   0000EF   9402         SUBB    A,#0x2
   \   0000F1   4004         JC      ??task_flash_music_deal_msg_20
    472          						scan_ctl.timer_flag--;
   \   0000F3   E0           MOVX    A,@DPTR
   \   0000F4   14           DEC     A
   \   0000F5   8083         SJMP    ??task_flash_music_deal_msg_13
    473          					}else if(scan_ctl.timer_flag == 1){
   \                     ??task_flash_music_deal_msg_20:
   \   0000F7   7401         MOV     A,#0x1
   \   0000F9   6B           XRL     A,R3
   \   0000FA   6003         JZ      $+5
   \   0000FC   02....       LJMP    ??task_flash_music_deal_msg_6
    474          						scan_ctl.timer_flag = 4;
   \   0000FF   7404         MOV     A,#0x4
   \   000101   02....       LJMP    ??task_flash_music_deal_msg_13
    475          					}	
    476          				}
    477          			}else {									// 设置时钟
    478          				if(scan_ctl.count_KU_TIMER == 0)
   \                     ??task_flash_music_deal_msg_17:
   \   000104   90....       MOV     DPTR,#(scan_ctl + 17)
   \   000107   E0           MOVX    A,@DPTR
   \   000108   FB           MOV     R3,A
   \   000109   702C         JNZ     ??task_flash_music_deal_msg_21
    479          				{
    480          					if(whire_cnt == Whire_Left)
   \   00010B   78..         MOV     R0,#(ocx + 11)
   \   00010D   E6           MOV     A,@R0
   \   00010E   FB           MOV     R3,A
   \   00010F   74FF         MOV     A,#-0x1
   \   000111   6A           XRL     A,R2
   \   000112   700F         JNZ     ??task_flash_music_deal_msg_22
    481          					{
    482          						if(ocx.timeh < 23){
   \   000114   EB           MOV     A,R3
   \   000115   C3           CLR     C
   \   000116   9417         SUBB    A,#0x17
   \   000118   5004         JNC     ??task_flash_music_deal_msg_23
    483          							ocx.timeh++;
   \                     ??task_flash_music_deal_msg_24:
   \   00011A   06           INC     @R0
   \   00011B   02....       LJMP    ??task_flash_music_deal_msg_6
    484          						}else {
    485          							ocx.timeh = 0;
   \                     ??task_flash_music_deal_msg_23:
   \   00011E   7600         MOV     @R0,#0x0
   \   000120   02....       LJMP    ??task_flash_music_deal_msg_6
    486          						}
    487          							
    488          					}else if(whire_cnt == Whire_Right)
   \                     ??task_flash_music_deal_msg_22:
   \   000123   7401         MOV     A,#0x1
   \   000125   6A           XRL     A,R2
   \   000126   6003         JZ      $+5
   \   000128   02....       LJMP    ??task_flash_music_deal_msg_6
    489          					{
    490          						if(ocx.timeh > 0){
   \   00012B   EB           MOV     A,R3
   \   00012C   6004         JZ      ??task_flash_music_deal_msg_25
    491          							ocx.timeh--;
   \                     ??task_flash_music_deal_msg_26:
   \   00012E   16           DEC     @R0
   \   00012F   02....       LJMP    ??task_flash_music_deal_msg_6
    492          						}else {
    493          							ocx.timeh = 23;
   \                     ??task_flash_music_deal_msg_25:
   \   000132   7617         MOV     @R0,#0x17
   \   000134   02....       LJMP    ??task_flash_music_deal_msg_6
    494          						}
    495          					}
    496          				}else if(scan_ctl.count_KU_TIMER == 1)
   \                     ??task_flash_music_deal_msg_21:
   \   000137   7401         MOV     A,#0x1
   \   000139   6B           XRL     A,R3
   \   00013A   6003         JZ      $+5
   \   00013C   02....       LJMP    ??task_flash_music_deal_msg_6
    497          				{
    498          					if(whire_cnt == Whire_Left)
   \   00013F   78..         MOV     R0,#(ocx + 12)
   \   000141   E6           MOV     A,@R0
   \   000142   FB           MOV     R3,A
   \   000143   74FF         MOV     A,#-0x1
   \   000145   6A           XRL     A,R2
   \   000146   7008         JNZ     ??task_flash_music_deal_msg_27
    499          					{
    500          						if(ocx.timel < 59){
   \   000148   EB           MOV     A,R3
   \   000149   C3           CLR     C
   \   00014A   943B         SUBB    A,#0x3b
   \   00014C   50D0         JNC     ??task_flash_music_deal_msg_23
    501          							ocx.timel++;
   \   00014E   80CA         SJMP    ??task_flash_music_deal_msg_24
    502          						}else {
    503          							ocx.timel = 0;
    504          						}							
    505          					}else if(whire_cnt == Whire_Right)
   \                     ??task_flash_music_deal_msg_27:
   \   000150   7401         MOV     A,#0x1
   \   000152   6A           XRL     A,R2
   \   000153   6003         JZ      $+5
   \   000155   02....       LJMP    ??task_flash_music_deal_msg_6
    506          					{
    507          						if(ocx.timel > 0){
   \   000158   EB           MOV     A,R3
   \   000159   70D3         JNZ     ??task_flash_music_deal_msg_26
    508          							ocx.timel--;
    509          						}else {
    510          							ocx.timel = 59;
   \   00015B   763B         MOV     @R0,#0x3b
   \   00015D   02....       LJMP    ??task_flash_music_deal_msg_6
    511          						}	
    512          					}
    513          				}
    514          			}
    515          		}
    516          		break;
    517          
    518          	case T_KEY_SW3_WHIRL:	// A3B3 的转动处理
    519          		IE_EA = 0;	// 关闭中断, 後在读取转动值, 防止数据在中断中被重写, 导致计数误差
   \                     ??task_flash_music_deal_msg_2:
   \   000160   C2AF         CLR     0xa8.7
    520          		whire_cnt = SW3_WHIRL_cnt;
   \   000162   90....       MOV     DPTR,#SW3_WHIRL_cnt
   \   000165   12....       LCALL   ?Subroutine0
    521          		SW3_WHIRL_cnt = 0;
    522          		IE_EA = 1;	// 开启中断
    523          		if(whire_cnt != 0)
   \                     ??CrossCallReturnLabel_2:
   \   000168   7003         JNZ     $+5
   \   00016A   02....       LJMP    ??task_flash_music_deal_msg_6
    524          		{	// 这里进行 whire_cnt 的後续处理
    525          			if(whire_cnt == Whire_Left)
   \   00016D   74FF         MOV     A,#-0x1
   \   00016F   6A           XRL     A,R2
   \   000170   7028         JNZ     ??task_flash_music_deal_msg_28
    526          			{
    527          				task_flash_music_direct(1);
   \   000172                ; Setup parameters for call to function task_flash_music_direct
   \   000172   D2F0         SETB    B.0
   \   000174   12....       LCALL   ??task_flash_music_direct
    528          				if((u_msc.music_num < u_msc.music_total-1))
   \   000177   90....       MOV     DPTR,#(u_msc + 4)
   \   00017A   E0           MOVX    A,@DPTR
   \   00017B   24FF         ADD     A,#-0x1
   \   00017D   F8           MOV     R0,A
   \   00017E   A3           INC     DPTR
   \   00017F   E0           MOVX    A,@DPTR
   \   000180   34FF         ADDC    A,#-0x1
   \   000182   F9           MOV     R1,A
   \   000183   7583..       MOV     DPH,#((u_msc >> 8) & 0xff)
   \   000186   7582..       MOV     DPL,#(u_msc & 0xff)
   \   000189   C3           CLR     C
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   98           SUBB    A,R0
   \   00018C   A3           INC     DPTR
   \   00018D   E0           MOVX    A,@DPTR
   \   00018E   99           SUBB    A,R1
   \   00018F   506B         JNC     ??task_flash_music_deal_msg_6
    529          				u_msc.music_num++; 			// 转回相应的歌曲 
   \   000191   90....       MOV     DPTR,#u_msc
   \   000194   12....       LCALL   ?Subroutine2
   \                     ??CrossCallReturnLabel_6:
   \   000197   02....       LJMP    ??task_flash_music_deal_msg_13
    530          			}else if(whire_cnt == Whire_Right)
   \                     ??task_flash_music_deal_msg_28:
   \   00019A   7401         MOV     A,#0x1
   \   00019C   6A           XRL     A,R2
   \   00019D   705D         JNZ     ??task_flash_music_deal_msg_6
    531          			{
    532          				task_flash_music_direct(1);
   \   00019F                ; Setup parameters for call to function task_flash_music_direct
   \   00019F   D2F0         SETB    B.0
   \   0001A1   12....       LCALL   ??task_flash_music_direct
    533          				if(u_msc.music_num >= 1)
   \   0001A4   90....       MOV     DPTR,#u_msc
   \   0001A7   E0           MOVX    A,@DPTR
   \   0001A8   7002         JNZ     ??task_flash_music_deal_msg_29
   \   0001AA   A3           INC     DPTR
   \   0001AB   E0           MOVX    A,@DPTR
   \                     ??task_flash_music_deal_msg_29:
   \   0001AC   604E         JZ      ??task_flash_music_deal_msg_6
    534          				u_msc.music_num--; 	
   \   0001AE   90....       MOV     DPTR,#u_msc
   \   0001B1   E0           MOVX    A,@DPTR
   \   0001B2   24FF         ADD     A,#-0x1
   \   0001B4   F0           MOVX    @DPTR,A
   \   0001B5   A3           INC     DPTR
   \   0001B6   E0           MOVX    A,@DPTR
   \   0001B7   34FF         ADDC    A,#-0x1
   \   0001B9   02....       LJMP    ??task_flash_music_deal_msg_13
    535          			}
    536          			//printf("%d ",u_msc.music_num);
    537          		}
    538          		break;
    539          
    540          #if 1
    541          	#if 0	//  停用直接播放的模式
    542              case T_KEY_1:
    543              case T_KEY_2:
    544              case T_KEY_3:
    545              case T_KEY_4:
    546              case T_KEY_5:
    547              case T_KEY_6:
    548          	case T_KEY_7:
    549          	case T_KEY_8:
    550          	case T_KEY_9:
    551          	case T_KEY_10:
    552                  printf("Key:%d\n",msg);
    553          		task_flash_music_direct(1);
    554          		u_msc.music_num = msg-1;	// 转回相应的歌曲
    555          		break;
    556          	#endif
    557          #else
    558              case T_KEY_NUM_0:
    559                  printf("Night\n");
    560          		task_flash_music_direct(1);
    561          		u_msc.music_num = 0;
    562          		break;
    563          
    564          	case T_KEY_NUM_1:
    565          		printf("Summer\n");
    566          		task_flash_music_direct(1);
    567          		u_msc.music_num = 1;
    568          		break;
    569          
    570          	case T_KEY_NUM_2:
    571          		printf("Rain\n");
    572          		task_flash_music_direct(1);
    573          		u_msc.music_num = 2;
    574          		break;
    575          	#if 1
    576          	case T_KEY_NUM_3:
    577          		printf("Ocean\n");
    578          		task_flash_music_direct(1);
    579          		u_msc.music_num = 3;
    580          		break;
    581          
    582              case T_KEY_NUM_4:
    583          		printf("Fan\n");
    584          		task_flash_music_direct(1);
    585          		u_msc.music_num = 4;
    586          		break;
    587          
    588          	case T_KEY_NUM_5:
    589          		printf("Brown\n");
    590          		task_flash_music_direct(1);
    591          		u_msc.music_num = 5;
    592          		break;
    593          	#endif
    594          #endif
    595          #if 0
    596          	case KU_STORY:
    597          #if 1
    598          		u_spi.spi_play_mode = SINGLE_DIR;        //单文件夹循环播放
    599          		sys_ctl.flash_music_sta = CHILDREN;          //播放诗歌文件夹
    600          		mp3_res_play_wait(CHILDREN);               //播放文件夹提示音
    601          		task_flash_music_sel_mode();
    602          #else
    603          		u_spi.spi_play_mode = SINGLE_DIR;        //单文件夹循环播放
    604          		sys_ctl.flash_music_sta = ENGLISH;          //播放诗歌文件夹
    605          		mp3_res_play_wait(ENGLISH);               //播放文件夹提示音
    606          		task_flash_music_sel_mode();
    607          #endif
    608          		break;
    609          #endif
    610          
    611          #if MUSIC_EQ
    612          	//EQ
    613          	case KU_EQ:
    614              case KL_PLAYMODE:
    615          		user_set_eq(sys_ctl.eq_num + 1);
    616          		printf("eq_num=%02x\n", sys_ctl.eq_num);
    617          		showeq();
    618          		break;
    619          #endif
    620          #if 0	// 2016/06/29 停用设备切换功能
    621          //长按 切换设备
    622          	case KL_PREV:
    623          #if USE_Flash_BREAK_POINT
    624          //				if(task_ctl.work_sta != TASK_EXIT)
    625          				{
    626          //					music_get_point(&u_msc.break_point);
    627          //					u_msc.break_point.pos = flash_music.pos;
    628          //					irtc_write_ram(RTCRAM_MUSIC_POS_SD1,(u8 *)&u_msc.break_point, 8);
    629          				}
    630          #endif
    631          		if(0==(SD_CHECK_PORT & BIT(SD_CHECK_PIN)))
    632          		{
    633          			device_chg = BIT(device_flash);
    634          			task_ctl.work_sta = TASK_MUSIC;
    635          			printf("ChgDev.");
    636          		}
    637          		break;
    638          #endif
    639          #if 0
    640          
    641          #if MUSIC_SWITCH_DEV
    642          		t_msc.mode++;    //播放模式：USB0-USB1-SD0-SD1-其他模式
    643          		tmp = device_get_actived_num();
    644          		printf("tmp:%d\n",tmp);
    645          		device_chg = true;
    646          		if((t_msc.mode == tmp/*device_get_actived_num()*/) ||(fs_cur_dev()==DEVICE_SDMMC1)|| (!task_flash_music_next_device()))
    647          		{
    648          			sd_stop(1);
    649          			if(device_activate(DEVICE_UDISK))
    650          			{
    651          				t_fat.dev_new = DEVICE_UDISK;    //模式切换，下次进入MP3模式时先播放U盘
    652          			}
    653          #if UDISK_DOUBLE_EN
    654          			else  if(device_activate(DEVICE_UDISK1))
    655          			{
    656          				t_fat.dev_new = DEVICE_UDISK1;    //模式切换，下次进入MP3模式时先播放U盘
    657          			}
    658          #endif
    659          			else  if(device_activate(DEVICE_SDMMC))
    660          			{
    661          				t_fat.dev_new = DEVICE_SDMMC;    //模式切换，下次进入MP3模式时先播放U盘
    662          			}
    663          			task_ctl.work_sta = TASK_EXIT;
    664          		}
    665          		if(b_dac.mute_en)
    666          		{
    667          			//解除MUTE
    668          			mute_disable();
    669          		}
    670          #else
    671          		task_ctl.work_sta = TASK_EXIT;
    672          #endif
    673          		break;
    674          #endif
    675          
    676          
    677          #if DIR_SWITCH_EN
    678          	case KU_PREVDIR:
    679          		task_music_dir(1);
    680          		break;
    681          
    682          	case KU_NEXTDIR:
    683          		task_music_dir(0);
    684          		break;
    685          #endif
    686          
    687          
    688          	case KU_MODE:
    689          	case KL_PLAY_AND_MODE:
    690          		//printf("exit\n");
    691          		task_ctl.work_sta = TASK_EXIT;
   \                     ??task_flash_music_deal_msg_4:
   \   0001BC   75..0C       MOV     task_ctl,#0xc
   \   0001BF   803B         SJMP    ??task_flash_music_deal_msg_6
    692          		break;
    693          
    694          	case QSYSTEM_500MS:
    695          		if(u_msc.music_num >= u_msc.music_total)
   \                     ??task_flash_music_deal_msg_3:
   \   0001C1   90....       MOV     DPTR,#(u_msc + 4)
   \   0001C4   E0           MOVX    A,@DPTR
   \   0001C5   F8           MOV     R0,A
   \   0001C6   A3           INC     DPTR
   \   0001C7   E0           MOVX    A,@DPTR
   \   0001C8   F9           MOV     R1,A
   \   0001C9   7583..       MOV     DPH,#((u_msc >> 8) & 0xff)
   \   0001CC   7582..       MOV     DPL,#(u_msc & 0xff)
   \   0001CF   C3           CLR     C
   \   0001D0   E0           MOVX    A,@DPTR
   \   0001D1   98           SUBB    A,R0
   \   0001D2   A3           INC     DPTR
   \   0001D3   E0           MOVX    A,@DPTR
   \   0001D4   99           SUBB    A,R1
   \   0001D5   4007         JC      ??task_flash_music_deal_msg_30
    696          		{
    697          			u_msc.music_num = 0;
   \   0001D7   90....       MOV     DPTR,#u_msc
   \   0001DA   E4           CLR     A
   \   0001DB   F0           MOVX    @DPTR,A
   \   0001DC   A3           INC     DPTR
   \   0001DD   F0           MOVX    @DPTR,A
    698          		}
    699          //		printf("flash..%lx, %lx, %lx\n", flash_music.addr, flash_music.len, flash_music.pos);
    700          		music_get_point(&u_msc.break_point);
   \                     ??task_flash_music_deal_msg_30:
   \   0001DE                ; Setup parameters for call to function music_get_point
   \   0001DE   12....       LCALL   ?Subroutine3
    701          		u_msc.break_point.pos = flash_music.pos;
   \                     ??CrossCallReturnLabel_7:
   \   0001E1   12....       LCALL   ?L_MOV_X
   \   0001E4   90....       MOV     DPTR,#(u_msc + 13)
   \   0001E7   78..         MOV     R0,#?V0 + 0
   \   0001E9   12....       LCALL   ?L_MOV_TO_X
    702          		irtc_write_ram(RTCRAM_MUSIC_POS_SD1,(u8 *)&u_msc.break_point, 8);
   \   0001EC                ; Setup parameters for call to function irtc_write_ram
   \   0001EC   7C08         MOV     R4,#0x8
   \   0001EE   7A..         MOV     R2,#((u_msc + 9) & 0xff)
   \   0001F0   7B..         MOV     R3,#(((u_msc + 9) >> 8) & 0xff)
   \   0001F2   790A         MOV     R1,#0xa
   \   0001F4   12....       LCALL   irtc_write_ram
   \   0001F7   8003         SJMP    ??task_flash_music_deal_msg_6
    703          		break;
    704          
    705          		//调用公共消息函数
    706          	default:
    707          		deal_msg(msg);
   \                     ??task_flash_music_deal_msg_5:
   \   0001F9                ; Setup parameters for call to function deal_msg
   \   0001F9   12....       LCALL   deal_msg
    708          		break;
    709          	}
    710          }
   \                     ??task_flash_music_deal_msg_6:
   \   0001FC   02....       LJMP    ?Subroutine7

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   2B           ADD     A,R3
   \   000001   F9           MOV     R1,A
   \   000002   12....       LCALL   user_set_volume
   \   000005                ; Setup parameters for call to function deal_vol_msg
   \   000005                ; Setup parameters for call to function deal_vol_msg
   \   000005   12....       LCALL   deal_vol_msg
   \   000008   90....       MOV     DPTR,#(sys_ctl + 2)
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   22           RET

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   E4           CLR     A
   \   000003   F0           MOVX    @DPTR,A
   \   000004   D2AF         SETB    0xa8.7
   \   000006   EA           MOV     A,R2
   \   000007   22           RET

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   7A..         MOV     R2,#((u_msc + 9) & 0xff)
   \   000002   7B..         MOV     R3,#(((u_msc + 9) >> 8) & 0xff)
   \   000004   12....       LCALL   music_get_point
   \   000007   90....       MOV     DPTR,#(flash_music + 8)
   \   00000A   78..         MOV     R0,#?V0 + 0
   \   00000C   22           RET
    711          
    712          //任务事务处理
    713          
    714          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
    715          void task_flash_music_event(void)
   \                     task_flash_music_event:
    716          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004   C0..         PUSH    ?V0 + 2
   \   000006   C0..         PUSH    ?V0 + 3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
    717          #ifdef REMOVED
    718          #if USE_SDCMD_IIC_SPIDAT
    719          	comm_event(2);                          //IO复用时，待切换模式后再初始化设备
    720          #else
    721          	comm_event(1);                          //调用公共事件
    722          #endif                         //调用公共事件
    723          #else
    724          	if(u_spi.spi_online)
   \   000008   90....       MOV     DPTR,#(u_spi + 1)
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   6004         JZ      ??task_flash_music_event_0
    725          		comm_event(2);
   \   00000E                ; Setup parameters for call to function comm_event
   \   00000E   7902         MOV     R1,#0x2
   \   000010   8002         SJMP    ??task_flash_music_event_1
    726          	else
    727          		comm_event(1);
   \                     ??task_flash_music_event_0:
   \   000012                ; Setup parameters for call to function comm_event
   \   000012   7901         MOV     R1,#0x1
   \                     ??task_flash_music_event_1:
   \   000014   12....       LCALL   comm_event
    728          #endif /* REMOVED */
    729          	music_event();                          //解码需要的事件
   \   000017                ; Setup parameters for call to function music_event
   \   000017   12....       LCALL   music_event
    730          	//printf("num=%d,total=%d\n", u_msc.music_num,u_msc.music_total);
    731          #if TASK_TIPS_EN
    732          	task_ctl.pre_sta = TASK_FLASH;
    733          #endif
    734          
    735          	if(b_sys.dev_change)
   \   00001A   A2..         MOV     C,b_sys.0
   \   00001C   5009         JNC     ??task_flash_music_event_2
    736          	{
    737          		if(!device_is_online(DEVICE_SDMMC))
   \   00001E                ; Setup parameters for call to function device_is_online
   \   00001E   7900         MOV     R1,#0x0
   \   000020   12....       LCALL   device_is_online
   \   000023   4002         JC      ??task_flash_music_event_2
    738          			b_sys.dev_change = 0;
   \   000025   C2..         CLR     b_sys.0
    739          	}
    740          
    741          		if(b_sys.dev_change || (device_chg & BIT(device_flash)))
   \                     ??task_flash_music_event_2:
   \   000027   A2..         MOV     C,b_sys.0
   \   000029   4008         JC      ??task_flash_music_event_3
   \   00002B   90....       MOV     DPTR,#device_chg
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   A2E1         MOV     C,0xE0 /* A   */.1
   \   000031   502C         JNC     ??task_flash_music_event_4
    742          		{
    743          			device_chg = 0;
   \                     ??task_flash_music_event_3:
   \   000033   E4           CLR     A
   \   000034   90....       MOV     DPTR,#device_chg
   \   000037   F0           MOVX    @DPTR,A
    744          			music_stop();						//停止当前音乐
   \   000038                ; Setup parameters for call to function music_stop
   \   000038   12....       LCALL   music_stop
    745          			b_msc.file_change = 1;				//需要打开一个新文件
    746          #if USE_Flash_BREAK_POINT
    747          			b_msc.break_init = 1;
   \   00003B   43..09       ORL     b_msc,#0x9
    748          			//task_music_break_save(1);
    749          			music_get_point(&u_msc.break_point);
   \   00003E                ; Setup parameters for call to function music_get_point
   \   00003E   12....       LCALL   ?Subroutine3
    750          		//	printf("@frame = %ld pos= %ld,", u_msc.break_point.frame, u_msc.break_point.pos);
    751          			//printf("write flash:%ld,%ld,%ld\n",flash_music.addr,flash_music.len,flash_music.pos);
    752          		// 取出当前的播放位置进行保存
    753          			u_msc.break_point.pos = flash_music.pos;
   \                     ??CrossCallReturnLabel_8:
   \   000041   12....       LCALL   ?L_MOV_X
   \   000044   90....       MOV     DPTR,#(u_msc + 13)
   \   000047   78..         MOV     R0,#?V0 + 0
   \   000049   12....       LCALL   ?L_MOV_TO_X
    754          			irtc_write_ram(RTCRAM_MUSIC_POS_SD1,(u8 *)&u_msc.break_point, 8);
   \   00004C                ; Setup parameters for call to function irtc_write_ram
   \   00004C   7C08         MOV     R4,#0x8
   \   00004E   7A..         MOV     R2,#((u_msc + 9) & 0xff)
   \   000050   7B..         MOV     R3,#(((u_msc + 9) >> 8) & 0xff)
   \   000052   790A         MOV     R1,#0xa
   \   000054   12....       LCALL   irtc_write_ram
    755          #endif
    756          			//printf("SD change write\n");
    757          			write_flash_num_rtcram();
   \   000057                ; Setup parameters for call to function write_flash_num_rtcram
   \   000057   12....       LCALL   write_flash_num_rtcram
    758          			task_ctl.work_sta = TASK_EXIT;
   \   00005A   75..0C       MOV     task_ctl,#0xc
   \   00005D   8006         SJMP    ??task_flash_music_event_5
    759          		}
    760          
    761          		if(task_ctl.work_sta != TASK_FLASH)
   \                     ??task_flash_music_event_4:
   \   00005F   7406         MOV     A,#0x6
   \   000061   65..         XRL     A,task_ctl
   \   000063   600B         JZ      ??task_flash_music_event_6
    762          		{
    763          			music_stop();
   \                     ??task_flash_music_event_5:
   \   000065                ; Setup parameters for call to function music_stop
   \   000065   12....       LCALL   music_stop
    764          
    765          			u_spi.spi_music_flag = 0;
   \   000068   E4           CLR     A
   \   000069   90....       MOV     DPTR,#u_spi
   \   00006C   F0           MOVX    @DPTR,A
    766          			return;
   \   00006D   02....       LJMP    ??task_flash_music_event_7
    767          		}
    768          
    769          		//打开新文件
    770          #if 1
    771          
    772          #if 0	// Melrin Remove 2016/04/15
    773          		if(b_msc.file_change)
    774          		{
    775          			b_dac.mute_en = 1; user_set_mute(); // 开始播放
    776          	#if REPEAT_AS_ONE
    777          			if(b_msc.repeat_as_one_flag == 0)
    778          	#endif
    779          			{
    780          			#if	1	//JianRong add 2015-06-10
    781          				msc_ctl.mscfade_en = 1;//使能调用dac淡出功能
    782          			 	music_stop();
    783          			#elif (DAC_FADE_EN==1)
    784          			//	dac_fade_in(0);
    785          			#endif
    786          			}
    787          		}
    788          #endif
    789          #else
    790          		if(b_msc.file_change)
    791          		{
    792          			//if(music_get_status() > STATUS_PLAY_STOPPING)
    793          			//	return;
    794          #if LED_EN
    795          			ocx.led_sta = LED_STA_FAST_GLITTER;
    796          #endif
    797          #if USE_Flash_BREAK_POINT
    798          			if(b_msc.break_init)
    799          			{
    800          				rtcram_read_multi(RTCRAM_MUSIC_POS_SD1,(u8 *)&u_msc.break_point, 8);	//如果SD_CMD与IIC复用，需在读文件前读出断点信息
    801          			}
    802          #endif
    803          
    804          			task_flash_music_new();
    805          			irtc_write_ram((1 * RTCRAM_OFFSET + RTCRAM_MUSIC_POS_SD + 8), (u8 *)&u_msc.music_num, 2);
    806          
    807          			shownum(u_msc.music_num + 1);
    808          			printf("1111u_msc.music_num=%d\n",u_msc.music_num+1);
    809          #if USE_Flash_BREAK_POINT
    810          			if(b_msc.break_init)
    811          			{
    812          				b_msc.break_init = 0;
    813          				// need modify Merlin 2015/04/25
    814          				//	printf("@frame = %ld pos= %ld,", u_msc.break_point.frame, u_msc.break_point.pos);
    815          				//music_jump(&u_msc.break_point);
    816          				flash_music.pos = u_msc.break_point.pos;
    817          				//printf("flash:%ld,%ld,%ld ",flash_music.addr,flash_music.len,flash_music.pos);
    818          			}
    819          #endif
    820          		}
    821          
    822          #endif
    823          
    824          #if USE_Flash_BREAK_POINT
    825          		if(b_msc.break_init)
   \                     ??task_flash_music_event_6:
   \   000070   A2..         MOV     C,b_msc.3
   \   000072   5003         JNC     ??task_flash_music_event_8
    826          		{
    827          			read_flash_num_rtcram();
   \   000074                ; Setup parameters for call to function read_flash_num_rtcram
   \   000074   12....       LCALL   read_flash_num_rtcram
    828          		}
    829          #endif
    830          
    831          		task_flash_music_new();
   \                     ??task_flash_music_event_8:
   \   000077                ; Setup parameters for call to function task_flash_music_new
   \   000077   12....       LCALL   task_flash_music_new
    832          #if USE_Flash_BREAK_POINT
    833          		if(b_msc.break_init)
   \   00007A   A2..         MOV     C,b_msc.3
   \   00007C   5010         JNC     ??task_flash_music_event_9
    834          		{
    835          			b_msc.break_init = 0;
   \   00007E   C2..         CLR     b_msc.3
    836          			//task_music_break_init();
    837          			rtcram_read_multi(RTCRAM_MUSIC_POS_SD1,(u8 *)&u_msc.break_point, 8);	// 读出断点信息
   \   000080                ; Setup parameters for call to function rtcram_read_multi
   \   000080   12....       LCALL   ?Subroutine5
    838          			flash_music.pos = u_msc.break_point.pos;
   \                     ??CrossCallReturnLabel_12:
   \   000083   12....       LCALL   ?L_MOV_X
   \   000086   90....       MOV     DPTR,#(flash_music + 8)
   \   000089   78..         MOV     R0,#?V0 + 0
   \   00008B   12....       LCALL   ?L_MOV_TO_X
    839          		}
    840          #endif
    841          
    842          		task_music_cal_time();                      //计算当前显示的时间
   \                     ??task_flash_music_event_9:
   \   00008E                ; Setup parameters for call to function task_music_cal_time
   \   00008E   12....       LCALL   task_music_cal_time
    843          
    844          #if 1	// 测试程式  修剪音频  20170614
    845          		{
    846          			static u32 last_pos;
    847          			if(last_pos != flash_music.pos)
   \   000091   90....       MOV     DPTR,#(flash_music + 8)
   \   000094   78..         MOV     R0,#?V0 + 0
   \   000096   12....       LCALL   ?L_MOV_X
   \   000099   90....       MOV     DPTR,#??last_pos
   \   00009C   78..         MOV     R0,#?V0 + 0
   \   00009E   12....       LCALL   ?L_EQ_X
   \   0000A1   6008         JZ      ??task_flash_music_event_10
    848          			{
    849          				last_pos = flash_music.pos;
   \   0000A3   90....       MOV     DPTR,#??last_pos
   \   0000A6   78..         MOV     R0,#?V0 + 0
   \   0000A8   12....       LCALL   ?L_MOV_TO_X
    850          			//	printf("f.%lx, %lx, %lx(%d).%d\n", flash_music.addr, flash_music.len, flash_music.pos, music_get_status(),u_msc.music_num);
    851          			//	printf("f.%lx, %lx\n", flash_music.len, flash_music.pos);
    852          				/*if(flash_music.pos == 0x50L)
    853          				{
    854          					flash_music.pos = flash_music.len - 0x50L;
    855          				}*/
    856          			}
    857          		}
    858          #endif
    859          
    860          #if 1     //  20170509   wq
    861          		if(flash_music.len <= flash_music.pos)   //if(flash_music.len-4 <= flash_music.pos)
   \                     ??task_flash_music_event_10:
   \   0000AB   90....       MOV     DPTR,#(flash_music + 4)
   \   0000AE   78..         MOV     R0,#?V0 + 0
   \   0000B0   12....       LCALL   ?L_MOV_X
   \   0000B3   7583..       MOV     DPH,#(((flash_music + 8) >> 8) & 0xff)
   \   0000B6   7582..       MOV     DPL,#((flash_music + 8) & 0xff)
   \   0000B9   78..         MOV     R0,#?V0 + 0
   \   0000BB   12....       LCALL   ?UL_GT_X
   \   0000BE   4033         JC      ??task_flash_music_event_7
    862          		{
    863          			if(sys_ctl.mode_play != ITEM_LOOP_SINGLE)
   \   0000C0   90....       MOV     DPTR,#sys_ctl
   \   0000C3   E0           MOVX    A,@DPTR
   \   0000C4   6402         XRL     A,#0x2
   \   0000C6   6005         JZ      ??task_flash_music_event_11
    864          			{
    865          				task_flash_music_auto_next();
   \   0000C8                ; Setup parameters for call to function task_flash_music_auto_next
   \   0000C8   12....       LCALL   task_flash_music_auto_next
   \   0000CB   8026         SJMP    ??task_flash_music_event_7
    866          			}
    867          			else
    868          			{
    869          				if(!b_msc.pause)  //通过打印发现，如果按暂停时还进来这里会导致播放后没有声音输出且不能暂停，切换上下曲也一直没声音
   \                     ??task_flash_music_event_11:
   \   0000CD   A2..         MOV     C,b_msc.1
   \   0000CF   4022         JC      ??task_flash_music_event_7
    870          				{
    871          					printf("SINGLE Loop\n");
   \   0000D1                ; Setup parameters for call to function my_printf
   \   0000D1   7A..         MOV     R2,#(`?<Constant "SINGLE Loop\\n">` & 0xff)
   \   0000D3   7B..         MOV     R3,#((`?<Constant "SINGLE Loop\\n">` >> 8) & 0xff)
   \   0000D5   12....       LCALL   my_printf
    872          					/*
    873          					if(sys_ctl.bat_sta_flag == 2)
    874          					{
    875          						if(task_ctl.last_work == TASK_FLASH)
    876          						{
    877          							task_flash_music_direct(1);
    878          							if(u_msc.music_num_last != 6)
    879          							{
    880          								u_msc.music_num = u_msc.music_num_last;
    881          							}else
    882          							{
    883          								u_msc.music_num = 0;
    884          							}
    885          						}else
    886          						{
    887          							if(u_msc.music_num_last != 6)
    888          							{
    889          								u_msc.music_num = u_msc.music_num_last;
    890          							}else
    891          							{
    892          								u_msc.music_num = 0;
    893          							}
    894          							task_ctl.work_sta = task_ctl.last_work;
    895          						}
    896          						sys_ctl.bat_sta_flag = 3;
    897          						sys_ctl.alarm_cnt = 0x00;
    898          						alarm_flag = 0;
    899          						printf("Alarm\n");
    900          					}
    901          					*/
    902          					flash_music.pos = 0L;
   \   0000D8   90....       MOV     DPTR,#__Constant_0
   \   0000DB   78..         MOV     R0,#?V0 + 0
   \   0000DD   12....       LCALL   ?L_MOV_C
   \   0000E0   90....       MOV     DPTR,#(flash_music + 8)
   \   0000E3   78..         MOV     R0,#?V0 + 0
   \   0000E5   12....       LCALL   ?L_MOV_TO_X
    903          					if(music_get_status() <= STATUS_PLAY_STOPPING)
   \   0000E8                ; Setup parameters for call to function music_get_status
   \   0000E8   12....       LCALL   music_get_status
   \   0000EB   E9           MOV     A,R1
   \   0000EC   C3           CLR     C
   \   0000ED   9402         SUBB    A,#0x2
   \   0000EF   5002         JNC     ??task_flash_music_event_7
    904          					{
    905          						b_msc.file_change = 1;
   \   0000F1   D2..         SETB    b_msc.0
   \                     ??task_flash_music_event_7:
   \   0000F3   02....       LJMP    ?Subroutine7
    906          					}
    907          				}
    908          			}
    909          		}
    910          #else
    911          
    912          
    913          
    914          		//判断音乐的播放状态
    915          		if(music_get_status() <= STATUS_PLAY_STOPPING)
    916          		{
    917          #if REPEAT_AS_ONE
    918          			b_msc.repeat_as_one_flag = 1;
    919          #else
    920          #if !ADD_BY_WUPENGFEI
    921          			if(sys_ctl.mode_play != ITEM_LOOP_SINGLE)
    922          #endif
    923          				task_flash_music_auto_next();
    924          #endif
    925          		}
    926          #endif
    927          }

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   7C08         MOV     R4,#0x8
   \   000002   7A..         MOV     R2,#((u_msc + 9) & 0xff)
   \   000004   7B..         MOV     R3,#(((u_msc + 9) >> 8) & 0xff)
   \   000006   790A         MOV     R1,#0xa
   \   000008   12....       LCALL   rtcram_read_multi
   \   00000B                ; Setup parameters for call to function my_printf
   \   00000B   90....       MOV     DPTR,#(u_msc + 13)
   \   00000E   78..         MOV     R0,#?V0 + 0
   \   000010   22           RET

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
   \                     ??last_pos:
   \   000000                DS 4
    928          extern void spi_test_2(void);
    929          
    930          /*****************************************************************************
    931           * Module    : SPI音乐播放任务入口
    932           *****************************************************************************/
    933          //任务初始化
    934          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
    935          void task_flash_music_enter(void)
   \                     task_flash_music_enter:
    936          {
   \   000000   7404         MOV     A,#0x4
   \   000002   12....       LCALL   ?FUNC_ENTER_SP
   \   000005                ; Saved register size: 7
   \   000005                ; Auto size: 0
    937          	set_sys_clk(SYS_24M);
   \   000005                ; Setup parameters for call to function set_sys_clk
   \   000005   F9           MOV     R1,A
   \   000006   12....       LCALL   set_sys_clk
    938          
    939          	spi_sd_mux_enter();
   \   000009                ; Setup parameters for call to function spi_sd_mux_enter
   \   000009   12....       LCALL   spi_sd_mux_enter
    940          	spi_port_init();
   \   00000C                ; Setup parameters for call to function spi_port_init
   \   00000C   12....       LCALL   spi_port_init
    941          	u_spi.spi_online=spi_flash_init();      //检测flash是否在线
   \   00000F                ; Setup parameters for call to function spi_flash_init
   \   00000F   12....       LCALL   spi_flash_init
   \   000012   E4           CLR     A
   \   000013   92E0         MOV     0xE0 /* A   */.0,C
   \   000015   90....       MOV     DPTR,#(u_spi + 1)
   \   000018   F0           MOVX    @DPTR,A
    942          
    943          	if(u_spi.spi_online)
   \   000019   7003         JNZ     $+5
   \   00001B   02....       LJMP    ??task_flash_music_enter_0
    944          	{
    945          		u_spi.spi_music_flag = 1;
   \   00001E   7401         MOV     A,#0x1
   \   000020   90....       MOV     DPTR,#u_spi
   \   000023   F0           MOVX    @DPTR,A
    946          	}
    947          	else
    948          	{
    949          
    950          		if(!(device_is_actived(DEVICE_SDMMC1) || device_is_actived(DEVICE_SDMMC1)))
    951          		{
    952          			printf("No Device!");
    953          			showhello();	// 没有可用的装置, 显示 888
    954          			//delay_5ms(250);
    955          		}
    956          		task_ctl.work_sta = TASK_EXIT;
    957          		return;
    958          	}
    959          	f_Encrypt = false;
   \   000024   E4           CLR     A
   \   000025   90....       MOV     DPTR,#f_Encrypt
   \   000028   F0           MOVX    @DPTR,A
    960          	if(first==0)
   \   000029   90....       MOV     DPTR,#first
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   700E         JNZ     ??task_flash_music_enter_1
    961          	{
    962          		disp_device();
   \   00002F                ; Setup parameters for call to function led_7p7s_disp_device
   \   00002F   12....       LCALL   led_7p7s_disp_device
    963          		delay_5ms(50);
   \   000032                ; Setup parameters for call to function delay_5ms
   \   000032   7932         MOV     R1,#0x32
   \   000034   12....       LCALL   delay_5ms
    964          		first=1;
   \   000037   7401         MOV     A,#0x1
   \   000039   90....       MOV     DPTR,#first
   \   00003C   F0           MOVX    @DPTR,A
    965          	}
    966          	user_set_eq(0);//设置EQ
   \                     ??task_flash_music_enter_1:
   \   00003D                ; Setup parameters for call to function user_set_eq
   \   00003D   7900         MOV     R1,#0x0
   \   00003F   12....       LCALL   user_set_eq
    967          
    968          #if DAC_FADE_EN
    969          //	b_dac.sound_en = 0;                      //关闭动态降噪 ，加快声音输出
    970          	b_dac.sound_en = 0;                      //动态降噪
   \   000042   C2..         CLR     b_dac.4
    971          	msc_ctl.mscfade_en = 0;
   \   000044   E4           CLR     A
   \   000045   90....       MOV     DPTR,#(msc_ctl + 26)
   \   000048   F0           MOVX    @DPTR,A
    972              b_dac.digvol_en = 1;  					//JianRong 2015-06-10
   \   000049   D2..         SETB    b_dac.3
    973          #else
    974          	msc_ctl.mscfade_en = 0;
    975          	b_dac.digvol_en = 1;
    976          	dac_set_volume_direct(0);
    977          #endif
    978          	dac_set_volume_direct(0);
   \   00004B                ; Setup parameters for call to function dac_set_volume_direct
   \   00004B   F9           MOV     R1,A
   \   00004C   12....       LCALL   dac_set_volume_direct
    979          	//user_set_mute();
    980          	memset(&u_msc, 0, sizeof(u_msc));			//清除音乐文件信息
   \   00004F                ; Setup parameters for call to function my_memset
   \   00004F   7C17         MOV     R4,#0x17
   \   000051   7D00         MOV     R5,#0x0
   \   000053   7900         MOV     R1,#0x0
   \   000055   7A..         MOV     R2,#(u_msc & 0xff)
   \   000057   7B..         MOV     R3,#((u_msc >> 8) & 0xff)
   \   000059   12....       LCALL   my_memset
    981          
    982          	b_msc.pause = 0;                        //播放信息初始化
    983          	b_msc.file_change = 1;                  //需要打开一个新文件
    984          #if USE_Flash_BREAK_POINT
    985          	b_msc.break_init = 1;					// 2015/06/06 Merlin
   \   00005C   C2..         CLR     b_msc.1
   \   00005E   43..09       ORL     b_msc,#0x9
    986          #endif
    987          
    988          	u_msc.music_total = get_Flash_TotalFiles();	//ALL_MP3_TOTAL;
   \   000061                ; Setup parameters for call to function get_Flash_TotalFiles
   \   000061   12....       LCALL   get_Flash_TotalFiles
   \   000064   90....       MOV     DPTR,#(u_msc + 4)
   \   000067   EA           MOV     A,R2
   \   000068   F0           MOVX    @DPTR,A
   \   000069   A3           INC     DPTR
   \   00006A   EB           MOV     A,R3
   \   00006B   F0           MOVX    @DPTR,A
    989          	printf("Total:%d\n",u_msc.music_total);
   \   00006C                ; Setup parameters for call to function my_printf
   \   00006C   90....       MOV     DPTR,#(u_msc + 4)
   \   00006F   12....       LCALL   ?PUSH_ISTACK_X_TWO
   \   000072   7A..         MOV     R2,#(`?<Constant "Total:%d\\n">` & 0xff)
   \   000074   7B..         MOV     R3,#((`?<Constant "Total:%d\\n">` >> 8) & 0xff)
   \   000076   12....       LCALL   my_printf
   \   000079   D0E0         POP     A
   \   00007B   D0E0         POP     A
    990          	u_spi.spi_play_mode = ALL_DIR;			//默认全部文件夹循环
   \   00007D   E4           CLR     A
   \   00007E   90....       MOV     DPTR,#(u_spi + 2)
   \   000081   F0           MOVX    @DPTR,A
    991          	sys_ctl.flash_music_sta = 0;//VOICE;	//从第一个文件夹开始，VOICE文件夹
   \   000082   90....       MOV     DPTR,#(sys_ctl + 9)
   \   000085   F0           MOVX    @DPTR,A
    992          	//u_msc.music_num = 0;			//第一首歌曲
    993          
    994          	read_flash_num_rtcram();	// 曲目的位置独立保存, 断点位置 放在 RTCRAM_MUSIC_POS_SD1
   \   000086                ; Setup parameters for call to function read_flash_num_rtcram
   \   000086   12....       LCALL   read_flash_num_rtcram
    995          
    996          	// 检查是否超出范围
    997          	if(u_msc.music_num > u_msc.music_total)
   \   000089   90....       MOV     DPTR,#u_msc
   \   00008C   E0           MOVX    A,@DPTR
   \   00008D   F8           MOV     R0,A
   \   00008E   A3           INC     DPTR
   \   00008F   E0           MOVX    A,@DPTR
   \   000090   F9           MOV     R1,A
   \   000091   7583..       MOV     DPH,#(((u_msc + 4) >> 8) & 0xff)
   \   000094   7582..       MOV     DPL,#((u_msc + 4) & 0xff)
   \   000097   C3           CLR     C
   \   000098   E0           MOVX    A,@DPTR
   \   000099   98           SUBB    A,R0
   \   00009A   A3           INC     DPTR
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   99           SUBB    A,R1
   \   00009D   5009         JNC     ??task_flash_music_enter_2
    998          	{
    999          		b_msc.break_init = 0;
   \   00009F   C2..         CLR     b_msc.3
   1000          		u_msc.music_num = 0;
   \   0000A1   90....       MOV     DPTR,#u_msc
   \   0000A4   E4           CLR     A
   \   0000A5   F0           MOVX    @DPTR,A
   \   0000A6   A3           INC     DPTR
   \   0000A7   F0           MOVX    @DPTR,A
   1001          	}
   1002          
   1003          
   1004          	//u_msc.music_num = 0;	// for test only
   1005          
   1006          
   1007          
   1008          	//if(music_get_status() > STATUS_PLAY_STOPPING)
   1009          	//	return;
   1010          //#if LED_EN
   1011          	ocx.led_sta = LED_STA_ON;
   \                     ??task_flash_music_enter_2:
   \   0000A8   78..         MOV     R0,#(ocx + 17)
   \   0000AA   7601         MOV     @R0,#0x1
   1012          //#endif
   1013          #if USE_Flash_BREAK_POINT
   1014          	if(b_msc.break_init || (device_chg  & BIT(device_music)))
   \   0000AC   A2..         MOV     C,b_msc.3
   \   0000AE   4008         JC      ??task_flash_music_enter_3
   \   0000B0   90....       MOV     DPTR,#device_chg
   \   0000B3   E0           MOVX    A,@DPTR
   \   0000B4   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000B6   5024         JNC     ??task_flash_music_enter_4
   1015          	{
   1016          		rtcram_read_multi(RTCRAM_MUSIC_POS_SD1,(u8 *)&u_msc.break_point, 8);	// 如果SD_CMD与IIC复用，需在读文件前读出断点信息
   \                     ??task_flash_music_enter_3:
   \   0000B8                ; Setup parameters for call to function rtcram_read_multi
   \   0000B8   12....       LCALL   ?Subroutine5
   1017          		printf("Break %ld, %ld\n", u_msc.break_point.frame, u_msc.break_point.pos);
   \                     ??CrossCallReturnLabel_13:
   \   0000BB   12....       LCALL   ?L_MOV_X
   \   0000BE   78..         MOV     R0,#?V0 + 0
   \   0000C0   12....       LCALL   ?PUSH_ISTACK_I_FOUR
   \   0000C3   90....       MOV     DPTR,#(u_msc + 9)
   \   0000C6   78..         MOV     R0,#?V0 + 0
   \   0000C8   12....       LCALL   ?L_MOV_X
   \   0000CB   78..         MOV     R0,#?V0 + 0
   \   0000CD   12....       LCALL   ?PUSH_ISTACK_I_FOUR
   \   0000D0   7A..         MOV     R2,#(`?<Constant "Break %ld, %ld\\n">` & 0xff)
   \   0000D2   7B..         MOV     R3,#((`?<Constant "Break %ld, %ld\\n">` >> 8) & 0xff)
   \   0000D4   12....       LCALL   my_printf
   \   0000D7   74F8         MOV     A,#-0x8
   \   0000D9   12....       LCALL   ?DEALLOC_EXT_STACK8
   1018          	}
   1019          #endif
   1020          //		task_flash_music_new();
   1021          #if 1
   1022          //	music_stop();                               //停止播放器
   1023          	b_msc.file_change = 0;                      //播放指定歌曲
   \                     ??task_flash_music_enter_4:
   \   0000DC   C2..         CLR     b_msc.0
   1024          
   1025          	if(task_flash_music_init(u_msc.music_num))
   \   0000DE                ; Setup parameters for call to function task_flash_music_init
   \   0000DE   90....       MOV     DPTR,#u_msc
   \   0000E1   12....       LCALL   ?Subroutine1
   \                     ??CrossCallReturnLabel_4:
   \   0000E4   5008         JNC     ??task_flash_music_enter_5
   1026          	{
   1027          		music_play();
   \   0000E6                ; Setup parameters for call to function music_play
   \   0000E6   12....       LCALL   music_play
   1028          		b_msc.pause = 0;
   \   0000E9   C2..         CLR     b_msc.1
   1029          		user_set_mute();
   \   0000EB                ; Setup parameters for call to function user_set_mute
   \   0000EB   12....       LCALL   user_set_mute
   1030          	}
   1031          #endif
   1032          
   1033          #if REPEAT_AS_ONE
   1034          	b_msc.repeat_as_one_flag = 0;
   1035          #endif
   1036          
   1037          	// 保存当前曲目位置
   1038          	irtc_write_ram(RTCRAM_MUSIC_NUM_SD1, (u8 *)&u_msc.music_num, 2);
   \                     ??task_flash_music_enter_5:
   \   0000EE                ; Setup parameters for call to function irtc_write_ram
   \   0000EE   7C02         MOV     R4,#0x2
   \   0000F0   7A..         MOV     R2,#(u_msc & 0xff)
   \   0000F2   7B..         MOV     R3,#((u_msc >> 8) & 0xff)
   \   0000F4   7912         MOV     R1,#0x12
   \   0000F6   12....       LCALL   irtc_write_ram
   1039          
   1040          #if USE_Flash_BREAK_POINT
   1041          	printf("device_chg = %d\n", device_chg);
   \   0000F9                ; Setup parameters for call to function my_printf
   \   0000F9   90....       MOV     DPTR,#device_chg
   \   0000FC   E0           MOVX    A,@DPTR
   \   0000FD   F582         MOV     DPL,A
   \   0000FF   8E83         MOV     DPH,R6
   \   000101   C082         PUSH    DPL
   \   000103   C083         PUSH    DPH
   \   000105   7A..         MOV     R2,#(`?<Constant "device_chg = %d\\n">` & 0xff)
   \   000107   7B..         MOV     R3,#((`?<Constant "device_chg = %d\\n">` >> 8) & 0xff)
   \   000109   12....       LCALL   my_printf
   \   00010C   D0E0         POP     A
   \   00010E   D0E0         POP     A
   1042          	if(b_msc.break_init || (device_chg  & BIT(device_music)))
   \   000110   A2..         MOV     C,b_msc.3
   \   000112   4008         JC      ??task_flash_music_enter_6
   \   000114   90....       MOV     DPTR,#device_chg
   \   000117   E0           MOVX    A,@DPTR
   \   000118   A2E0         MOV     C,0xE0 /* A   */.0
   \   00011A   501F         JNC     ??task_flash_music_enter_7
   1043          	{
   1044          		//解决播放重复的问题
   1045          		b_msc.break_init = 0;
   \                     ??task_flash_music_enter_6:
   \   00011C   C2..         CLR     b_msc.3
   1046          		flash_music.pos = u_msc.break_point.pos;
   \   00011E   90....       MOV     DPTR,#(u_msc + 13)
   \   000121   78..         MOV     R0,#?V0 + 0
   \   000123   12....       LCALL   ?L_MOV_X
   \   000126   90....       MOV     DPTR,#(flash_music + 8)
   \   000129   78..         MOV     R0,#?V0 + 0
   \   00012B   12....       LCALL   ?L_MOV_TO_X
   1047          		memset((void *)0x3cb,0x00,0x3D1-0x3CB);		// clear DAC_XDATA
   \   00012E                ; Setup parameters for call to function my_memset
   \   00012E   7C06         MOV     R4,#0x6
   \   000130   7D00         MOV     R5,#0x0
   \   000132   7900         MOV     R1,#0x0
   \   000134   7ACB         MOV     R2,#-0x35
   \   000136   7B03         MOV     R3,#0x3
   \   000138   12....       LCALL   my_memset
   1048          		//memset((void *)0x7D0,0x00,0x1000-0x7D0);	// clear DECODER_BUF
   1049          		//printf("start memset\n");
   1050          		//printf("read flash:%ld,%ld,%ld\n",flash_music.addr,flash_music.len,flash_music.pos);
   1051          //		device_chg = 0;
   1052          	}
   1053          #endif
   1054          
   1055          //#if LED_EN
   1056          	ocx.led_sta = LED_STA_ON;
   \                     ??task_flash_music_enter_7:
   \   00013B   78..         MOV     R0,#(ocx + 17)
   \   00013D   7601         MOV     @R0,#0x1
   1057          //#endif
   1058          
   1059          #if DISP_Show_Device
   1060          	ocx_msgbox("-1-");
   1061          #endif
   1062          
   1063          	dac_set_volume(0);
   \   00013F                ; Setup parameters for call to function dac_set_volume
   \   00013F   7900         MOV     R1,#0x0
   \   000141   12....       LCALL   dac_set_volume
   1064          
   1065          #if 1	// same as task_music
   1066          	mute_disable();
   \   000144                ; Setup parameters for call to function mute_disable
   \   000144   12....       LCALL   mute_disable
   1067          	sound_ctl_init(10, 0x20, 100, 0x1a);
   \   000147                ; Setup parameters for call to function sound_ctl_init
   \   000147   7C1A         MOV     R4,#0x1a
   \   000149   7B64         MOV     R3,#0x64
   \   00014B   7A20         MOV     R2,#0x20
   \   00014D   790A         MOV     R1,#0xa
   \   00014F   12....       LCALL   sound_ctl_init
   1068          #else
   1069          	mute_disable();
   1070          	sound_ctl_init(1, 0x00, 100, 0x1a);     //关闭淡入淡出
   1071          #endif
   1072          
   1073          	for(u8 i = 60; i; i--)
   \   000152   7E3C         MOV     R6,#0x3c
   1074          	{
   1075          		delay_5ms(1);
   \                     ??task_flash_music_enter_8:
   \   000154                ; Setup parameters for call to function delay_5ms
   \   000154   7901         MOV     R1,#0x1
   \   000156   12....       LCALL   delay_5ms
   1076          		music_event();
   \   000159                ; Setup parameters for call to function music_event
   \   000159   12....       LCALL   music_event
   1077          	}
   \   00015C   1E           DEC     R6
   \   00015D   EE           MOV     A,R6
   \   00015E   70F4         JNZ     ??task_flash_music_enter_8
   1078          	//dac_set_volume_direct(sys_ctl.volume);
   1079          	dac_set_volume(sys_ctl.volume);
   \   000160                ; Setup parameters for call to function dac_set_volume
   \   000160   90....       MOV     DPTR,#(sys_ctl + 2)
   \   000163   E0           MOVX    A,@DPTR
   \   000164   F9           MOV     R1,A
   \   000165   12....       LCALL   dac_set_volume
   1080          //	task_flash_music_direct(0);
   1081          }
   \                     ??task_flash_music_enter_9:
   \   000168   7F04         MOV     R7,#0x4
   \   00016A   02....       LJMP    ?FUNC_LEAVE_SP
   \                     ??task_flash_music_enter_0:
   \   00016D                ; Setup parameters for call to function device_is_actived
   \   00016D   7901         MOV     R1,#0x1
   \   00016F   12....       LCALL   device_is_actived
   \   000172   4015         JC      ??task_flash_music_enter_10
   \   000174                ; Setup parameters for call to function device_is_actived
   \   000174   7901         MOV     R1,#0x1
   \   000176   12....       LCALL   device_is_actived
   \   000179   400E         JC      ??task_flash_music_enter_10
   \   00017B                ; Setup parameters for call to function my_printf
   \   00017B   7A..         MOV     R2,#(`?<Constant "No Device!">` & 0xff)
   \   00017D   7B..         MOV     R3,#((`?<Constant "No Device!">` >> 8) & 0xff)
   \   00017F   12....       LCALL   my_printf
   \   000182                ; Setup parameters for call to function led_7p7s_disp_str
   \   000182   7A..         MOV     R2,#(`?<Constant " on">` & 0xff)
   \   000184   7B..         MOV     R3,#((`?<Constant " on">` >> 8) & 0xff)
   \   000186   12....       LCALL   led_7p7s_disp_str
   \                     ??task_flash_music_enter_10:
   \   000189   75..0C       MOV     task_ctl,#0xc
   \   00018C   80DA         SJMP    ??task_flash_music_enter_9
   1082          
   1083          //任务退出
   1084          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   1085          void task_flash_music_exit(void)
   \                     task_flash_music_exit:
   1086          {
   \   000000   C0..         PUSH    ?V0 + 0
   \   000002   C0..         PUSH    ?V0 + 1
   \   000004   C0..         PUSH    ?V0 + 2
   \   000006   C0..         PUSH    ?V0 + 3
   \   000008                ; Saved register size: 4
   \   000008                ; Auto size: 0
   1087          	//delay_5ms(20);
   1088          	//mute_enable();
   1089          	SD_FLAG=1;
   \   000008   7401         MOV     A,#0x1
   \   00000A   90....       MOV     DPTR,#SD_FLAG
   \   00000D   F0           MOVX    @DPTR,A
   1090          #if USE_Flash_BREAK_POINT
   1091          	if(task_ctl.work_sta != TASK_EXIT)
   \   00000E   740C         MOV     A,#0xc
   \   000010   65..         XRL     A,task_ctl
   \   000012   6019         JZ      ??task_flash_music_exit_0
   1092          	{
   1093          		music_get_point(&u_msc.break_point);
   \   000014                ; Setup parameters for call to function music_get_point
   \   000014   12....       LCALL   ?Subroutine3
   1094          		u_msc.break_point.pos = flash_music.pos;
   \                     ??CrossCallReturnLabel_9:
   \   000017   12....       LCALL   ?L_MOV_X
   \   00001A   90....       MOV     DPTR,#(u_msc + 13)
   \   00001D   78..         MOV     R0,#?V0 + 0
   \   00001F   12....       LCALL   ?L_MOV_TO_X
   1095          		irtc_write_ram(RTCRAM_MUSIC_POS_SD1,(u8 *)&u_msc.break_point, 8);
   \   000022                ; Setup parameters for call to function irtc_write_ram
   \   000022   7C08         MOV     R4,#0x8
   \   000024   7A..         MOV     R2,#((u_msc + 9) & 0xff)
   \   000026   7B..         MOV     R3,#(((u_msc + 9) >> 8) & 0xff)
   \   000028   790A         MOV     R1,#0xa
   \   00002A   12....       LCALL   irtc_write_ram
   1096          	}
   1097          #endif
   1098          
   1099          	printf("task flash exit\n");
   \                     ??task_flash_music_exit_0:
   \   00002D                ; Setup parameters for call to function my_printf
   \   00002D   7A..         MOV     R2,#(`?<Constant "task flash exit\\n">` & 0xff)
   \   00002F   7B..         MOV     R3,#((`?<Constant "task flash exit\\n">` >> 8) & 0xff)
   \   000031   12....       LCALL   my_printf
   1100          	msc_ctl.mscfade_en = 1;			//退出音乐模式时淡出，必须放在music_stop之前
   \   000034   7401         MOV     A,#0x1
   \   000036   90....       MOV     DPTR,#(msc_ctl + 26)
   \   000039   F0           MOVX    @DPTR,A
   1101          	music_stop();
   \   00003A                ; Setup parameters for call to function music_stop
   \   00003A   12....       LCALL   music_stop
   1102          	b_dac.sound_en = 0;
   \   00003D   C2..         CLR     b_dac.4
   1103          	delay_5ms(20);
   \   00003F                ; Setup parameters for call to function delay_5ms
   \   00003F   7914         MOV     R1,#0x14
   \   000041   12....       LCALL   delay_5ms
   1104          #if DAC_FADE_EN
   1105          	dac_fade_out();
   \   000044                ; Setup parameters for call to function dac_fade_out
   \   000044   12....       LCALL   dac_fade_out
   1106          	dac_fade_wait();
   \   000047                ; Setup parameters for call to function dac_fade_wait
   \   000047   12....       LCALL   dac_fade_wait
   1107          #endif
   1108              user_change_volume(0);         // 退出task_flash 开MUTE前将当前音量设为0，延时0.2s,开MUTE   20170901
   \   00004A                ; Setup parameters for call to function user_change_volume
   \   00004A   7900         MOV     R1,#0x0
   \   00004C   12....       LCALL   user_change_volume
   1109          	delay_5ms(40);
   \   00004F                ; Setup parameters for call to function delay_5ms
   \   00004F   7928         MOV     R1,#0x28
   \   000051   12....       LCALL   delay_5ms
   1110          	mute_enable();
   \   000054                ; Setup parameters for call to function mute_enable
   \   000054   12....       LCALL   mute_enable
   1111          #ifdef REMOVED
   1112          #if USE_SDCMD_IIC_SPIDAT
   1113          	spi_sd_mux_exit();
   1114          	sd_port_init(1);
   1115          #endif
   1116          #else
   1117          	if(u_spi.spi_online)
   \   000057   90....       MOV     DPTR,#(u_spi + 1)
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   6003         JZ      ??task_flash_music_exit_1
   1118          	{
   1119          		spi_sd_mux_exit();
   \   00005D                ; Setup parameters for call to function spi_sd_mux_exit
   \   00005D   12....       LCALL   spi_sd_mux_exit
   1120          		//sd_port_init(1);
   1121          	}
   1122          	u_spi.spi_music_flag = 0;
   \                     ??task_flash_music_exit_1:
   \   000060   E4           CLR     A
   \   000061   90....       MOV     DPTR,#u_spi
   \   000064   F0           MOVX    @DPTR,A
   1123          #endif /* REMOVED */
   1124          
   1125          }
   \   000065                REQUIRE ?Subroutine7
   \   000065                ; // Fall through to label ?Subroutine7
   1126          
   1127          //任务主流程
   1128          #pragma location="TASK_FLASH_SEG"

   \                                 In segment TASK_FLASH_SEG, align 1, keep-with-next
   1129          void task_flash_music(void)
   \                     task_flash_music:
   1130          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1131          	printf("task_flash\n");
   \   000000                ; Setup parameters for call to function my_printf
   \   000000   7A..         MOV     R2,#(`?<Constant "task_flash\\n">` & 0xff)
   \   000002   7B..         MOV     R3,#((`?<Constant "task_flash\\n">` >> 8) & 0xff)
   \   000004   12....       LCALL   my_printf
   1132          	task_flash_music_enter();
   \   000007                ; Setup parameters for call to function task_flash_music_enter
   \   000007   12....       LCALL   task_flash_music_enter
   \   00000A   8009         SJMP    ??task_flash_music_0
   1133          	while((task_ctl.work_sta == TASK_FLASH) && (Timer1_flag == false))
   1134          	{
   1135          		task_flash_music_event();
   \                     ??task_flash_music_1:
   \   00000C                ; Setup parameters for call to function task_flash_music_event
   \   00000C   12....       LCALL   task_flash_music_event
   1136          		task_flash_music_deal_msg(get_msg());
   \   00000F                ; Setup parameters for call to function task_flash_music_deal_msg
   \   00000F                ; Setup parameters for call to function get_msg
   \   00000F   12....       LCALL   get_msg
   \   000012   12....       LCALL   task_flash_music_deal_msg
   1137          		//task_music_display();
   1138          	}
   \                     ??task_flash_music_0:
   \   000015   7406         MOV     A,#0x6
   \   000017   65..         XRL     A,task_ctl
   \   000019   7006         JNZ     ??task_flash_music_2
   \   00001B   90....       MOV     DPTR,#Timer1_flag
   \   00001E   E0           MOVX    A,@DPTR
   \   00001F   60EB         JZ      ??task_flash_music_1
   1139          	task_flash_music_exit();
   \                     ??task_flash_music_2:
   \   000021                ; Setup parameters for call to function task_flash_music_exit
   \   000021   12....       LCALL   task_flash_music_exit
   1140          	if(task_ctl.work_sta != TASK_POWEROFF)
   \   000024   7409         MOV     A,#0x9
   \   000026   65..         XRL     A,task_ctl
   \   000028   6003         JZ      ??task_flash_music_3
   1141          	{
   1142          	task_ctl.work_sta = TASK_IDLE;
   \   00002A   75..08       MOV     task_ctl,#0x8
   1143          	}
   1144          }
   \                     ??task_flash_music_3:
   \   00002D   22           RET

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "dir_start:%d\\n">`:
   \   000000   6469725F     DB "dir_start:%d\012"
   \            73746172
   \            743A2564
   \            0A00    

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "cur num:%d\\n">`:
   \   000000   63757220     DB "cur num:%d\012"
   \            6E756D3A
   \            25640A00

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "SINGLE Loop\\n">`:
   \   000000   53494E47     DB "SINGLE Loop\012"
   \            4C45204C
   \            6F6F700A
   \            00      

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "No Device!">`:
   \   000000   4E6F2044     DB "No Device!"
   \            65766963
   \            652100  

   \                                 In segment CODE_C, align 1
   \                     `?<Constant " on">`:
   \   000000   206F6E00     DB " on"

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "Total:%d\\n">`:
   \   000000   546F7461     DB "Total:%d\012"
   \            6C3A2564
   \            0A00    

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "Break %ld, %ld\\n">`:
   \   000000   42726561     DB "Break %ld, %ld\012"
   \            6B20256C
   \            642C2025
   \            6C640A00

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "device_chg = %d\\n">`:
   \   000000   64657669     DB "device_chg = %d\012"
   \            63655F63
   \            6867203D
   \            2025640A
   \            00      

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "task flash exit\\n">`:
   \   000000   7461736B     DB "task flash exit\012"
   \            20666C61
   \            73682065
   \            7869740A
   \            00      

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "task_flash\\n">`:
   \   000000   7461736B     DB "task_flash\012"
   \            5F666C61
   \            73680A00

   \                                 In segment CODE_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In segment CODE_C, align 1
   \                     __Constant_400:
   \   000000   00040000     DD 1024

   \                                 In segment CODE_C, align 1
   \                     __Constant_800:
   \   000000   00080000     DD 2048

   \                                 In segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IE0
   \                     _A_IE0:
   \   000000                DS 1
   1145          #endif

   Maximum stack usage in bytes:

     Function                       EXT_STACK PSTACK XSTACK
     --------                       --------- ------ ------
     get_Flash_TotalFiles                 22      0      0
       -> spi_read                        30      0      0
     get_dirstart                          4      0      0
       -> my_printf                        4      0      0
     get_dirtotal                          0      0      0
     task_flash_music                      0      0      0
       -> my_printf                        0      0      0
       -> task_flash_music_enter           0      0      0
       -> task_flash_music_event           0      0      0
       -> get_msg                          0      0      0
       -> task_flash_music_deal_msg        0      0      0
       -> task_flash_music_exit            0      0      0
     task_flash_music_auto_next            4      0      0
       -> task_flash_music_direct          0      0      0
     task_flash_music_deal_msg             6      0      0
       -> user_set_volume                  8      0      0
       -> deal_vol_msg                     8      0      0
       -> UN_MUTE                          8      0      0
       -> user_set_volume                  8      0      0
       -> deal_vol_msg                     8      0      0
       -> MUTE_EN                          8      0      0
       -> task_flash_music_direct          8      0      0
       -> task_flash_music_direct          8      0      0
       -> music_get_point                  8      0      0
       -> irtc_write_ram                   8      0      0
       -> deal_msg                         8      0      0
     task_flash_music_direct               7      0      0
       -> loop_auto                        6      0      0
     task_flash_music_display              0      0      0
       -> task_music_display               0      0      0
     task_flash_music_enter               15      0      0
       -> set_sys_clk                     14      0      0
       -> spi_sd_mux_enter                14      0      0
       -> spi_port_init                   14      0      0
       -> spi_flash_init                  14      0      0
       -> led_7p7s_disp_device            14      0      0
       -> delay_5ms                       14      0      0
       -> user_set_eq                     14      0      0
       -> dac_set_volume_direct           14      0      0
       -> my_memset                       14      0      0
       -> get_Flash_TotalFiles            14      0      0
       -> my_printf                       18      0      0
       -> read_flash_num_rtcram           14      0      0
       -> rtcram_read_multi               14      0      0
       -> my_printf                       30      0      0
       -> task_flash_music_init           14      0      0
       -> music_play                      14      0      0
       -> user_set_mute                   14      0      0
       -> irtc_write_ram                  14      0      0
       -> my_printf                       18      0      0
       -> my_memset                       14      0      0
       -> dac_set_volume                  14      0      0
       -> mute_disable                    14      0      0
       -> sound_ctl_init                  14      0      0
       -> delay_5ms                       14      0      0
       -> music_event                     14      0      0
       -> dac_set_volume                  14      0      0
       -> device_is_actived               14      0      0
       -> device_is_actived               14      0      0
       -> my_printf                       14      0      0
       -> led_7p7s_disp_str               14      0      0
     task_flash_music_event                6      0      0
       -> comm_event                       8      0      0
       -> comm_event                       8      0      0
       -> music_event                      8      0      0
       -> device_is_online                 8      0      0
       -> music_stop                       8      0      0
       -> music_get_point                  8      0      0
       -> irtc_write_ram                   8      0      0
       -> write_flash_num_rtcram           8      0      0
       -> music_stop                       8      0      0
       -> read_flash_num_rtcram            8      0      0
       -> task_flash_music_new             8      0      0
       -> rtcram_read_multi                8      0      0
       -> task_music_cal_time              8      0      0
       -> task_flash_music_auto_next
                                           8      0      0
       -> my_printf                        8      0      0
       -> music_get_status                 8      0      0
     task_flash_music_exit                 4      0      0
       -> music_get_point                  8      0      0
       -> irtc_write_ram                   8      0      0
       -> my_printf                        8      0      0
       -> music_stop                       8      0      0
       -> delay_5ms                        8      0      0
       -> dac_fade_out                     8      0      0
       -> dac_fade_wait                    8      0      0
       -> user_change_volume               8      0      0
       -> delay_5ms                        8      0      0
       -> mute_enable                      8      0      0
       -> spi_sd_mux_exit                  8      0      0
     task_flash_music_init                 7      0      0
       -> spi_mp3_index_read               0      0      0
       -> music_init                       0      0      0
     task_flash_music_new                  4      0      0
       -> music_play                       0      0      0
       -> write_flash_num_rtcram           0      0      0
       -> music_stop                       0      0      0
       -> task_flash_music_init            0      0      0
       -> task_flash_music_direct          0      0      0
       -> task_flash_music_direct          0      0      0
     task_flash_music_sel_mode             4      0      0
       -> get_dirstart                     4      0      0
       -> my_printf                        8      0      0


   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     P1DIR                             1
     flash_music_total_tbl             7
     flash_music_total                 2
     flash_long_change                 1
     alarm_flag                        1
     task_flash_music_display          4
     get_dirstart                     39
     ?Subroutine6                      9
     get_Flash_TotalFiles            135
     ?Subroutine2                      9
     get_dirtotal                      4
     task_flash_music_init            33
     task_flash_music_direct          75
     task_flash_music_sel_mode        52
     ?Subroutine7                      9
     task_flash_music_new             49
     ?Subroutine1                      7
     task_flash_music_auto_next       18
     task_flash_music_deal_msg       511
     ?Subroutine4                     13
     ?Subroutine0                      8
     ?Subroutine3                     13
     task_flash_music_event          246
     ?Subroutine5                     17
     last_pos                          4
     task_flash_music_enter          398
     task_flash_music_exit           101
     task_flash_music                 46
     ?<Constant "dir_start:%d\n">     14
     ?<Constant "cur num:%d\n">       12
     ?<Constant "SINGLE Loop\n">      13
     ?<Constant "No Device!">         11
     ?<Constant " on">                 4
     ?<Constant "Total:%d\n">         10
     ?<Constant "Break %ld, %ld\n">   16
     ?<Constant "device_chg = %d\n">
                                      17
     ?<Constant "task flash exit\n">
                                      17
     ?<Constant "task_flash\n">       12
     __Constant_0                      4
     __Constant_400                    4
     __Constant_800                    4
     _A_IE0                            1

 
   138 bytes in segment CODE_C
     2 bytes in segment SFR_AN
     7 bytes in segment TASK_FLASH_CONST
 1 721 bytes in segment TASK_FLASH_SEG
    75 bytes in segment TASK_MUSIC_SEG
     8 bytes in segment XDATA_Z
 
 1 929 bytes of CODE  memory (+ 12 bytes shared)
     0 bytes of DATA  memory (+  2 bytes shared)
     8 bytes of XDATA memory

Errors: none
Warnings: none
