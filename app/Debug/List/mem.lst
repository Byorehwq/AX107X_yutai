##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   29/Jun/2018  19:55:09 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  near                                              #
#    Data model         =  large                                             #
#    Calling convention =  extended stack reentrant                          #
#    Constant location  =  code                                              #
#    Extended stack     =  enabled                                           #
#    Dptr setup         =  1,16                                              #
#    Source file        =  I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\mem\mem.c       #
#    Command line       =  -I E:\software\8051\INC\ -I                       #
#                          E:\software\8051\INC\CLIB\ -I                     #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\COMMON\ -I      #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\INC\ -I         #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\config\ -I      #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\api\ -I         #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\fm\ -I          #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\fat\ -I         #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\display\ -I     #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\display\theme_d #
#                          efault\ -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073 #
#                          A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\disp #
#                          lay\led\ -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC07 #
#                          3A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\dis #
#                          play\lcd\ -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC0 #
#                          73A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\ta #
#                          sk\ -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇 #
#                          泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\user\    #
#                          -I I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_A #
#                          X1071_xxxxxxxx_20180629_Merlin_1\app\mem\ -I      #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\module\ -I      #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\key\ -I         #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\startmusic\ -I  #
#                          I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\spi\ -D         #
#                          AX107X_TAG -lC I:\a_wangqun\宇泰_睡眠仪_KNP08\18B #
#                          C073A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\ #
#                          Debug\List\ -o I:\a_wangqun\宇泰_睡眠仪_KNP08\18B #
#                          C073A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\ #
#                          Debug\Obj\ -e -z9 --core=plain --dptr=16,1        #
#                          --data_model=large --code_model=near              #
#                          --calling_convention=ext_stack_reentrant          #
#                          --place_constants=code --nr_virtual_regs 20       #
#                          --extended_stack I:\a_wangqun\宇泰_睡眠仪_KNP08\1 #
#                          8BC073A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\ap #
#                          p\mem\mem.c                                       #
#    List file          =  I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\Debug\List\mem. #
#                          lst                                               #
#    Object file        =  I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX10 #
#                          71_xxxxxxxx_20180629_Merlin_1\app\Debug\Obj\mem.r #
#                          51                                                #
#                                                                            #
#                                                                            #
##############################################################################

I:\a_wangqun\宇泰_睡眠仪_KNP08\18BC073A_宇泰_AX1071_xxxxxxxx_20180629_Merlin_1\app\mem\mem.c
      1          /*****************************************************************************
      2           * Module    : mem
      3           * File      : mem.c
      4           * Author    :
      5           * Email     :
      6           * Function  : 记忆任务流程
      7           *****************************************************************************/
      8          #include "include.h"
      9          #include "mem_rtcram.h"
     10          #include "mem_internal.h"
     11          #include "mem_eeprom.h"
     12          #include "mem_device.h"
     13          

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
     14          type_mem_ctl mem_ctl;
   \                     mem_ctl:
   \   000000                DS 4
     15          
     16          
     17          #pragma location="MEM"

   \                                 In segment MEM, align 1, keep-with-next
     18          void mem_event(void)
   \                     mem_event:
     19          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     20          	if(mem_ctl.delay_time == 1)
   \   000000   90....       MOV     DPTR,#(mem_ctl + 2)
   \   000003   E0           MOVX    A,@DPTR
   \   000004   6401         XRL     A,#0x1
   \   000006   7010         JNZ     ??mem_event_0
     21          	{
     22          		//延时到
     23          		mem_ctl.delay_time = 0;
   \   000008   E4           CLR     A
   \   000009   F0           MOVX    @DPTR,A
     24          
     25          #if (SYS_MEM == MEM_RTCRAM)
     26          		rtcram_write_sys_info();
   \   00000A   90....       MOV     DPTR,#(mem_ctl + 1)
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   A2E1         MOV     C,0xE0 /* A   */.1
   \   000010   5006         JNC     ??mem_event_0
   \   000012   C2E1         CLR     0xE0 /* A   */.1
   \   000014   F0           MOVX    @DPTR,A
   \   000015                ; Setup parameters for call to function write_volume_rtcram
   \   000015   12....       LCALL   write_volume_rtcram
     27          
     28          #elif (SYS_MEM == MEM_INTERNAL)
     29          		internal_write_sys_info();
     30          
     31          #elif (SYS_MEM == MEM_E2PROM)
     32          		eep_write_sys_info();
     33          
     34          #elif (SYS_MEM == MEM_DEVICE)
     35          		dev_write_info();
     36          #endif
     37          	}
     38          
     39          #if (SYS_MEM == MEM_INTERNAL)
     40          #if USE_BREAK_POINT
     41          	if(task_ctl.work_sta == TASK_MUSIC)
     42          	{
     43          		if(mem_ctl.erase_time == 1)
     44          		{
     45          			mem_ctl.erase_time = 0;
     46          			if(mem_ctl.erase_sta == NEED_RE_ERASE)
     47          			{
     48          				mem_ctl.erase_sta = BEING_ERASE;
     49          			}
     50          		}
     51          
     52          		erase_music_break_internal();
     53          	}
     54          	else
     55          	{
     56          		mem_ctl.erase_time = 0;
     57          	}
     58          #endif
     59          #endif
     60          
     61          	mem_ctl.dev = fs_cur_dev();
   \                     ??mem_event_0:
   \   000018                ; Setup parameters for call to function fs_cur_dev
   \   000018   12....       LCALL   fs_cur_dev
   \   00001B   E9           MOV     A,R1
   \   00001C   90....       MOV     DPTR,#mem_ctl
   \   00001F   F0           MOVX    @DPTR,A
     62          }
   \   000020   22           RET
     63          
     64          #if ((SYS_MEM == MEM_RTCRAM) || (SYS_MEM == MEM_INTERNAL))
     65          #pragma location="MEM"

   \                                 In segment MEM, align 1, keep-with-next
     66          void var_set_default(void)
   \                     var_set_default:
     67          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     68          	sys_ctl.volume = VOLUME_MAX/2+9;;		// Merlin 2015/06/06
   \   000000   7422         MOV     A,#0x22
   \   000002   90....       MOV     DPTR,#(sys_ctl + 2)
   \   000005   F0           MOVX    @DPTR,A
     69          	sys_ctl.dev_save = DEVICE_SDMMC;	// Merlin 2015/06/29 外卡优先,因为系统规格无切换设备功能
   \   000006   E4           CLR     A
   \   000007   90....       MOV     DPTR,#(sys_ctl + 7)
   \   00000A   F0           MOVX    @DPTR,A
     70          
     71          #if USE_BREAK_POINT
     72          	u_msc.music_num = 0;
   \   00000B   90....       MOV     DPTR,#u_msc
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
     73          	mem_ctl.dev = 1; task_music_break_save(0); write_num_rtcram();
   \   000011   7401         MOV     A,#0x1
   \   000013   12....       LCALL   ?Subroutine0
     74          	mem_ctl.dev = 0; task_music_break_save(0); write_num_rtcram();
   \                     ??CrossCallReturnLabel_0:
   \   000016   E4           CLR     A
   \   000017   12....       LCALL   ?Subroutine0
     75          	
     76          #endif
     77          
     78          #if TASK_FM_EN
     79          	fm_ctl.ch_total = 1;
     80          	fm_ctl.ch_cur = 1;
     81          	fm_ctl.fm_freq = FM_MIN_FREQ;
     82          	mem_fmbuf_clr();
     83          	fm_ctl.ch_buf[0] = 0x01;
     84          #if ((SYS_MEM == MEM_RTCRAM) || (SYS_MEM == MEM_E2PROM))
     85          	write_fm_info(0);
     86          #endif
     87          #endif
     88          
     89          #if (SYS_MEM == MEM_RTCRAM)    //第一次上电初始化RTCRAM
     90          	write_volume_rtcram();
   \                     ??CrossCallReturnLabel_1:
   \   00001A                ; Setup parameters for call to function write_volume_rtcram
   \   00001A   12....       LCALL   write_volume_rtcram
     91          	write_device_rtcram();
   \   00001D                ; Setup parameters for call to function write_device_rtcram
   \   00001D   12....       LCALL   write_device_rtcram
     92          	sys_ctl.mode_play = ITEM_LOOP_SINGLE; //上电播放模式为单曲循环
   \   000020   7402         MOV     A,#0x2
   \   000022   90....       MOV     DPTR,#sys_ctl
   \   000025   F0           MOVX    @DPTR,A
     93          	write_playmode_rtcram();
   \   000026                ; Setup parameters for call to function write_playmode_rtcram
   \   000026   12....       LCALL   write_playmode_rtcram
     94          #if TASK_FM_EN
     95          	write_total_channel_rtcram();
     96          	write_cur_channel_rtcram();
     97          #endif
     98          #endif
     99          
    100          
    101          }
   \   000029   22           RET

   \                                 In segment MEM, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   90....       MOV     DPTR,#mem_ctl
   \   000003   F0           MOVX    @DPTR,A
   \   000004                ; Setup parameters for call to function task_music_break_save
   \   000004                ; Setup parameters for call to function task_music_break_save
   \   000004   C2F0         CLR     B.0
   \   000006   12....       LCALL   task_music_break_save
   \   000009                ; Setup parameters for call to function write_num_rtcram
   \   000009                ; Setup parameters for call to function write_num_rtcram
   \   000009   12....       LCALL   write_num_rtcram
   \   00000C   22           RET
    102          #endif
    103          
    104          #pragma location="MEM"

   \                                 In segment MEM, align 1, keep-with-next
    105          void mem_read_init_info(void)
   \                     mem_read_init_info:
    106          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    107          #if (SYS_MEM == MEM_RTCRAM)
    108          	if(!(rtcram_poweron_check()))
   \   000000                ; Setup parameters for call to function rtcram_poweron_check
   \   000000   12....       LCALL   rtcram_poweron_check
   \   000003   5021         JNC     ??mem_read_init_info_0
    109          	{
    110          		return;
    111          	}
    112          
    113          	read_volume_rtcram();
   \   000005                ; Setup parameters for call to function read_volume_rtcram
   \   000005   12....       LCALL   read_volume_rtcram
    114          
    115          #if 0	// 强制以外卡为优先, 无设备记忆功能
    116          	read_device_rtcram();
    117          #else
    118          	sys_ctl.dev_save = DEVICE_SDMMC;	// Merlin 2015/06/29 外卡优先,因为系统规格无切换设备功能
   \   000008   E4           CLR     A
   \   000009   90....       MOV     DPTR,#(sys_ctl + 7)
   \   00000C   F0           MOVX    @DPTR,A
    119          #endif
    120          
    121          #if TASK_FM_EN
    122          	read_fm_info_rtcram();
    123          #endif
    124          
    125          #elif (SYS_MEM == MEM_INTERNAL)
    126          	if(!(internal_poweron_check()))  //出错，使用默认值
    127          	{
    128          		var_set_default();
    129          		return;
    130          	}
    131          
    132          	read_volume_internal();
    133          	read_device_internal();
    134          #if TASK_FM_EN
    135          	read_fm_info_internal();
    136          #endif
    137          
    138          #elif (SYS_MEM == MEM_E2PROM)
    139          	read_volume_eeprom();
    140          	read_device_eeprom();
    141          #if TASK_FM_EN
    142          	read_fm_info_eeprom();
    143          #endif
    144          
    145          #elif (SYS_MEM == MEM_DEVICE)
    146          	device_mount();
    147          	dev_read_info();
    148          #endif
    149          #if 0
    150          #if 1	// 音量只使用固定的级数, 不做调整
    151          	sys_ctl.volume = VOLUME_MAX;	// Merlin 2015/06/06
    152          #else
    153          	if(sys_ctl.volume > VOLUME_MAX)
    154          	{
    155          		sys_ctl.volume = VOLUME_MAX;
    156          	}
    157          	else if(sys_ctl.volume < 5)
    158          	{
    159          		sys_ctl.volume = 10;
    160          	}
    161          #endif
    162          #endif
    163          	if(sys_ctl.dev_save >= MEDIA_DEVICE_NUM)
    164          	{
    165          		sys_ctl.dev_save = DEVICE_INVALID;
    166          	}
    167          
    168          	// 2015/06/29 增加循环模式的记忆功能
    169          	rtcram_read_multi(RTCRAM_PLAY_MODE,(u8 *)&sys_ctl.mode_play, 1);	// 读出循环模式, ONE/ALL
   \   00000D                ; Setup parameters for call to function rtcram_read_multi
   \   00000D   7C01         MOV     R4,#0x1
   \   00000F   7A..         MOV     R2,#(sys_ctl & 0xff)
   \   000011   7B..         MOV     R3,#((sys_ctl >> 8) & 0xff)
   \   000013   7922         MOV     R1,#0x22
   \   000015   12....       LCALL   rtcram_read_multi
    170          
    171          	if((sys_ctl.mode_play != ITEM_LOOP_SINGLE) && (sys_ctl.mode_play != ITEM_LOOP_ALL))
   \   000018   90....       MOV     DPTR,#sys_ctl
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   6402         XRL     A,#0x2
   \   00001E   6006         JZ      ??mem_read_init_info_0
   \   000020   E0           MOVX    A,@DPTR
   \   000021   6003         JZ      ??mem_read_init_info_0
    172          	{
    173          		sys_ctl.mode_play = ITEM_LOOP_SINGLE;
   \   000023   7402         MOV     A,#0x2
   \   000025   F0           MOVX    @DPTR,A
   \                     ??mem_read_init_info_0:
   \   000026   22           RET
    174          	}
    175          
    176          #if TASK_FM_EN
    177          	if(fm_ctl.fm_freq > (FM_MAX_FREQ - FM_MIN_FREQ))
    178          	{
    179          		fm_ctl.fm_freq = FM_MIN_FREQ;
    180          	}
    181          	else
    182          	{
    183          		fm_ctl.fm_freq += FM_MIN_FREQ;
    184          	}
    185          
    186          	if(fm_ctl.ch_cur > fm_ctl.ch_total || fm_ctl.ch_cur == 0 || fm_ctl.ch_total > 26*8 /*|| fm_ctl.ch_total == 0 多余判断*/)
    187          	{
    188          		fm_ctl.ch_cur = 1;
    189          		fm_ctl.ch_total = 1;
    190          	}
    191          #endif
    192          }
    193          
    194          #if (SYS_MEM == MEM_INTERNAL)
    195          #pragma inline=forced
    196          #pragma location="MEM"
    197          void internal_write_sys_info(void)
    198          {
    199          	if(mem_ctl.change_flag & BIT(MEM_NUM_BIT))
    200          	{
    201          		mem_ctl.change_flag &= ~BIT(MEM_NUM_BIT);
    202          		write_num_internal();
    203          	}
    204          	if((mem_ctl.change_flag & BIT(MEM_VOL_BIT))
    205          	        ||(mem_ctl.change_flag & BIT(MEM_DEV_BIT)))
    206          	{
    207          		mem_ctl.change_flag &= ~(BIT(MEM_VOL_BIT) | BIT(MEM_DEV_BIT));
    208          		write_volume_device_internal();
    209          	}
    210          #if TASK_FM_EN
    211          	if(mem_ctl.change_flag & BIT(MEM_FRE_BIT))
    212          	{
    213          		mem_ctl.change_flag &= ~BIT(MEM_FRE_BIT);
    214          		write_cur_channel_internal();
    215          	}
    216          #endif
    217          }
    218          #endif
    219          
    220          #if (SYS_MEM == MEM_E2PROM)
    221          #pragma inline=forced
    222          #pragma location="MEM"
    223          void eep_write_sys_info(void)
    224          {
    225          	if(mem_ctl.change_flag & BIT(MEM_VOL_BIT))
    226          	{
    227          		mem_ctl.change_flag &= ~BIT(MEM_VOL_BIT);
    228          		write_volume_eeprom();
    229          	}
    230          }
    231          #endif
    232          
    233          #if (SYS_MEM == MEM_RTCRAM)
    234          #pragma inline=forced
    235          #pragma location="MEM"
    236          void rtcram_write_sys_info(void)
    237          {
    238          	if(mem_ctl.change_flag & BIT(MEM_VOL_BIT))
    239          	{
    240          		mem_ctl.change_flag &= ~BIT(MEM_VOL_BIT);
    241          		write_volume_rtcram();
    242          	}
    243          }
    244          #endif
    245          	
    246          #pragma location="MEM"

   \                                 In segment MEM, align 1, keep-with-next
    247          void mem_write_file_change(void)
   \                     mem_write_file_change:
    248          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    249          #if (SYS_MEM == MEM_RTCRAM)
    250          	write_num_rtcram();                           //切换文件成功后立即写曲目
   \   000000                ; Setup parameters for call to function write_num_rtcram
   \   000000   12....       LCALL   write_num_rtcram
    251          
    252          #elif (SYS_MEM == MEM_INTERNAL)
    253          	mem_ctl.delay_time = MEM_DELAY;               //internal，延时记忆
    254          	mem_ctl.change_flag |= BIT(MEM_NUM_BIT);
    255          
    256          #elif (SYS_MEM == MEM_E2PROM)
    257          	write_num_eeprom();                           //切换文件成功后立即写曲目
    258          
    259          #elif (SYS_MEM == MEM_DEVICE)
    260          	mem_ctl.delay_time = 0;
    261          	dev_write_info();                             //U/SD存储，切文件时记忆
    262          #endif
    263          }
   \   000003   22           RET
    264          
    265          #pragma location="MEM"

   \                                 In segment MEM, align 1, keep-with-next
    266          void mem_read_music_num(void)
   \                     mem_read_music_num:
    267          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    268          #if (SYS_MEM == MEM_RTCRAM)
    269          	read_num_rtcram();
   \   000000                ; Setup parameters for call to function read_num_rtcram
   \   000000   12....       LCALL   read_num_rtcram
    270          
    271          #elif (SYS_MEM == MEM_INTERNAL)
    272          	read_num_internal();
    273          
    274          #elif (SYS_MEM == MEM_E2PROM)
    275          	read_num_eeprom();
    276          
    277          #elif (SYS_MEM == MEM_DEVICE)
    278          	dev_read_music_num();
    279          #endif
    280          
    281          	if((u_msc.music_num == 0) || (u_msc.music_num > (u_msc.music_total - 1)))
   \   000003   90....       MOV     DPTR,#u_msc
   \   000006   E0           MOVX    A,@DPTR
   \   000007   7002         JNZ     ??mem_read_music_num_0
   \   000009   A3           INC     DPTR
   \   00000A   E0           MOVX    A,@DPTR
   \                     ??mem_read_music_num_0:
   \   00000B   601B         JZ      ??mem_read_music_num_1
   \   00000D   90....       MOV     DPTR,#(u_msc + 4)
   \   000010   E0           MOVX    A,@DPTR
   \   000011   24FF         ADD     A,#-0x1
   \   000013   FA           MOV     R2,A
   \   000014   A3           INC     DPTR
   \   000015   E0           MOVX    A,@DPTR
   \   000016   34FF         ADDC    A,#-0x1
   \   000018   FB           MOV     R3,A
   \   000019   90....       MOV     DPTR,#u_msc
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   F8           MOV     R0,A
   \   00001E   A3           INC     DPTR
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   F9           MOV     R1,A
   \   000021   C3           CLR     C
   \   000022   EA           MOV     A,R2
   \   000023   98           SUBB    A,R0
   \   000024   EB           MOV     A,R3
   \   000025   99           SUBB    A,R1
   \   000026   5009         JNC     ??mem_read_music_num_2
    282          	{
    283          		u_msc.music_num = 1;
   \                     ??mem_read_music_num_1:
   \   000028   90....       MOV     DPTR,#u_msc
   \   00002B   7401         MOV     A,#0x1
   \   00002D   F0           MOVX    @DPTR,A
   \   00002E   A3           INC     DPTR
   \   00002F   E4           CLR     A
   \   000030   F0           MOVX    @DPTR,A
    284          	}
    285          }
   \                     ??mem_read_music_num_2:
   \   000031   22           RET
    286          
    287          #pragma location="MEM"

   \                                 In segment MEM, align 1, keep-with-next
    288          void mem_write_device(void)
   \                     mem_write_device:
    289          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    290          
    291          	if(task_ctl.work_sta == TASK_FLASH)
   \   000000   7406         MOV     A,#0x6
   \   000002   65..         XRL     A,task_ctl
   \   000004   7004         JNZ     ??mem_write_device_0
    292          	{
    293          		sys_ctl.dev_save = DEVICE_SDMMC1;
   \   000006   7401         MOV     A,#0x1
   \   000008   8004         SJMP    ??mem_write_device_1
    294          	}
    295          	else
    296          	{
    297          		sys_ctl.dev_save = t_fat.dev_sel;
   \                     ??mem_write_device_0:
   \   00000A   90....       MOV     DPTR,#(t_fat + 25)
   \   00000D   E0           MOVX    A,@DPTR
   \                     ??mem_write_device_1:
   \   00000E   90....       MOV     DPTR,#(sys_ctl + 7)
   \   000011   F0           MOVX    @DPTR,A
    298          	}
    299          
    300          #if (SYS_MEM == MEM_RTCRAM)
    301          	write_device_rtcram();
   \   000012                ; Setup parameters for call to function write_device_rtcram
   \   000012   12....       LCALL   write_device_rtcram
    302          
    303          #elif (SYS_MEM == MEM_INTERNAL)
    304          	mem_ctl.delay_time = MEM_DELAY;               //internal，延时记忆
    305          	mem_ctl.change_flag |= BIT(MEM_DEV_BIT);
    306          
    307          #elif (SYS_MEM == MEM_E2PROM)
    308          	write_device_eeprom();
    309          #endif
    310          }
   \   000015   22           RET
    311          
    312          #if TASK_FM_EN
    313          //写入总台数、当前电台序号、当前频率
    314          #pragma location="MEM"
    315          void mem_write_channel(void)
    316          {
    317          #if (SYS_MEM == MEM_RTCRAM)
    318          	write_total_channel_rtcram();
    319          	write_cur_channel_rtcram();
    320          
    321          #elif (SYS_MEM == MEM_INTERNAL)
    322          	write_total_channel_internal();
    323          	write_cur_channel_internal();
    324          
    325          #elif (SYS_MEM == MEM_E2PROM)
    326          	write_total_channel_eeprom();
    327          	write_cur_channel_eeprom();
    328          
    329          #elif (SYS_MEM == MEM_DEVICE)
    330          	mem_ctl.delay_time = 1;
    331          
    332          #endif
    333          }
    334          
    335          //写入FM当前电台序号和频率
    336          void mem_write_cur_channel(void)
    337          {
    338          #if (SYS_MEM == MEM_RTCRAM)
    339          	write_cur_channel_rtcram();
    340          
    341          #elif (SYS_MEM == MEM_INTERNAL)
    342          	mem_ctl.delay_time = MEM_DELAY;               //internal，延时记忆
    343          	mem_ctl.change_flag |= BIT(MEM_FRE_BIT);
    344          
    345          #elif (SYS_MEM == MEM_E2PROM)
    346          	write_cur_channel_eeprom();
    347          
    348          #elif (SYS_MEM == MEM_DEVICE)
    349          	mem_ctl.delay_time = MEM_DELAY;
    350          
    351          #endif
    352          }
    353          
    354          //写入FM自动搜台信息
    355          #pragma location="MEM"
    356          void mem_write_fm(void)
    357          {
    358          #if FM_SEEK_50K_STEP
    359          	u16 byte_idx;
    360          	u8 bit_idx;
    361          	byte_idx = (fm_ctl.fm_freq - FM_MIN_FREQ)/5;
    362          	bit_idx = byte_idx % 8;
    363          	byte_idx = byte_idx / 8;
    364          
    365          #else
    366          	u8 byte_idx, bit_idx;
    367          	bit_idx = (u8)(fm_ctl.fm_freq - FM_MIN_FREQ);
    368          
    369          	byte_idx = bit_idx / 8;
    370          	bit_idx = bit_idx % 8;
    371          #endif
    372          	if(fm_ctl.fm_freq <= FM_MAX_FREQ)
    373          	{
    374          		fm_ctl.ch_buf[byte_idx] |= (1<<bit_idx);
    375          	}
    376          	//printf("ch_buf[%d] = %02x\n",byte_idx,fm_ctl.ch_buf[byte_idx]);
    377          
    378          	write_fm_info(byte_idx);
    379          }
    380          
    381          //清除记忆模块（由于内置记忆模块的擦写时间长，不在这里做）
    382          #pragma location="MEM"
    383          void mem_fmbuf_clr(void)
    384          {
    385          	memset(fm_ctl.ch_buf,0x00,CH_BUF_MAX);
    386          #if ((SYS_MEM == MEM_RTCRAM) || (SYS_MEM == MEM_E2PROM))
    387          	for(u8 i = 0; i < CH_BUF_MAX; i++)
    388          	{
    389          		write_fm_info(i);
    390          	}
    391          #endif
    392          }
    393          #endif
    394          
    395          #pragma location="MEM"

   \                                 In segment MEM, align 1, keep-with-next
    396          void mem_time_set(void)
   \                     mem_time_set:
    397          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    398          	if(mem_ctl.delay_time > 1)
   \   000000   90....       MOV     DPTR,#(mem_ctl + 2)
   \   000003   E0           MOVX    A,@DPTR
   \   000004   C3           CLR     C
   \   000005   9402         SUBB    A,#0x2
   \   000007   4003         JC      ??mem_time_set_0
    399          	{
    400          		mem_ctl.delay_time--;
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   14           DEC     A
   \   00000B   F0           MOVX    @DPTR,A
    401          	}
    402          
    403          #if ((SYS_MEM == MEM_INTERNAL) && USE_BREAK_POINT)
    404          	if((mem_ctl.erase_time > 1) && (mem_ctl.erase_sta == NEED_RE_ERASE))
    405          	{
    406          		mem_ctl.erase_time--;
    407          	}
    408          #endif
    409          }
   \                     ??mem_time_set_0:
   \   00000C   22           RET

   Maximum stack usage in bytes:

     Function                   EXT_STACK PSTACK XSTACK
     --------                   --------- ------ ------
     mem_event                         0      0      0
       -> write_volume_rtcram          0      0      0
       -> fs_cur_dev                   0      0      0
     mem_read_init_info                0      0      0
       -> rtcram_poweron_check         0      0      0
       -> read_volume_rtcram           0      0      0
       -> rtcram_read_multi            0      0      0
     mem_read_music_num                0      0      0
       -> read_num_rtcram              0      0      0
     mem_time_set                      0      0      0
     mem_write_device                  0      0      0
       -> write_device_rtcram          0      0      0
     mem_write_file_change             0      0      0
       -> write_num_rtcram             0      0      0
     var_set_default                   0      0      0
       -> task_music_break_save        0      0      0
       -> write_num_rtcram             0      0      0
       -> task_music_break_save        0      0      0
       -> write_num_rtcram             0      0      0
       -> write_volume_rtcram          0      0      0
       -> write_device_rtcram          0      0      0
       -> write_playmode_rtcram        0      0      0


   Segment part sizes:

     Function/Label        Bytes
     --------------        -----
     mem_ctl                  4
     mem_event               33
     var_set_default         42
     ?Subroutine0            13
     mem_read_init_info      39
     mem_write_file_change    4
     mem_read_music_num      50
     mem_write_device        22
     mem_time_set            13

 
 216 bytes in segment MEM
   4 bytes in segment XDATA_Z
 
 216 bytes of CODE  memory
   4 bytes of XDATA memory

Errors: none
Warnings: none
