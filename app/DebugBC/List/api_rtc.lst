##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   27/Jun/2018  22:48:35 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  near                                              #
#    Data model         =  large                                             #
#    Calling convention =  extended stack reentrant                          #
#    Constant location  =  code                                              #
#    Extended stack     =  enabled                                           #
#    Dptr setup         =  1,16                                              #
#    Source file        =  rtc/api_rtc.c                                     #
#    Command line       =  -f option_c51.cfg (-ICOMMON\ -IINC\ -Iconfig\     #
#                          -Iapi\ -Ifm\ -Ifat\ -Idisplay\                    #
#                          -Idisplay\theme_default\ -Idisplay\led\           #
#                          -Idisplay\lcd\ -Itask\ -Iuser\ -Imem\ -Imodule\   #
#                          -Ikey\ -Istartmusic\ -Ispi\ -e -z9 --core=plain   #
#                          --dptr=16,1 --data_model=large --code_model=near  #
#                          --calling_convention=ext_stack_reentrant          #
#                          --place_constants=code --nr_virtual_regs 20       #
#                          --extended_stack) -DAX207X_TAG --debug -lC        #
#                          DebugBC/List -o DebugBC/Obj/api_rtc.r51           #
#                          rtc/api_rtc.c                                     #
#    List file          =  DebugBC/List/api_rtc.lst                          #
#    Object file        =  DebugBC/Obj/api_rtc.r51                           #
#                                                                            #
#                                                                            #
##############################################################################

R:\18BC073A_宇泰_AX1071_xxxxxxxx_20180627\app\rtc\api_rtc.c
      1          #include "include.h"

   \                                 In segment SFR_AN, at 0x8b
   \   unsigned char volatile __sfr MEMCON
   \                     MEMCON:
   \   000000                DS 1
      2          
      3          
      4          #if TASK_RTC_EN
      5          
      6          
      7          TIME __idata t_time;
      8          
      9          #pragma constseg="RTC_TBL"
     10          IAR_CONST u32 month[12] =
     11          {
     12          	0,
     13          	DAY *(31),
     14          	DAY *(31+29),
     15          	DAY *(31+29+31),
     16          	DAY *(31+29+31+30),
     17          	DAY *(31+29+31+30+31),
     18          	DAY *(31+29+31+30+31+30),
     19          	DAY *(31+29+31+30+31+30+31),
     20          	DAY *(31+29+31+30+31+30+31+31),
     21          	DAY *(31+29+31+30+31+30+31+31+30),
     22          	DAY *(31+29+31+30+31+30+31+31+30+31),
     23          	DAY *(31+29+31+30+31+30+31+31+30+31+30)
     24          };
     25          #pragma constseg=default
     26          
     27          
     28          #if RTC_DATE_EN
     29          //把每秒累计的count 转换成年月日
     30          void sec2date(TIME __idata *t, u32 second) AT(RTC_SEG_API);
     31          void sec2date(TIME __idata *t, u32 second)
     32          {
     33          	sec2time(t, second);
     34          
     35          	t->year = t->base_year;                       /* 基本年 */
     36          	while(1)
     37          	{
     38          		if(((t->year % 4 == 0) && (t->year % 100 != 0)) || (t->year % 400 == 0))  /* 闰年处理 */
     39          		{
     40          			if(second >= (YEAR + DAY))
     41          			{
     42          				second -= (YEAR + DAY);
     43          				t->year++;
     44          			}
     45          			else
     46          				break;
     47          		}
     48          
     49          		else                                         /* 平年处理 */
     50          			if(second >= YEAR)
     51          			{
     52          				second -= YEAR;
     53          				t->year++;
     54          			}
     55          			else
     56          				break;
     57          	}
     58          	t->month = 12;
     59          	while(1)
     60          	{
     61          		if(((t->year % 4 == 0) && (t->year % 100 != 0)) || (t->year % 400 == 0))
     62          		{
     63          			if(second >= month[t->month - 1])
     64          			{
     65          				second -=  month[t->month - 1];
     66          				break;
     67          			}
     68          			else
     69          				t->month--;
     70          		}
     71          		else
     72          		{
     73          			if(t->month > 2)
     74          			{
     75          				if(second >= (month[t->month - 1] - DAY))
     76          				{
     77          					second -= (month[t->month - 1] - DAY);
     78          					break;
     79          				}
     80          				else
     81          					t->month--;
     82          			}
     83          			else
     84          			{
     85          				if(second >=month[t->month - 1])
     86          				{
     87          					second -= month[t->month - 1];
     88          					break;
     89          				}
     90          				else
     91          					t->month--;
     92          			}
     93          		}
     94          	}
     95          	t->day = (second / DAY + 1);
     96          }
     97          
     98          //输入年月日,输出秒数,返回以秒累计的数值
     99          u32 date2sec(TIME __idata *t) AT(RTC_SEG_API);
    100          u32 date2sec(TIME __idata *t)
    101          {
    102          	u32 res;                            /* 总秒数 */
    103          	u8 year,month_tp;
    104          	month_tp = t->month;              /* 取结构体的月数 */
    105          	month_tp--;                        /* 减去当前月 */
    106          	year = t->year;
    107          	year -= t->base_year;             /* 减去年的初始值 */
    108          	res = YEAR*year + DAY*((year+3)/4); /* 计算年的总分钟数(包括闰月) */
    109          	res += month[month_tp];            /* 增加当年的月的大概分钟数 */
    110          	if(month_tp>1 && ((year)%4))       /* 细调当年闰月的天数 */
    111          		res -= DAY;
    112          	res += DAY*(t->day-1);
    113          	res += time2sec(t);
    114          	return res;
    115          }
    116          #endif
    117          
    118          //调整分
    119          #pragma location="RTC_SEG_API"
    120          void deal_minute(bool flag)
    121          {
    122          	u8 tmp = t_time.minute;
    123          
    124          	if(flag)
    125          	{
    126          		if(tmp < 59)
    127          		{
    128          			tmp++;
    129          		}
    130          		else
    131          		{
    132          			tmp = 0;
    133          		}
    134          	}
    135          	else
    136          	{
    137          		if(tmp > 0)
    138          		{
    139          			tmp--;
    140          		}
    141          		else
    142          		{
    143          			tmp = 59;
    144          		}
    145          	}
    146          
    147          	t_time.minute = tmp;
    148          }
    149          
    150          
    151          //调整时
    152          #pragma location="RTC_SEG_API"
    153          void deal_hour(bool flag)
    154          {
    155          	u8 tmp = t_time.hour;
    156          
    157          	if(flag)
    158          	{
    159          		if(tmp < 23)
    160          		{
    161          			tmp++;
    162          		}
    163          		else
    164          		{
    165          			tmp = 0;
    166          		}
    167          	}
    168          	else
    169          	{
    170          		if(tmp > 0)
    171          		{
    172          			tmp--;
    173          		}
    174          		else
    175          		{
    176          			tmp = 23;
    177          		}
    178          	}
    179          	t_time.hour = tmp;
    180          }
    181          #endif
    182          
    183          #if (TASK_RTC_EN || (SYS_MEM == MEM_RTCRAM))
    184          //RTC初始化
    185          void irtc_init(void) AT(RTC_INIT);

   \                                 In segment RTC_INIT, align 1, keep-with-next
    186          void irtc_init(void)
   \                     irtc_init:
    187          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    188          	SELECT_IROM2();
   \   000000   538BEF       ANL     0x8b,#0xef
   \   000003   438B01       ORL     0x8b,#0x1
    189          
    190          	u8 rtccon_val = irtc_read_cmd(CFG_RD);
   \   000006                ; Setup parameters for call to function irtc_read_cmd
   \   000006   7954         MOV     R1,#0x54
   \   000008   12....       LCALL   irtc_read_cmd
   \   00000B   E9           MOV     A,R1
   \   00000C   FA           MOV     R2,A
    191          	if(sys_ctl.irtc_poweron)
   \   00000D   90....       MOV     DPTR,#(sys_ctl + 10)
   \   000010   E0           MOVX    A,@DPTR
   \   000011   600D         JZ      ??irtc_init_0
    192          	{
    193          #if (SYS_CRY == CRY_32K)
    194          		rtccon_val |= BIT(7);   //xosc 32k enable
    195          #endif
    196          #if (CRY_PIN_NUM == CRY_1PIN)
    197          		rtccon_val |= BIT(5);   //xosc
    198          #endif
    199          		rtccon_val |= BIT(3) | BIT(2);
    200          		//bit4-PDFLAG:RTCC timer is working
    201          		//bit3-F1HZEN:1Hz signal output enable
    202          		//bit2-F32KHZEN:32KHz signal output enable
    203          		irtc_write_cmd(CFG_WR, rtccon_val);
   \   000013                ; Setup parameters for call to function irtc_write_cmd
   \   000013   740C         MOV     A,#0xc
   \   000015   4A           ORL     A,R2
   \   000016   FA           MOV     R2,A
   \   000017   7955         MOV     R1,#0x55
   \   000019   12....       LCALL   irtc_write_cmd
    204          
    205          #if (SYS_MEM == MEM_RTCRAM)
    206          		mem_ctl.rtcram_poweron = 1;            //上电，记忆恢复成默认值
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??irtc_init_1
    207          #endif
    208          
    209          #if TASK_RTC_EN
    210          		t_time.second = 1;
    211          		t_time.minute = 0;
    212          		t_time.hour = 0;
    213          #if RTC_DATE_EN
    214          		t_time.day = 1;
    215          		t_time.month = 1;
    216          		t_time.year = 2013;
    217          #endif
    218          		irtc_write_date(date2sec(&t_time));
    219          
    220          #if ALARM_EN
    221          		t_time.second = 0;
    222          		irtc_write_alarm(date2sec(&t_time));
    223          #endif
    224          #endif //TASK_RTC_EN
    225          	}
    226          	else
    227          	{
    228          #if (SYS_MEM == MEM_RTCRAM)
    229          		mem_ctl.rtcram_poweron = 0;
   \                     ??irtc_init_0:
   \   000020   E4           CLR     A
   \                     ??irtc_init_1:
   \   000021   90....       MOV     DPTR,#(mem_ctl + 3)
   \   000024   F0           MOVX    @DPTR,A
    230          #endif
    231          	}
    232          
    233          #if TASK_RTC_EN
    234          	IRTCON &= ~BIT(2);              //second interrupt disable
    235          #if ALARM_EN
    236          	IRTCON |= BIT(4);               //alarm interrupt enable
    237          #endif
    238          	IRTCON &= ~(BIT(3)|BIT(5));     //second & alarm pending clear
    239          
    240          #if ALARM_WAKEUP_EN
    241          	u8 wkocon_val = irtc_read_cmd(WKO_RD);
    242          	wkocon_val |= 0x98;       //WKO output high
    243          	wkocon_val &= ~(BIT(5) | BIT(0));
    244          	irtc_write_cmd(WKO_WR, wkocon_val);
    245          #endif
    246          
    247          #endif
    248          }
   \   000025   22           RET
    249          #endif

   Maximum stack usage in bytes:

     Function            EXT_STACK PSTACK XSTACK
     --------            --------- ------ ------
     irtc_init                  0      0      0
       -> irtc_read_cmd         0      0      0
       -> irtc_write_cmd        0      0      0


   Segment part sizes:

     Function/Label Bytes
     -------------- -----
     MEMCON            1
     irtc_init        38

 
 38 bytes in segment RTC_INIT
  1 byte  in segment SFR_AN
 
 38 bytes of CODE memory
  0 bytes of DATA memory (+ 1 byte shared)

Errors: none
Warnings: none
