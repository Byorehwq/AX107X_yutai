##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   10/Sep/2015  19:03:31 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  near                                              #
#    Data model         =  large                                             #
#    Calling convention =  extended stack reentrant                          #
#    Constant location  =  code                                              #
#    Extended stack     =  enabled                                           #
#    Dptr setup         =  1,16                                              #
#    Source file        =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\user\user_io.c                        #
#    Command line       =  -I "C:\Program Files\IAR Systems\Embedded         #
#                          Workbench 4.05 Evaluation version\8051\INC\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench  #
#                          4.05 Evaluation version\8051\INC\CLIB\" -I        #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\lil #
#                          y\15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX1 #
#                          070_20150908\COMMON\" -I "C:\Documents and        #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\INC\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\config\" -I "C:\Documents and    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\api\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\fm\" -I "C:\Documents and        #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\fat\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\display\" -I "C:\Documents and   #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\displ #
#                          ay\led\" -I "C:\Documents and                     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\displ #
#                          ay\lcd\" -I "C:\Documents and                     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\task\ #
#                          " -I "C:\Documents and Settings\Administrator\×ÀÃ #
#                          æ\lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lil #
#                          y_AX1070_20150908\user\" -I "C:\Documents and     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\mem\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\module\" -I "C:\Documents and    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\modul #
#                          e\kedir\" -I "C:\Documents and                    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\key\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\startmusic\" -D UART_DEBUG -D    #
#                          AX207X_TAG -lC "C:\Documents and                  #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\UART_ #
#                          Debug\List\" -o "C:\Documents and                 #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\UART_ #
#                          Debug\Obj\" -e -z9 --debug --core=plain           #
#                          --dptr=16,1 --data_model=large --code_model=near  #
#                          --calling_convention=ext_stack_reentrant          #
#                          --place_constants=code --nr_virtual_regs 20       #
#                          --extended_stack "C:\Documents and                #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\user\ #
#                          user_io.c"                                        #
#    List file          =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\UART_Debug\List\user_io.lst           #
#    Object file        =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\UART_Debug\Obj\user_io.r51            #
#                                                                            #
#                                                                            #
##############################################################################

C:\Documents and Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX1070_20150908\user\user_io.c
      1          /*****************************************************************************
      2           * Module    : User
      3           * File      : user_io.c
      4           * Author    : Hanny
      5           * Email     : coldney@yahoo.com.cn
      6           * Function  : ÓÃ»§µÄIOÉèÖÃ£¬Éè±¸¼ì²âµÈ
      7           *****************************************************************************/
      8          #include "include.h"

   \                                 In segment SFR_AN, at 0xb0
   \   unsigned char volatile __sfr P3
   \                     P3:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr P0DIR
   \                     P0DIR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr P1DIR
   \                     P1DIR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xbd
   \   unsigned char volatile __sfr P3DIR
   \                     P3DIR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr P4DIR
   \                     P4DIR:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xc0
   \   unsigned char volatile __sfr P4
   \                     P4:
   \   000000                DS 1
      9          #include "task.h"
     10          
     11          extern void sd_init(void);
     12          extern void usb_init(u8 host, u8 dev);
     13          extern void usb_init_dev_only(u8 host, u8 dev);
     14          extern void usb_init_std(u8 phy);
     15          extern void usb_init_dev_only_std(u8 phy);
     16          
     17          //IO³õÊ¼»¯
     18          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
     19          void port_init(void)
   \                     port_init:
     20          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     21          #if !USE_SD_CLK_DET
     22          	//SD¼ì²â½Å
     23          	SD_CHECK_DIR |= BIT(SD_CHECK_PIN);  //ÉèÎªÊäÈë
   \   000000   43BD01       ORL     0xbd,#0x1
     24          	SD_CHECK_PU |= BIT(SD_CHECK_PIN);   //ÉÏÀ­ÉèÖÃ
   \   000003   903013       MOV     DPTR,#0x3013
   \   000006   E0           MOVX    A,@DPTR
   \   000007   D2E0         SETB    0xE0 /* A   */.0
   \   000009   F0           MOVX    @DPTR,A
     25          #if SD_DOUBLE_EN
     26          	//SD¼ì²â½Å
     27          	SD1_CHECK_DIR |= BIT(SD1_CHECK_PIN);	//ÉèÎªÊäÈë
   \   00000A   43BD02       ORL     0xbd,#0x2
     28          	SD1_CHECK_PU |= BIT(SD1_CHECK_PIN);	//ÉÏÀ­ÉèÖÃ
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   D2E1         SETB    0xE0 /* A   */.1
   \   000010   F0           MOVX    @DPTR,A
     29          #endif
     30          #endif
     31          	sd_group_sel(DEVICE_SDMMC);
   \   000011                ; Setup parameters for call to function sd_group_sel
   \   000011   7900         MOV     R1,#0x0
   \   000013   12....       LCALL   sd_group_sel
     32          	sd_init();
   \   000016                ; Setup parameters for call to function sd_init
   \   000016   12....       LCALL   sd_init
     33          #if ((USB_HOST_PHY == USB_DEV_PHY) || (USB_DET != USBDET_OTG))
     34          #if (USB_DET == USBDET_DEV_ONLY)
     35          	usb_init_dev_only_std(USB_DEV_PHY);
     36          #else
     37          	usb_init_std(USB_HOST_PHY);
   \   000019                ; Setup parameters for call to function usb_init_std
   \   000019   7901         MOV     R1,#0x1
   \   00001B   12....       LCALL   usb_init_std
     38          #endif
     39          #else
     40          	usb_init(USB_HOST_PHY, USB_DEV_PHY);
     41          #endif
     42          
     43          #if (AUX_DET_EN && !USE_7P7S_LED_AUX_MUX)
     44          	//LineIn¼ì²â
     45          	AUX_CHECK_DIR |= BIT(AUX_CHECK_PIN);
     46          	AUX_CHECK_PU |= BIT(AUX_CHECK_PIN);
     47          #endif
     48          #if MIC_DET_EN
     49          	//Mic¼ì²â
     50          	MIC_CHECK_DIR |= BIT(MIC_CHECK_PIN);
     51          	MIC_CHECK_PU |= BIT(MIC_CHECK_PIN);
     52          #endif
     53          #if (HP_DET_EN && !USE_SDCLK_SDDET_PHONE_MUX && !USE_SDCMD_IICCLK_PHONE_MUX)
     54          	//¶ú»ú¼ì²â
     55          	HP_CHECK_DIR |= BIT(HP_CHECK_PIN);
     56          	HP_CHECK_PU |= BIT(HP_CHECK_PIN);
     57          #endif
     58          #if DCIN_DET_EN
     59          	//DC¼ì²â
     60          	DCIN_CHECK_DIR |= BIT(DCIN_CHECK_PIN);
     61          #endif
     62          
     63          #if (MUTE_TYPE != MUTE_NO)
     64          	MUTE_DIR &= ~BIT(MUTE_PIN);     //MUTE¿ØÖÆ£¬¿ªMUTE
   \   00001E   53BEEF       ANL     0xbe,#0xef
     65          	EN_MUTE();
   \   000021   D2C4         SETB    0xc0.4
     66          #endif
     67          
     68          #if PA_MODE_SEL_EN
     69          	PA_MODE_DIR &= ~BIT(PA_MODE_PIN);
     70          	PA_MODE_PORT &= ~BIT(PA_MODE_PIN);   //Ñ¡ÔñABÀà¹¦·Å
     71          #endif
     72          
     73          	RP_EN_INIT;
   \   000023   43BA08       ORL     0xba,#0x8
   \   000026   903010       MOV     DPTR,#0x3010
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   D2E3         SETB    0xE0 /* A   */.3
   \   00002C   F0           MOVX    @DPTR,A
     74          
     75          	KEY1_INIT;
   \   00002D   43BA01       ORL     0xba,#0x1
   \   000030   E0           MOVX    A,@DPTR
   \   000031   D2E0         SETB    0xE0 /* A   */.0
   \   000033   F0           MOVX    @DPTR,A
     76          	KEY2_INIT;
   \   000034   43BA02       ORL     0xba,#0x2
   \   000037   E0           MOVX    A,@DPTR
   \   000038   D2E1         SETB    0xE0 /* A   */.1
   \   00003A   F0           MOVX    @DPTR,A
     77          	KEY3_INIT;
   \   00003B   43BA04       ORL     0xba,#0x4
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   D2E2         SETB    0xE0 /* A   */.2
   \   000041   F0           MOVX    @DPTR,A
     78          #if TASK_FLASH_EN
     79          	spi_port_init();
   \   000042                ; Setup parameters for call to function spi_port_init
   \   000042   12....       LCALL   spi_port_init
     80          #endif
     81          }
   \   000045   22           RET
     82          
     83          #pragma location="SD_SEG"

   \                                 In segment SD_SEG, align 1, keep-with-next
     84          void sd_group_sel(u8 sd_group)
   \                     sd_group_sel:
     85          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     86          	if(sd_group == DEVICE_SDMMC)
   \   000000   E9           MOV     A,R1
   \   000001   7008         JNZ     ??sd_group_sel_0
     87          	{
     88          		SD_PORT_SEL();
   \   000003   903056       MOV     DPTR,#0x3056
   \   000006   E0           MOVX    A,@DPTR
   \   000007   543F         ANL     A,#0x3f
   \   000009   800F         SJMP    ??sd_group_sel_1
     89          	}
     90          	else if(sd_group == DEVICE_SDMMC1)
   \                     ??sd_group_sel_0:
   \   00000B   7401         MOV     A,#0x1
   \   00000D   69           XRL     A,R1
   \   00000E   700B         JNZ     ??sd_group_sel_2
     91          	{
     92          		SD1_PORT_SEL();
   \   000010   903056       MOV     DPTR,#0x3056
   \   000013   E0           MOVX    A,@DPTR
   \   000014   C2E7         CLR     0xE0 /* A   */.7
   \   000016   F0           MOVX    @DPTR,A
   \   000017   E0           MOVX    A,@DPTR
   \   000018   D2E6         SETB    0xE0 /* A   */.6
   \                     ??sd_group_sel_1:
   \   00001A   F0           MOVX    @DPTR,A
     93          	}
     94          	sd_chk.group = sd_group;
   \                     ??sd_group_sel_2:
   \   00001B   E9           MOV     A,R1
   \   00001C   90....       MOV     DPTR,#sd_chk
   \   00001F   F0           MOVX    @DPTR,A
     95          	//printf("sd group:%d\n",sd_chk.group);
     96          }
   \   000020   22           RET
     97          
     98          //SD PORT³õÊ¼»¯
     99          #if SD_DOUBLE_EN
    100          #pragma location="SD_SEG"

   \                                 In segment SD_SEG, align 1, keep-with-next
    101          void sd_port_init(u8 type)
   \                     sd_port_init:
    102          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    103          	SD_CMD_DIR |= BIT(SD_CMD_PIN);              //CMD
   \   000000   43BB80       ORL     0xbb,#0x80
    104          	SD_DAT0_DIR |= BIT(SD_DAT0_PIN);            //DAT0
   \   000003   43BB20       ORL     0xbb,#0x20
    105          	SD_DAT0_PU |= BIT(SD_DAT0_PIN);             //DAT0ÉÏÀ­
   \   000006   903011       MOV     DPTR,#0x3011
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   D2E5         SETB    0xE0 /* A   */.5
   \   00000C   F0           MOVX    @DPTR,A
    106          #if (USE_SDCMD_IICCLK_MIC_MUX || USE_SDCMD_IICCLK_PHONE_MUX)
    107          	SD_CMD_PU500R_EN();                         //CMD¿ªÉÏÀ­500R
    108          #else
    109          	SD_CMD_PU |= BIT(SD_CMD_PIN);               //CMDÉÏÀ­10K
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   D2E7         SETB    0xE0 /* A   */.7
   \   000010   F0           MOVX    @DPTR,A
    110          #endif
    111          
    112          	SD1_CMD_DIR |= BIT(SD1_CMD_PIN);            //SD1 CMD
   \   000011   43BB10       ORL     0xbb,#0x10
    113          	SD1_DAT0_DIR |= BIT(SD1_DAT0_PIN);          //SD1 DAT0
   \   000014   43BB04       ORL     0xbb,#0x4
    114          	SD1_DAT0_PU |= BIT(SD1_DAT0_PIN);           //SD1 DAT0ÉÏÀ­
   \   000017   E0           MOVX    A,@DPTR
   \   000018   D2E2         SETB    0xE0 /* A   */.2
   \   00001A   F0           MOVX    @DPTR,A
    115          	SD1_CMD_PU |= BIT(SD1_CMD_PIN);             //SD1 CMDÉÏÀ­10K
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   D2E4         SETB    0xE0 /* A   */.4
   \   00001E   F0           MOVX    @DPTR,A
    116          
    117          #if !USE_SD_CLK_DET
    118          	SD_CLK_DIR &= ~BIT(SD_CLK_PIN);             //CLKÊä³ö
   \   00001F   53BBBF       ANL     0xbb,#0xbf
    119          	SD1_CLK_DIR &= ~BIT(SD1_CLK_PIN);           //SD1 CLKÊä³ö
   \   000022   53BBF7       ANL     0xbb,#0xf7
    120          #else
    121          	if(sd_chk.group == DEVICE_SDMMC)
    122          	{
    123          		if((type == 1)
    124          #if (/*(!USE_SDCLK_SDDET_PHONE_MUX)&&*/(!USE_SDCMD_IICCLK_PHONE_MUX)&&(!USE_SDCMD_IICCLK_MIC_MUX))
    125          		        || (type == 3)
    126          #endif
    127          		  )
    128          		{
    129          			SD_CLK_PU &= ~BIT(SD_CLK_PIN);          //¹Ø±ÕÉÏÀ­
    130          			SD_CLK_DIR &= ~BIT(SD_CLK_PIN);         //CLKÓÃÓÚÊ±ÖÓÊä³ö
    131          		}
    132          		else
    133          		{
    134          			SD_CLK_DIR |= BIT(SD_CLK_PIN);          //CLKÓÃÓÚSD0¿¨¼ì²â
    135          #if !USE_SDCLK_SDDET_PHONE_MUX  //SD0 CLK¡¢SD¼ì²â¡¢¶ú»ú¼ì²â¸´ÓÃ£¬Ê¹ÓÃÍâ²¿10KÉÏÀ­µç×è
    136          			SD_CLK_PU |= BIT(SD_CLK_PIN);           //´ò¿ªÉÏÀ­
    137          #endif
    138          		}
    139          		SD1_CLK_DIR |= BIT(SD1_CLK_PIN);            //CLKÓÃÓÚSD1¿¨¼ì²â
    140          		SD1_CLK_PU |= BIT(SD1_CLK_PIN);             //´ò¿ªÉÏÀ­
    141          	}
    142          	else if(sd_chk.group == DEVICE_SDMMC1)
    143          	{
    144          		if((type == 1)
    145          #if (/*(!USE_SDCLK_SDDET_PHONE_MUX)&&*/(!USE_SDCMD_IICCLK_PHONE_MUX)&&(!USE_SDCMD_IICCLK_MIC_MUX))
    146          		        || (type == 3)
    147          #endif
    148          		  )
    149          		{
    150          			SD1_CLK_PU &= ~BIT(SD1_CLK_PIN);        //¹Ø±ÕÉÏÀ­
    151          			SD1_CLK_DIR &= ~BIT(SD1_CLK_PIN);       //CLKÓÃÓÚÊ±ÖÓÊä³ö
    152          		}
    153          		else
    154          		{
    155          			SD1_CLK_DIR |= BIT(SD1_CLK_PIN);        //CLKÓÃÓÚSD1¿¨¼ì²â
    156          			SD1_CLK_PU |= BIT(SD1_CLK_PIN);         //´ò¿ªÉÏÀ­
    157          		}
    158          		SD_CLK_DIR |= BIT(SD_CLK_PIN);              //CLKÓÃÓÚSD0¿¨¼ì²â
    159          #if !USE_SDCLK_SDDET_PHONE_MUX  //SD0 CLK¡¢SD¼ì²â¡¢¶ú»ú¼ì²â¸´ÓÃ£¬Ê¹ÓÃÍâ²¿10KÉÏÀ­µç×è
    160          		SD_CLK_PU |= BIT(SD_CLK_PIN);               //´ò¿ªÉÏÀ­
    161          #endif
    162          	}
    163          #endif
    164          }
   \   000025   22           RET
    165          
    166          #else
    167          //SD PORT³õÊ¼»¯
    168          #pragma location="SD_SEG"
    169          void sd_port_init(u8 type)
    170          {
    171          	SD_PORT_SEL();
    172          
    173          	SD_CMD_DIR |= BIT(SD_CMD_PIN);              //CMD
    174          	SD_DAT0_DIR |= BIT(SD_DAT0_PIN);            //DAT0
    175          	SD_DAT0_PU |= BIT(SD_DAT0_PIN);             //DAT0ÉÏÀ­
    176          #if (USE_SDCMD_IICCLK_MIC_MUX || USE_SDCMD_IICCLK_PHONE_MUX || USE_SDCMD_IICCLK_SDDET_MUX)
    177          	SD_CMD_PU500R_EN();                         //CMD¿ªÉÏÀ­500R
    178          #else
    179          	SD_CMD_PU |= BIT(SD_CMD_PIN);               //CMDÉÏÀ­10K
    180          #endif
    181          
    182          #if !USE_SD_CLK_DET
    183          	SD_CLK_DIR &= ~BIT(SD_CLK_PIN);             //CLKÊä³ö
    184          	SD1_CLK_DIR &= ~BIT(SD1_CLK_PIN);           //SD1 CLKÊä³ö
    185          #else
    186          	if((type == 1)
    187          #if (/*(!USE_SDCLK_SDDET_PHONE_MUX)&&*/(!USE_SDCMD_IICCLK_PHONE_MUX)&&(!USE_SDCMD_IICCLK_MIC_MUX)&&(!USE_SDCMD_IICCLK_SDDET_MUX))
    188          	        || (type == 3)
    189          #endif
    190          	  )
    191          	{
    192          		SD_CLK_PU &= ~BIT(SD_CLK_PIN);          //¹Ø±ÕÉÏÀ­
    193          		SD_CLK_DIR &= ~BIT(SD_CLK_PIN);         //CLKÓÃÓÚÊ±ÖÓÊä³ö
    194          	}
    195          	else
    196          	{
    197          		SD_CLK_DIR |= BIT(SD_CLK_PIN);          //CLKÓÃÓÚSD¿¨¼ì²â
    198          #if !USE_SDCLK_SDDET_PHONE_MUX  //SD CLK¡¢SD¼ì²â¡¢¶ú»ú¼ì²â¸´ÓÃ£¬Ê¹ÓÃÍâ²¿10KÉÏÀ­µç×è
    199          		SD_CLK_PU |= BIT(SD_CLK_PIN);           //´ò¿ªÉÏÀ­
    200          #endif
    201          	}
    202          #endif
    203          }
    204          #endif /*END SD_DOUBLE_EN*/
    205          
    206          //SD¼ì²â, Íâ½Ó SD¿¨
    207          #pragma location="SD_SEG"

   \                                 In segment SD_SEG, align 1, keep-with-next
    208          void sd_detect(void)
   \                     sd_detect:
    209          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    210          #if USE_SDCLK_SDDET_PHONE_MUX  //SD CLK¡¢SD¼ì²â¡¢¶ú»ú¼ì²â¸´ÓÃ£¬Ê¹ÓÃÍâ²¿10KÉÏÀ­µç×è
    211          	if(0 == (SD_CHECK_DIR & BIT(SD_CHECK_PIN)))
    212          	{
    213          		return;   //IOÊä³ö×´Ì¬
    214          	}
    215          
    216          	if((scan_ctl.sddect_val < 115)
    217          	        || ((scan_ctl.sddect_val > 145) && (scan_ctl.sddect_val < 190)))
    218          	{
    219          #else
    220          
    221          #if USE_SDCMD_IICCLK_SDDET_MUX
    222          	if(!(sd_port_sta()))
    223          	{
    224          		return;
    225          	}
    226          	SD_CMD_PU |= BIT(SD_CMD_PIN);           //CMD¿ªÉÏÀ­10K
    227          	SD_CMD_PU500R_DIS();                    //CMD¹ØÉÏÀ­500R
    228          	asm("nop");
    229          	asm("nop");
    230          	asm("nop");
    231          	asm("nop");
    232          	asm("nop");
    233          	asm("nop");
    234          	asm("nop");
    235          	asm("nop");
    236          #else
    237          	if(0 == (SD_CHECK_PU & BIT(SD_CHECK_PIN)))
   \   000000   903013       MOV     DPTR,#0x3013
   \   000003   E0           MOVX    A,@DPTR
   \   000004   A2E0         MOV     C,0xE0 /* A   */.0
   \   000006   502C         JNC     ??sd_detect_0
    238          	{
    239          		return;
    240          	}
    241          #endif
    242          	if(0==(SD_CHECK_PORT & BIT(SD_CHECK_PIN)))        //SD¿¨²åÈë¼ì²âIO»á±»À­µÍ
   \   000008   A2B0         MOV     C,0xb0.0
   \   00000A   7900         MOV     R1,#0x0
   \   00000C   4012         JC      ??sd_detect_1
    243          	{
    244          #endif
    245          		if(device_insert(DEVICE_SDMMC))
   \   00000E                ; Setup parameters for call to function device_insert
   \   00000E   12....       LCALL   device_insert
   \   000011   5021         JNC     ??sd_detect_0
    246          		{
    247          			b_sys.dev_change = 1;
   \   000013   D2..         SETB    b_sys.0
    248          			sd_insert();
   \   000015                ; Setup parameters for call to function sd_insert
   \   000015   12....       LCALL   sd_insert
    249          			printf("SD0 IN\n");
   \   000018                ; Setup parameters for call to function my_printf
   \   000018   7A..         MOV     R2,#(`?<Constant "SD0 IN\\n">` & 0xff)
   \   00001A   7B..         MOV     R3,#((`?<Constant "SD0 IN\\n">` >> 8) & 0xff)
   \   00001C   12....       LCALL   my_printf
   \   00001F   22           RET
    250          		}
    251          	}
    252          	else
    253          	{
    254          		if(device_remove(DEVICE_SDMMC))
   \                     ??sd_detect_1:
   \   000020                ; Setup parameters for call to function device_remove
   \   000020   12....       LCALL   device_remove
   \   000023   500F         JNC     ??sd_detect_0
    255          		{
    256          			if(fs_cur_dev() == DEVICE_SDMMC)
   \   000025                ; Setup parameters for call to function fs_cur_dev
   \   000025   12....       LCALL   fs_cur_dev
   \   000028   E9           MOV     A,R1
   \   000029   7002         JNZ     ??sd_detect_2
    257          			{
    258          				b_sys.dev_change = 1;
   \   00002B   D2..         SETB    b_sys.0
    259          			}
    260          			//sd_remove();
    261          			printf("SD0 OUT\n");
   \                     ??sd_detect_2:
   \   00002D                ; Setup parameters for call to function my_printf
   \   00002D   7A..         MOV     R2,#(`?<Constant "SD0 OUT\\n">` & 0xff)
   \   00002F   7B..         MOV     R3,#((`?<Constant "SD0 OUT\\n">` >> 8) & 0xff)
   \   000031   12....       LCALL   my_printf
   \                     ??sd_detect_0:
   \   000034   22           RET
    262          		}
    263          	}
    264          
    265          #if USE_SDCMD_IICCLK_SDDET_MUX
    266          	SD_CMD_PU &= ~BIT(SD_CMD_PIN);          //CMD¹ØÉÏÀ­10K
    267          	SD_CMD_PU500R_EN();                     //CMD¿ªÉÏÀ­500R
    268          #endif
    269          }
    270          
    271          // ÄÚ½Ó SD¿¨, Èç¹ûÊ¹ÓÃÄÚ½ÓSPI-FlashÊ±, ½«Í£ÓÃÄÚ½Ó SD¿¨µÄÕì²â

   \                                 In segment NEAR_CODE, align 1, keep-with-next
    272          void sd1_detect(void)
   \                     sd1_detect:
    273          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    274          	if(u_spi.spi_online)
   \   000000   90....       MOV     DPTR,#(u_spi + 1)
   \   000003   E0           MOVX    A,@DPTR
   \   000004   7036         JNZ     ??sd1_detect_0
    275          	{
    276          		return;
    277          	}
    278          	if(0 == (SD1_CHECK_PU & BIT(SD1_CHECK_PIN)))
   \   000006   903013       MOV     DPTR,#0x3013
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   A2E1         MOV     C,0xE0 /* A   */.1
   \   00000C   502E         JNC     ??sd1_detect_0
    279          	{
    280          		return;
    281          	}
    282          	if(!(SD1_CHECK_PORT & BIT(SD1_CHECK_PIN)))        //SD¿¨²åÈë¼ì²âIO»á±»À­µÍ
   \   00000E   A2B1         MOV     C,0xb0.1
   \   000010   7901         MOV     R1,#0x1
   \   000012   4012         JC      ??sd1_detect_1
    283          	{
    284          		if(device_insert(DEVICE_SDMMC1))
   \   000014                ; Setup parameters for call to function device_insert
   \   000014   12....       LCALL   device_insert
   \   000017   5023         JNC     ??sd1_detect_0
    285          		{
    286          			b_sys.dev_change = 1;
   \   000019   D2..         SETB    b_sys.0
    287          			sd_insert();
   \   00001B                ; Setup parameters for call to function sd_insert
   \   00001B   12....       LCALL   sd_insert
    288          			printf("SD1 IN\n");
   \   00001E                ; Setup parameters for call to function my_printf
   \   00001E   7A..         MOV     R2,#(`?<Constant "SD1 IN\\n">` & 0xff)
   \   000020   7B..         MOV     R3,#((`?<Constant "SD1 IN\\n">` >> 8) & 0xff)
   \   000022   12....       LCALL   my_printf
   \   000025   22           RET
    289          		}
    290          	}
    291          	else
    292          	{
    293          		if(device_remove(DEVICE_SDMMC1))
   \                     ??sd1_detect_1:
   \   000026                ; Setup parameters for call to function device_remove
   \   000026   12....       LCALL   device_remove
   \   000029   5011         JNC     ??sd1_detect_0
    294          		{
    295          			if(fs_cur_dev() == DEVICE_SDMMC1)
   \   00002B                ; Setup parameters for call to function fs_cur_dev
   \   00002B   12....       LCALL   fs_cur_dev
   \   00002E   E9           MOV     A,R1
   \   00002F   6401         XRL     A,#0x1
   \   000031   7002         JNZ     ??sd1_detect_2
    296          			{
    297          				b_sys.dev_change = 1;
   \   000033   D2..         SETB    b_sys.0
    298          			}
    299          			printf("SD1 OUT\n");
   \                     ??sd1_detect_2:
   \   000035                ; Setup parameters for call to function my_printf
   \   000035   7A..         MOV     R2,#(`?<Constant "SD1 OUT\\n">` & 0xff)
   \   000037   7B..         MOV     R3,#((`?<Constant "SD1 OUT\\n">` >> 8) & 0xff)
   \   000039   12....       LCALL   my_printf
   \                     ??sd1_detect_0:
   \   00003C   22           RET
    300          		}
    301          	}
    302          }
    303          
    304          //sddectµÄI/O×´Ì¬
    305          #pragma location="SD_SEG"

   \                                 In segment SD_SEG, align 1, keep-with-next
    306          bool sd_port_sta(void)
   \                     sd_port_sta:
    307          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    308          	if(0 == (SD_CHECK_DIR & BIT(SD_CHECK_PIN)))
   \   000000   E5BD         MOV     A,0xbd
   \   000002   A2E0         MOV     C,0xE0 /* A   */.0
   \   000004   4002         JC      ??sd_port_sta_0
    309          	{
    310          		return 0;   //IOÊä³ö×´Ì¬
   \   000006   C3           CLR     C
   \   000007   22           RET
    311          	}
    312          	else
    313          	{
    314          		return 1;   //IOÊäÈë×´Ì¬
   \                     ??sd_port_sta_0:
   \   000008   D3           SETB    C
   \   000009   22           RET
    315          	}
    316          }
    317          
    318          //USB¼ì²âº¯Êý
    319          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    320          void usb_detect(void)
   \                     usb_detect:
    321          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    322          #if UDISK_DOUBLE_EN
    323          	asm("push 0xdc");//USBCON1
    324          	u8 usb_conn;
    325          	for(u8 i = 0; i < 2; i++)        //¼ì²âPHY0,PHY1ÉÏµÄÖ÷´ÓÉè±¸
    326          	{
    327          		usb_conn = usb_connected(i);
    328          #if (!UDISK_DOUBLE_EN)
    329          		if(USB_HOST_PHY == i)       //µ¥UDISK¹¦ÄÜ
    330          #endif
    331          		{
    332          			if(USB_CONNECTED_UDISK == usb_conn)
    333          			{
    334          				if(device_insert(DEVICE_UDISK + i))
    335          				{
    336          					b_sys.dev_change = 1;
    337          					printf("UDISK[%d] IN\n",i);
    338          				}
    339          			}
    340          			else
    341          			{
    342          				if(device_remove(DEVICE_UDISK + i))
    343          				{
    344          					if(fs_cur_dev() == DEVICE_UDISK+i)
    345          					{
    346          						b_sys.dev_change = 1;
    347          					}
    348          					printf("UDISK[%d] OUT\n",i);
    349          				}
    350          			}
    351          		}
    352          
    353          #if TASK_USBDEV_EN
    354          		if(USB_DEV_PHY == i)                    //Ö¸¶¨Ò»×é×÷ÎªDEVICE
    355          		{
    356          			//printf("usb_conn:%d  ",usb_conn);
    357          			if(USB_CONNECTED_PC == usb_conn)
    358          			{
    359          				if(device_insert(DEVICE_PC))
    360          				{
    361          					printf("PC IN\n");
    362          				}
    363          			}
    364          			else
    365          			{
    366          				if(device_remove(DEVICE_PC))
    367          				{
    368          					printf("PC OUT\n");
    369          				}
    370          			}
    371          		}
    372          #endif
    373          	}
    374          
    375          
    376          	asm("pop 0xdc");
    377          #else
    378          #if ((USB_HOST_PHY == USB_DEV_PHY) || (USB_DET != USBDET_OTG))
    379          	asm("push 0xdc");//USBCON1
   \   000000   C0DC         push 0xdc
    380          	u8 usb_conn = usb_connected(USB_HOST_PHY);
    381          
    382          #if (USB_DET != USBDET_DEV_ONLY)
    383          	if(USB_CONNECTED_UDISK == usb_conn)
   \   000002                ; Setup parameters for call to function usb_connected
   \   000002   7901         MOV     R1,#0x1
   \   000004   12....       LCALL   usb_connected
   \   000007   E9           MOV     A,R1
   \   000008   6402         XRL     A,#0x2
   \   00000A   7902         MOV     R1,#0x2
   \   00000C   700D         JNZ     ??usb_detect_0
    384          	{
    385          		if(device_insert(DEVICE_UDISK))
   \   00000E                ; Setup parameters for call to function device_insert
   \   00000E   12....       LCALL   device_insert
   \   000011   501E         JNC     ??usb_detect_1
    386          		{
    387          			b_sys.dev_change = 1;
   \   000013   D2..         SETB    b_sys.0
    388          			printf("UDISK IN\n");
   \   000015                ; Setup parameters for call to function my_printf
   \   000015   7A..         MOV     R2,#(`?<Constant "UDISK IN\\n">` & 0xff)
   \   000017   7B..         MOV     R3,#((`?<Constant "UDISK IN\\n">` >> 8) & 0xff)
   \   000019   8013         SJMP    ??usb_detect_2
    389          		}
    390          	}
    391          	else
    392          	{
    393          		if(device_remove(DEVICE_UDISK))
   \                     ??usb_detect_0:
   \   00001B                ; Setup parameters for call to function device_remove
   \   00001B   12....       LCALL   device_remove
   \   00001E   5011         JNC     ??usb_detect_1
    394          		{
    395          			if(fs_cur_dev() == DEVICE_UDISK)
   \   000020                ; Setup parameters for call to function fs_cur_dev
   \   000020   12....       LCALL   fs_cur_dev
   \   000023   E9           MOV     A,R1
   \   000024   6402         XRL     A,#0x2
   \   000026   7002         JNZ     ??usb_detect_3
    396          			{
    397          				b_sys.dev_change = 1;
   \   000028   D2..         SETB    b_sys.0
    398          			}
    399          			printf("UDISK OUT\n");
   \                     ??usb_detect_3:
   \   00002A                ; Setup parameters for call to function my_printf
   \   00002A   7A..         MOV     R2,#(`?<Constant "UDISK OUT\\n">` & 0xff)
   \   00002C   7B..         MOV     R3,#((`?<Constant "UDISK OUT\\n">` >> 8) & 0xff)
   \                     ??usb_detect_2:
   \   00002E   12....       LCALL   my_printf
    400          		}
    401          	}
    402          #endif
    403          #if TASK_USBDEV_EN
    404          	if(USB_CONNECTED_PC == usb_conn)
    405          	{
    406          		if(device_insert(DEVICE_PC))
    407          		{
    408          			printf("PC IN\n");
    409          		}
    410          	}
    411          	else
    412          	{
    413          		if(device_remove(DEVICE_PC))
    414          		{
    415          			printf("PC OUT\n");
    416          		}
    417          	}
    418          #endif
    419          #else
    420          	//USB DEVICEÓëHOSTÓÃµÄPHY²»Í¬
    421          	u8 usb_conn = usb_connected(USB_DEV_PHY);
    422          #if TASK_USBDEV_EN
    423          	if(USB_CONNECTED_PC == usb_conn)
    424          	{
    425          		if(device_insert(DEVICE_PC))
    426          		{
    427          			printf("PC IN\n");
    428          		}
    429          	}
    430          	else
    431          	{
    432          		if(device_remove(DEVICE_PC))
    433          		{
    434          			printf("PC OUT\n");
    435          		}
    436          	}
    437          #endif
    438          	usb_conn = usb_connected(USB_HOST_PHY);
    439          	if(USB_CONNECTED_UDISK == usb_conn)
    440          	{
    441          		if(device_insert(DEVICE_UDISK))
    442          		{
    443          			b_sys.dev_change = 1;
    444          			printf("UDISK IN\n");
    445          		}
    446          	}
    447          	else
    448          	{
    449          		if(device_remove(DEVICE_UDISK))
    450          		{
    451          			if(fs_cur_dev() == DEVICE_UDISK)
    452          			{
    453          				b_sys.dev_change = 1;
    454          			}
    455          			printf("UDISK OUT\n");
    456          		}
    457          	}
    458          #endif
    459          	asm("pop 0xdc");
   \                     ??usb_detect_1:
   \   000031   D0DC         pop 0xdc
    460          #endif
    461          }
   \   000033   22           RET
    462          
    463          #if AUX_DET_EN
    464          //LineIn¼ì²âº¯Êý
    465          #pragma location="USER_IO_SEG"
    466          void aux_detect(void)
    467          {
    468          	if(!(AUX_CHECK_PORT & BIT(AUX_CHECK_PIN)))
    469          	{
    470          		if(device_insert(DEVICE_LINEIN))
    471          		{
    472          			//printf("AUX IN\n");
    473          		}
    474          	}
    475          	else
    476          	{
    477          		if(device_remove(DEVICE_LINEIN))
    478          		{
    479          			//printf("AUX OUT\n");
    480          		}
    481          	}
    482          }
    483          #endif
    484          
    485          #if MIC_DET_EN
    486          //Mic¼ì²âº¯Êý
    487          #pragma location="USER_IO_SEG"
    488          void mic_detect(void)
    489          {
    490          #if USE_SDCMD_IICCLK_MIC_MUX
    491          	if(!(sd_port_sta()))
    492          	{
    493          		return;
    494          	}
    495          	SD_CMD_PU |= BIT(SD_CMD_PIN);           //CMD¿ªÉÏÀ­10K
    496          	SD_CMD_PU500R_DIS();                    //CMD¹ØÉÏÀ­500R
    497          	asm("nop");
    498          	asm("nop");
    499          	asm("nop");
    500          	asm("nop");
    501          	asm("nop");
    502          	asm("nop");
    503          	asm("nop");
    504          	asm("nop");
    505          
    506          #else
    507          	if((0 == (MIC_CHECK_PU & BIT(MIC_CHECK_PIN)))
    508          	        || (0 == (MIC_CHECK_DIR & BIT(MIC_CHECK_PIN))))
    509          	{
    510          		return;
    511          	}
    512          #endif
    513          
    514          	if(!(MIC_CHECK_PORT & BIT(MIC_CHECK_PIN)))
    515          	{
    516          		if(device_insert(DEVICE_MIC))
    517          		{
    518          			//printf("MIC IN\n");
    519          		}
    520          	}
    521          	else
    522          	{
    523          		if(device_remove(DEVICE_MIC))
    524          		{
    525          			//printf("MIC OUT\n");
    526          		}
    527          	}
    528          
    529          #if USE_SDCMD_IICCLK_MIC_MUX
    530          	SD_CMD_PU &= ~BIT(SD_CMD_PIN);          //CMD¹ØÉÏÀ­10K
    531          	SD_CMD_PU500R_EN();                     //CMD¿ªÉÏÀ­500R
    532          #endif
    533          }
    534          #endif
    535          
    536          #if HP_DET_EN
    537          //Headphone¼ì²âº¯Êý
    538          #pragma location="USER_IO_SEG"
    539          void headphone_detect(void)
    540          {
    541          #if USE_SDCLK_SDDET_PHONE_MUX               //SD CLK¡¢SD¼ì²â¡¢¶ú»ú¼ì²â¸´ÓÃ
    542          	if(0 == (SD_CHECK_DIR & BIT(SD_CHECK_PIN)))
    543          	{
    544          		return;   //IOÊä³ö×´Ì¬
    545          	}
    546          
    547          	if(scan_ctl.sddect_val < 145)
    548          
    549          #elif DAC_BUF_EN             //Ê¹ÓÃVCM BUFÊ±ADC¼ì²â£¬¿ªÄÚ²¿ÉÏÀ­10K
    550          	if(scan_ctl.hpdect_val < 200)
    551          
    552          #else
    553          #if USE_SDCMD_IICCLK_PHONE_MUX              //¸´ÓÃSDCMD/IICCLK½øÐÐ¶ú»ú¼ì²â
    554          	if(!(sd_port_sta()))
    555          	{
    556          		return;
    557          	}
    558          	SD_CMD_PU |= BIT(SD_CMD_PIN);           //CMD¿ªÉÏÀ­10K
    559          	SD_CMD_PU500R_DIS();                    //CMD¹ØÉÏÀ­500R
    560          	asm("nop");
    561          	asm("nop");
    562          	asm("nop");
    563          	asm("nop");
    564          	asm("nop");
    565          	asm("nop");
    566          	asm("nop");
    567          	asm("nop");
    568          #endif
    569          	if(!(HP_CHECK_PORT & BIT(HP_CHECK_PIN)))
    570          #endif
    571          	{
    572          		if(device_insert(DEVICE_HP))
    573          		{
    574          			printf("HP IN\n");
    575          		}
    576          		mute_enable();
    577          	}
    578          	else
    579          	{
    580          		if(device_remove(DEVICE_HP))
    581          		{
    582          			printf("HP OUT\n");
    583          			mute_disable();
    584          		}
    585          	}
    586          
    587          #if USE_SDCMD_IICCLK_PHONE_MUX
    588          	SD_CMD_PU &= ~BIT(SD_CMD_PIN);          //CMD¹ØÉÏÀ­10K
    589          	SD_CMD_PU500R_EN();                     //CMD¿ªÉÏÀ­500R
    590          #endif
    591          
    592          #if 0
    593          #if (MUTE_TYPE != MUTE_NO)
    594          	if(device_is_online(DEVICE_HP))
    595          	{
    596          		MUTE_EN();
    597          	}
    598          	else if(device_remove(DEVICE_HP))
    599          	{
    600          		if((!b_dac.mute_en)
    601          #if DAC_POWER_SPEED
    602          		        && (dac_init_ctl.sta == DAC_INIT_END)
    603          #endif
    604          		  )
    605          		{
    606          			UN_MUTE();
    607          		}
    608          	}
    609          #endif
    610          #endif
    611          }
    612          #endif
    613          
    614          #if DCIN_DET_EN
    615          //dcin¼ì²âº¯Êý
    616          #pragma location="USER_IO_SEG"
    617          void dcin_detect(void)
    618          {
    619          	static u8 cnt_in = 0,cnt_out = 0;
    620          	if((DCIN_CHECK_PORT & BIT(DCIN_CHECK_PIN)))
    621          	{
    622          		cnt_out = 0;
    623          		if(cnt_in < 20)
    624          		{
    625          			cnt_in++;
    626          			poweroff_ctl.dc_in_sta = DC_UNSTABLE;
    627          		}
    628          		else if(cnt_in == 20)
    629          		{
    630          			cnt_in = 30;
    631          			poweroff_ctl.dc_in_sta = DC_IN;
    632          			printf("dc in...\n");
    633          		}
    634          	}
    635          	else
    636          	{
    637          		cnt_in = 0;
    638          		if(cnt_out < 20)
    639          		{
    640          			cnt_out++;
    641          			poweroff_ctl.dc_in_sta = DC_UNSTABLE;
    642          		}
    643          		else if(cnt_out == 20)
    644          		{
    645          			cnt_out = 30;
    646          			poweroff_ctl.dc_in_sta = DC_OUT;
    647          			printf("dc out...\n");
    648          		}
    649          	}
    650          }
    651          #endif
    652          
    653          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    654          void mute_init(void)
   \                     mute_init:
    655          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    656          	MUTE_PORT_OUTPUT;
   \   000000   53BEEF       ANL     0xbe,#0xef
    657          	MUTE_PORT_LOW;
   \   000003   C2C4         CLR     0xc0.4
    658          }
   \   000005   22           RET
    659          
    660          
    661          //¿ªMUTEº¯Êý, Í£Ö¹ÉùÒôÊä³ö
    662          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    663          void MUTE_EN(void)
   \                     MUTE_EN:
    664          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    665          #if (MUTE_TYPE != MUTE_NO)
    666          	EN_MUTE();
   \   000000   D2C4         SETB    0xc0.4
    667          #endif
    668          	//printf("mute\n");
    669          }
   \   000002   22           RET
    670          
    671          
    672          //¹ØMUTEº¯Êý, Êä³öÉùÒô
    673          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    674          void UN_MUTE(void)
   \                     UN_MUTE:
    675          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    676          #if (MUTE_TYPE != MUTE_NO)
    677          	DIS_MUTE();
   \   000000   C2C4         CLR     0xc0.4
    678          #endif
    679          	//printf("mute\n");
    680          }
   \   000002   22           RET
    681          
    682          //¿ªMUTEº¯Êý, Í£Ö¹ÉùÒôÊä³ö
    683          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    684          void mute_enable(void)
   \                     mute_enable:
    685          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    686          	if(!b_dac.mute_en)
   \   000000   A2..         MOV     C,b_dac.1
   \   000002   4008         JC      ??mute_enable_0
    687          	{
    688          		b_dac.mute_en = 1;
   \   000004   D2..         SETB    b_dac.1
    689          		mute_status_change = true;
   \   000006   7401         MOV     A,#0x1
   \   000008   90....       MOV     DPTR,#mute_status_change
   \   00000B   F0           MOVX    @DPTR,A
    690          	}
    691          #if 0
    692          #if (MUTE_TYPE != MUTE_NO)
    693          	//EN_MUTE();
    694          	MUTE_PORT_LOW;
    695          #endif
    696          #endif
    697          	//printf("mute\n");
    698          }
   \                     ??mute_enable_0:
   \   00000C   22           RET
    699          
    700          
    701          //¹ØMUTEº¯Êý, ÈÃÉùÒô³öÀ´
    702          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    703          void mute_disable(void)
   \                     mute_disable:
    704          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    705          	if(b_dac.mute_en)
   \   000000   A2..         MOV     C,b_dac.1
   \   000002   5008         JNC     ??mute_disable_0
    706          	{
    707          		b_dac.mute_en = 0;
   \   000004   C2..         CLR     b_dac.1
    708          		mute_status_change = true;
   \   000006   7401         MOV     A,#0x1
   \   000008   90....       MOV     DPTR,#mute_status_change
   \   00000B   F0           MOVX    @DPTR,A
    709          	}
    710          #if 0
    711          #if (MUTE_TYPE != MUTE_NO)
    712          	DIS_MUTE();
    713          #endif
    714          #endif
    715          	//printf("unmute\n");
    716          }
   \                     ??mute_disable_0:
   \   00000C   22           RET
    717          
    718          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    719          void mute_ctl_auto(void)
   \                     mute_ctl_auto:
    720          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    721          	if(mute_status_change)
   \   000000   90....       MOV     DPTR,#mute_status_change
   \   000003   E0           MOVX    A,@DPTR
   \   000004   600C         JZ      ??mute_ctl_auto_0
    722          	{
    723          		if(b_dac.mute_en)
   \   000006   A2..         MOV     C,b_dac.1
   \   000008   5004         JNC     ??mute_ctl_auto_1
    724          		{
    725          			MUTE_EN();
   \   00000A   D2C4         SETB    0xc0.4
   \   00000C   8002         SJMP    ??mute_ctl_auto_2
    726          		}
    727          		else
    728          		{
    729          			UN_MUTE();
   \                     ??mute_ctl_auto_1:
   \   00000E   C2C4         CLR     0xc0.4
    730          		}
    731          		mute_status_change = false;
   \                     ??mute_ctl_auto_2:
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
    732          	}
    733          }
   \                     ??mute_ctl_auto_0:
   \   000012   22           RET
    734          
    735          
    736          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    737          void io_output_clk_start(void)
   \                     io_output_clk_start:
    738          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    739          #if (FM_CLOCK == USE_IO_32KHZ_CLK)
    740          	CLKCON2 &= ~BIT(7);      //RTCC clock source select XOSC
    741          	//CLKCON2 |= BIT(7);       //RTCC clock source select RC32K
    742          	CLKCON3 |= BIT(6);       //output clk 32.768KHz
    743          
    744          #elif (FM_CLOCK == USE_IO_12MHZ_CLK)
    745          	CLKCON3 &= ~(BIT(7) | BIT(6));
    746          #endif
    747          
    748          	AIPCON8 &= ~(BIT(2) | BIT(1) | BIT(0));
   \   000000   903058       MOV     DPTR,#0x3058
   \   000003   E0           MOVX    A,@DPTR
   \   000004   54F8         ANL     A,#0xf8
   \   000006   F0           MOVX    @DPTR,A
    749          	AIPCON8 |= FM_CLK_IO;
   \   000007   E0           MOVX    A,@DPTR
   \   000008   4406         ORL     A,#0x6
   \   00000A   F0           MOVX    @DPTR,A
    750          
    751          #if (FM_CLK_IO == CLK_P16)
    752          	P1DIR &= ~BIT(6);
    753          #elif (FM_CLK_IO == CLK_P15)
    754          	P1DIR &= ~BIT(5);
    755          #elif (FM_CLK_IO == CLK_P06)
    756          	P0DIR &= ~BIT(6);
    757          #elif (FM_CLK_IO == CLK_P32)
    758          	P3DIR &= ~BIT(2);
    759          #elif (FM_CLK_IO == CLK_P33)
    760          	P3DIR &= ~BIT(3);
    761          #elif (FM_CLK_IO == CLK_P34)
    762          	P3DIR &= ~BIT(4);
   \   00000B   53BDEF       ANL     0xbd,#0xef
    763          #elif (FM_CLK_IO == CLK_P35)
    764          	P3DIR &= ~BIT(5);
    765          #else
    766          #error "ÇëÑ¡ÔñÌá¹©Ê±ÖÓµÄIO"
    767          #endif
    768          }
   \   00000E   22           RET
    769          
    770          #pragma location="USER_IO_SEG"

   \                                 In segment USER_IO_SEG, align 1, keep-with-next
    771          void io_output_clk_stop(void)
   \                     io_output_clk_stop:
    772          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    773          #if (FM_CLK_IO == CLK_P16)
    774          	P1DIR |= BIT(6);
    775          #elif (FM_CLK_IO == CLK_P15)
    776          	P1DIR |= BIT(5);
    777          #elif (FM_CLK_IO == CLK_P06)
    778          	P0DIR |= BIT(6);
    779          #elif (FM_CLK_IO == CLK_P32)
    780          	P3DIR |= BIT(2);
    781          #elif (FM_CLK_IO == CLK_P33)
    782          	P3DIR |= BIT(3);
    783          #elif (FM_CLK_IO == CLK_P34)
    784          	P3DIR |= BIT(4);
   \   000000   43BD10       ORL     0xbd,#0x10
    785          #elif (FM_CLK_IO == CLK_P35)
    786          	P3DIR |= BIT(5);
    787          #endif
    788          }
   \   000003   22           RET

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "SD0 IN\\n">`:
   \   000000   53443020     DB "SD0 IN\012"
   \            494E0A00

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "SD0 OUT\\n">`:
   \   000000   53443020     DB "SD0 OUT\012"
   \            4F55540A
   \            00      

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "SD1 IN\\n">`:
   \   000000   53443120     DB "SD1 IN\012"
   \            494E0A00

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "SD1 OUT\\n">`:
   \   000000   53443120     DB "SD1 OUT\012"
   \            4F55540A
   \            00      

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "UDISK IN\\n">`:
   \   000000   55444953     DB "UDISK IN\012"
   \            4B20494E
   \            0A00    

   \                                 In segment CODE_C, align 1
   \                     `?<Constant "UDISK OUT\\n">`:
   \   000000   55444953     DB "UDISK OUT\012"
   \            4B204F55
   \            540A00  

   Maximum stack usage in bytes:

     Function            EXT_STACK PSTACK XSTACK
     --------            --------- ------ ------
     MUTE_EN                    0      0      0
     UN_MUTE                    0      0      0
     io_output_clk_start        0      0      0
     io_output_clk_stop         0      0      0
     mute_ctl_auto              0      0      0
     mute_disable               0      0      0
     mute_enable                0      0      0
     mute_init                  0      0      0
     port_init                  0      0      0
       -> sd_group_sel          0      0      0
       -> sd_init               0      0      0
       -> usb_init_std          0      0      0
       -> spi_port_init         0      0      0
     sd1_detect                 0      0      0
       -> device_insert         0      0      0
       -> sd_insert             0      0      0
       -> my_printf             0      0      0
       -> device_remove         0      0      0
       -> fs_cur_dev            0      0      0
       -> my_printf             0      0      0
     sd_detect                  0      0      0
       -> device_insert         0      0      0
       -> sd_insert             0      0      0
       -> my_printf             0      0      0
       -> device_remove         0      0      0
       -> fs_cur_dev            0      0      0
       -> my_printf             0      0      0
     sd_group_sel               0      0      0
     sd_port_init               0      0      0
     sd_port_sta                0      0      0
     usb_detect                 0      0      0
       -> usb_connected         0      0      0
       -> device_insert         0      0      0
       -> my_printf             0      0      0
       -> device_remove         0      0      0
       -> fs_cur_dev            0      0      0
       -> my_printf             0      0      0


   Segment part sizes:

     Function/Label            Bytes
     --------------            -----
     P3                           1
     P0DIR                        1
     P1DIR                        1
     P3DIR                        1
     P4DIR                        1
     P4                           1
     port_init                   70
     sd_group_sel                33
     sd_port_init                38
     sd_detect                   53
     sd1_detect                  61
     sd_port_sta                 10
     usb_detect                  52
     mute_init                    6
     MUTE_EN                      3
     UN_MUTE                      3
     mute_enable                 13
     mute_disable                13
     mute_ctl_auto               19
     io_output_clk_start         15
     io_output_clk_stop           4
     ?<Constant "SD0 IN\n">       8
     ?<Constant "SD0 OUT\n">      9
     ?<Constant "SD1 IN\n">       8
     ?<Constant "SD1 OUT\n">      9
     ?<Constant "UDISK IN\n">    10
     ?<Constant "UDISK OUT\n">   11

 
  55 bytes in segment CODE_C
  61 bytes in segment NEAR_CODE
 134 bytes in segment SD_SEG
   6 bytes in segment SFR_AN
 198 bytes in segment USER_IO_SEG
 
 448 bytes of CODE memory
   0 bytes of DATA memory (+ 6 bytes shared)

Errors: none
Warnings: none
