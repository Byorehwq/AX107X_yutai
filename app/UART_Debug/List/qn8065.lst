##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   10/Sep/2015  19:03:29 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  near                                              #
#    Data model         =  large                                             #
#    Calling convention =  extended stack reentrant                          #
#    Constant location  =  code                                              #
#    Extended stack     =  enabled                                           #
#    Dptr setup         =  1,16                                              #
#    Source file        =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\fm\qn8065.c                           #
#    Command line       =  -I "C:\Program Files\IAR Systems\Embedded         #
#                          Workbench 4.05 Evaluation version\8051\INC\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench  #
#                          4.05 Evaluation version\8051\INC\CLIB\" -I        #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\lil #
#                          y\15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX1 #
#                          070_20150908\COMMON\" -I "C:\Documents and        #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\INC\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\config\" -I "C:\Documents and    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\api\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\fm\" -I "C:\Documents and        #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\fat\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\display\" -I "C:\Documents and   #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\displ #
#                          ay\led\" -I "C:\Documents and                     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\displ #
#                          ay\lcd\" -I "C:\Documents and                     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\task\ #
#                          " -I "C:\Documents and Settings\Administrator\×ÀÃ #
#                          æ\lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lil #
#                          y_AX1070_20150908\user\" -I "C:\Documents and     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\mem\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\module\" -I "C:\Documents and    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\modul #
#                          e\kedir\" -I "C:\Documents and                    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\key\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\startmusic\" -D UART_DEBUG -D    #
#                          AX207X_TAG -lC "C:\Documents and                  #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\UART_ #
#                          Debug\List\" -o "C:\Documents and                 #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\UART_ #
#                          Debug\Obj\" -e -z9 --debug --core=plain           #
#                          --dptr=16,1 --data_model=large --code_model=near  #
#                          --calling_convention=ext_stack_reentrant          #
#                          --place_constants=code --nr_virtual_regs 20       #
#                          --extended_stack "C:\Documents and                #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\fm\qn #
#                          8065.c"                                           #
#    List file          =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\UART_Debug\List\qn8065.lst            #
#    Object file        =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\UART_Debug\Obj\qn8065.r51             #
#                                                                            #
#                                                                            #
##############################################################################

C:\Documents and Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX1070_20150908\fm\qn8065.c
      1          /*--------------------------------------------------------------------------*/
      2          /**@file QN8065.C
      3             @brief FMÄ£¿éQN8065Çý¶¯
      4             @details FMÄ£¿éQN8065µÄÇý¶¯º¯Êý
      5             @author NC
      6             @date 2013-10-23
      7             @note Í¨¹ýºê¶¨ÒåÀ´Ñ¡ÔñÇý¶¯·½Ê½
      8          */
      9          /*----------------------------------------------------------------------------*/
     10          
     11          #include "include.h"
     12          #include "qn8065.h"
     13          
     14          #if FM_QN8065_EN
     15          
     16          //if using pilot as CCA algorithm,macro QN8065_PILOT_CCA will be set to 1
     17          #define QN8065_PILOT_CCA 		            1
     18          
     19          #if ((FM_CLOCK == USE_IO_12MHZ_CLK) || (FM_CLOCK == USE_SD_IO_12MHZ_CLK))
     20          //if using scan noise floor as CCA algorithm,macro QN8065_SCAN_NOISE_FLOOR_CCA will be set to 1
     21          #define QN8065_SCAN_NOISE_FLOOR_CCA			0
     22          //if want improving some special frequency SNR, macro IMPROVING_SNR will be set to 1
     23          #define IMPROVING_SNR                       0
     24          #else
     25          #define QN8065_SCAN_NOISE_FLOOR_CCA		    1
     26          #define IMPROVING_SNR                       1
     27          #endif
     28          u8 QN8065_PreNoiseFloor = 40,QN8065_NoiseFloor = 40;
     29          
     30          #pragma constseg="QN8065_RX_TABLE"
     31          #if 0
     32          //32¼¶ÒôÁ¿
     33          u8 volume_8065table[33] = {0,2,4,6,8,10,12,13,14,15,16,17,18,\
     34                                     19,20,21,22,23,24,25,26,27,28,29,30,32,34,36,38,41,43,45,47
     35                                    };
     36          #else
     37          //16¼¶ÒôÁ¿
     38          u8 volume_8065table[17] = {0,4,8,12,14,16,18,20,22,24,26,28,30,34,38,43,47};
     39          #endif
     40          #pragma constseg=default
     41          
     42          void QN8065_Delay(u16 n) @"QN8065_RX"
     43          {
     44          	while(n--)
     45          		asm("nop");
     46          }
     47          
     48          UINT16 QN8065_FREQ2CHREG(UINT16 freq) @"QN8065_RX"
     49          {
     50          	return	(freq-6000)/5;
     51          }
     52          
     53          /**********************************************************************
     54          void QN8065_SetMute(u8 On)
     55          **********************************************************************
     56          Description: on or off mute chip
     57          Parameters:
     58              On: 1:on mute chip;0:off mute chip
     59          Return Value:
     60              None
     61          **********************************************************************/
     62          void QN8065_SetMute(u8 On) @"QN8065_RX"
     63          {
     64          	//mute or unmute by holding DAC
     65          	//and set low voltage regulator output as 0.9v
     66          	QN8065_WriteReg(QN8065_REG_REF, On?0x14:0x10);
     67          }
     68          
     69          /**********************************************************************
     70          void QN8065_SetCh(UINT16 start,UINT16 stop,u8 step)
     71          **********************************************************************
     72          Description: set channel frequency
     73          Parameters:
     74              freq:  channel frequency to be set,frequency unit is 10KHZ
     75          Return Value:
     76              None
     77          **********************************************************************/
     78          void QN8065_SetCh(UINT16 start,UINT16 stop,u8 step) @"QN8065_RX"
     79          {
     80          	u8 temp;
     81          	//TRACE("start:%d,stop:%d,step:%d \n",start,stop, step);
     82          	start = QN8065_FREQ2CHREG(start);
     83          	//fored the stop is bigger than start
     84          	stop = QN8065_FREQ2CHREG(stop);
     85          	//writing higher bits of channel frequency,CCA channel start,
     86          	//stop and step index at first
     87          	temp = (u8)((start >> 8) & QN8065_CH_CH);
     88          	temp |= ((u8)(start >> 6) & QN8065_CH_CH_START);
     89          	temp |= ((u8)(stop >> 4) & QN8065_CH_CH_STOP);
     90          	temp |= (step << 6);
     91          	QN8065_WriteReg(QN8065_CH_STEP, temp);
     92          	//writing lower 8 bits of CCA channel start index
     93          	QN8065_WriteReg(QN8065_CH_START, (u8)start);
     94          	//writing lower 8 bits of CCA channel stop index
     95          	QN8065_WriteReg(QN8065_CH_STOP, (u8)stop);
     96          	//writing lower 8 bits of channel index
     97          	QN8065_WriteReg(QN8065_CH, (u8)start);
     98          }
     99          
    100          /**********************************************************************
    101          void qn8065_init()
    102          **********************************************************************
    103          Description: Initialize device to make it ready to have all functionality ready for use.
    104          Parameters:
    105              None
    106          Return Value:
    107              None
    108          **********************************************************************/
    109          void qn8065_init(void) @"QN8065_RX"
    110          {
    111          	QN8065_WriteReg(QN8065_SYSTEM1, 0x81);
    112          	delay_5ms(10);
    113          
    114          	/*********User sets chip working clock **********/
    115          	//Following is where change the input clock wave type,as sine-wave or square-wave.
    116          
    117          #if ( (FM_CLOCK == USE_IO_32KHZ_CLK) || (FM_CLOCK == USE_SD_IO_32KHZ_CLK)\
    118              || (FM_CLOCK == USE_IO_12MHZ_CLK) || (FM_CLOCK == USE_SD_IO_12MHZ_CLK) )
    119          	QN8065_WriteReg(QN8065_CCA,QN8065_DIGITAL_CLOCK);    //·½²¨
    120          #else
    121          	QN8065_WriteReg(QN8065_CCA,QN8065_SINE_WAVE_CLOCK);  //ÕýÏÒ²¨
    122          #endif
    123          	//Following is where change the input clock frequency.
    124          
    125          	QN8065_WriteReg(QN8065_XTAL_DIV0, QN8065_XTAL_DIV0_VAL);
    126          	QN8065_WriteReg(QN8065_XTAL_DIV1, QN8065_XTAL_DIV1_VAL);
    127          	QN8065_WriteReg(QN8065_XTAL_DIV2, QN8065_XTAL_DIV2_VAL);
    128          
    129          	delay_5ms(10);
    130          
    131          	/********User sets chip working clock end ********/
    132          	QN8065_WriteReg(QN8065_CCA1, 0x96);
    133          	QN8065_WriteReg(QN8065_CCOND1, 0xb6);
    134          	///select SNR for SM,SNC,HCC MPX
    135          	QN8065_WriteReg(QN8065_SMSTART,0x80|QN8065_SMSTART_VAL); //set SMSTART
    136          	QN8065_WriteReg(QN8065_SNCSTART,0x80|QN8065_SNCSTART_VAL); //set SNCSTART
    137          	QN8065_WriteReg(QN8065_HCCSTART,0x80|QN8065_HCCSTART_VAL); //set HCCSTART
    138          	//enter receiver mode directly
    139          	QN8065_WriteReg(QN8065_SYSTEM1, 0x11);
    140          	QN8065_SetMute(1);
    141          }
    142          
    143          /**********************************************************************
    144          void qn8065_tune2ch(u16 ch)
    145          **********************************************************************
    146          Description: Tune to the specific channel.
    147          Parameters:
    148          	ch:Set the frequency (10kHz) to be tuned,
    149          eg: 101.30MHz will be set to 10130.
    150          Return Value:
    151          	None
    152          **********************************************************************/
    153          void qn8065_tune2ch(u16 ch) @"QN8065_RX"
    154          {
    155          	u8 sysClk32kFlag = 0;
    156          	u8 stereoFlag = 0;
    157          	u8 reg;
    158          #if !FM_SEEK_50K_STEP
    159          	ch = ch * 10;
    160          #endif
    161          	QN8065_SetMute(1);
    162          	if(QN8065_ReadReg(QN8065_XTAL_DIV0) == 0x01)
    163          	{
    164          		sysClk32kFlag = 1;
    165          		stereoFlag = (QN8065_ReadReg(QN8065_STATUS1) & QN8065_ST_MO_RX) ? 0:1;
    166          	}
    167          #if IMPROVING_SNR
    168          	//improving some special stations snr when working clock is 32768Hz
    169          	if(ch == 10030 || ch == 10090 || ch == 10100 || ch == 10110
    170          	|| ch == 10150 || ch == 10160 || ch == 10220)
    171          	{
    172          		//frequency is added 50k only system clock is 32K.
    173          		if(sysClk32kFlag)
    174          		{
    175          			QN8065_WriteReg(QN8065_XTAL_DIV2, 0x67);
    176          			//add 50K
    177          			ch += 5;
    178          		}
    179          	}
    180          	//restore XTAL_DIV2 right value if the station is not a special station
    181          	else
    182          	{
    183          		QN8065_WriteReg(QN8065_XTAL_DIV2, QN8065_XTAL_DIV2_VAL);
    184          	}
    185          #endif
    186          	QN8065_WriteReg(QN8065_REG_FLL,0x84); //enable 2k speed
    187          	//enter idle mode and disable CCA, with user write into frequency
    188          	QN8065_WriteReg(QN8065_SYSTEM1, 0x01);
    189          	//step is 100K.
    190          	QN8065_SetCh(ch, ch, 1);
    191          	//enter rx mode and disable CCA, with user write into frequency
    192          	QN8065_WriteReg(QN8065_SYSTEM1, 0x11);
    193          	QN8065_Delay(QN8065_CH_SETUP_DELAY_TIME);
    194          	QN8065_WriteReg(QN8065_REG_FLL, 0x04);//disable 2k speed
    195          	if(sysClk32kFlag)
    196          	{
    197          		reg = QN8065_ReadReg(QN8065_CCA1);
    198          		//disable bypass 32k spur rejection filter if is stereo
    199          		if(stereoFlag)
    200          		{
    201          			reg &= ~0x20;
    202          		}
    203          		//enable bypass 32k spur rejection filter if is mono
    204          		else
    205          		{
    206          			reg |= 0x20;
    207          		}
    208          		QN8065_WriteReg(QN8065_CCA1, reg);
    209          	}
    210          	QN8065_SetMute(0);
    211          }
    212          
    213          #if QN8065_SCAN_NOISE_FLOOR_CCA
    214          /***********************************************************************
    215          Description: scan a noise floor from 87.5M to 108M by step 200K
    216          Parameters:
    217          Return Value:
    218          1: scan a noise floor successfully.
    219          0: chip would not normally work.
    220          **********************************************************************/
    221          u8 QN8065_ScanNoiseFloor(u16 start,u16 stop) @"QN8065_RX"
    222          {
    223          	u8 regValue;
    224          	u8 timeOut = 255; //time out is 2.55S
    225          
    226          	QN8065_WriteReg(QN8065_CCA_TIME,0x00);
    227          	//config CCS from start frequency to  stop frequency by step 200KHZ
    228          	QN8065_SetCh(start,stop,2);
    229          	//enable CCS
    230          	QN8065_WriteReg(QN8065_CCA2, 0x95);
    231          	//enter CCA mode,channel index is decided by internal CCA
    232          	QN8065_WriteReg(QN8065_SYSTEM1,0x12);
    233          	while(1)
    234          	{
    235          		regValue = QN8065_ReadReg(QN8065_SYSTEM1);
    236          		//if it seeks a potential channel, the loop will be quited
    237          		if((regValue & QN8065_CHSC) == 0) break;
    238          		delay_5ms(10);   //delay 10ms
    239          		//if it was time out,chip would not normally work.
    240          		if((timeOut--) == 0)
    241          		{
    242          			//disable CCS while exit
    243          			QN8065_WriteReg(QN8065_CCA2,0x85);
    244          			return 0;
    245          		}
    246          	}
    247          	//disable CCS while exit
    248          	QN8065_WriteReg(QN8065_CCA2,0x85);
    249          	QN8065_NoiseFloor = QN8065_ReadReg(QN8065_CCS_NOISE)&0x7f;
    250          	if(((QN8065_PreNoiseFloor-QN8065_NoiseFloor) > 2) ||((QN8065_NoiseFloor-QN8065_PreNoiseFloor) > 2))
    251          	{
    252          		QN8065_PreNoiseFloor = QN8065_NoiseFloor;
    253          	}
    254          	//TRACE("%d-%d noiseFloor:%d,timeElapsed:%dms\n",start,stop,QN8065_NoiseFloor,(255-timeOut)*10);
    255          	return 1;
    256          }
    257          #endif
    258          
    259          /***********************************************************************
    260          void QN8065_RXSetTH(void)
    261          ***********************************************************************
    262          Description: Setting the threshold value of automatic scan channel
    263          
    264          Return Value:
    265            	None
    266          ***********************************************************************/
    267          void QN8065_RXSetTH(void) @"QN8065_RX"
    268          {
    269          #if IMPROVING_SNR
    270          	u8 rssiTH;
    271          	rssiTH = (QN8065_PreNoiseFloor-28);//(QN8065_PreNoiseFloor-28)+3;
    272          	//restore XTAL_DIV2 right value if the station is not a special station
    273          	QN8065_WriteReg(QN8065_XTAL_DIV2, QN8065_XTAL_DIV2_VAL);
    274          	//set IF counter error range value is 256 = 4*64
    275          	QN8065_WriteReg(QN8065_CCA_CNT, 8);//4
    276          #else
    277          	//set IF counter error range value is 256 = 4*64
    278          	QN8065_WriteReg(QN8065_CCA_CNT, 10);//8
    279          #endif
    280          	//set CCA time
    281          	QN8065_WriteReg(QN8065_CCA_TIME, QN8065_CCA_NAGC_40MS|QN8065_CCA_NSNR_20MS|QN8065_CCA_NRSSI_10MS);
    282          #if IMPROVING_SNR
    283          	//set RSSI threshold for CCA
    284          	QN8065_WriteReg(QN8065_CCA, QN8065_ReadReg(QN8065_CCA)&~0x3f|rssiTH);
    285          #else
    286          	//set RSSI threshold for CCA
    287          	QN8065_WriteReg(QN8065_CCA, QN8065_ReadReg(QN8065_CCA)&~0x3f | 3); //rssiTH);
    288          #endif
    289          	//set QN8065_SNR threshold for CCA
    290          #if QN8065_PILOT_CCA
    291          	QN8065_WriteReg(QN8065_CCA_SNR_TH, QN8065_ReadReg(QN8065_CCA_SNR_TH)&~0x3f|8);  //pilot CCA the QN8065_SNR thershold is 8
    292          #else
    293          	QN8065_WriteReg(QN8065_CCA_SNR_TH, QN8065_ReadReg(QN8065_CCA_SNR_TH)&~0x3f|9); 	//normall CCA the QN8065_SNR thereshold is 9
    294          #endif
    295          	//TRACE("rssiTH=%d, snrTH=%d\n", rssiTH,snrTH);
    296          }
    297          
    298          //#pragma constseg="FM_SEG_QN8065_CONST"
    299          IAR_CONST u16 qn8065_start[] =
    300          {
    301          	8750,  8810,  9010,  9210,
    302          	9410,  9610,  9810,  10010,
    303          	10210, 10410, 10610
    304          };
    305          
    306          IAR_CONST u16 qn8065_stop[] =
    307          {
    308          	8800,  9000,  9200,  9400,
    309          	9600,  9800,  10000, 10200,
    310          	10400, 10600, 10800
    311          };
    312          //#pragma constseg=default
    313          /***********************************************************************
    314          INT8 QN8065_RXValidCH(UINT16 freq);
    315          ***********************************************************************
    316          Description: to validate a ch (frequency)(if it's a valid channel)
    317          Freq: specific channel frequency, unit: 10Khz
    318            eg: 108.00MHz will be set to 10800.
    319          Return Value:
    320            0: it's not a valid channel
    321            1: it's a valid channel
    322           -1: chip does not normally work.
    323          ***********************************************************************/
    324          u8 QN8065_RXValidCH(u16 freq) @"QN8065_RX"
    325          {
    326          	u8 regValue;
    327          	u8 timeOut;
    328          	u8 isValidChannelFlag;
    329          #if QN8065_PILOT_CCA
    330          	u8 snr,readCnt,stereoCount=0;
    331          #endif
    332          
    333          #if ( (FM_CLOCK != USE_IO_12MHZ_CLK) && (FM_CLOCK != USE_SD_IO_12MHZ_CLK) )
    334          #if QN8065_SCAN_NOISE_FLOOR_CCA
    335          #if 1
    336          	for(u8 i=0; i<11; i++)
    337          	{
    338          		if(freq == qn8065_start[i])
    339          		{
    340          			QN8065_ScanNoiseFloor(qn8065_start[i], qn8065_stop[i]);
    341          			QN8065_RXSetTH();
    342          			break;
    343          		}
    344          	}
    345          #else
    346          	switch(freq)
    347          	{
    348          	case 8750:
    349          		QN8065_ScanNoiseFloor(8750,8800);
    350          		QN8065_RXSetTH();
    351          		break;
    352          	case 8810:
    353          		QN8065_ScanNoiseFloor(8810,9000);
    354          		QN8065_RXSetTH();
    355          		break;
    356          	case 9010:
    357          		QN8065_ScanNoiseFloor(9010,9200);
    358          		QN8065_RXSetTH();
    359          		break;
    360          	case 9210:
    361          		QN8065_ScanNoiseFloor(9210,9400);
    362          		QN8065_RXSetTH();
    363          		break;
    364          	case 9410:
    365          		QN8065_ScanNoiseFloor(9410,9600);
    366          		QN8065_RXSetTH();
    367          		break;
    368          	case 9610:
    369          		QN8065_ScanNoiseFloor(9610,9800);
    370          		QN8065_RXSetTH();
    371          		break;
    372          	case 9810:
    373          		QN8065_ScanNoiseFloor(9810,10000);
    374          		QN8065_RXSetTH();
    375          		break;
    376          	case 10010:
    377          		QN8065_ScanNoiseFloor(10010,10200);
    378          		QN8065_RXSetTH();
    379          		break;
    380          	case 10210:
    381          		QN8065_ScanNoiseFloor(10210,10400);
    382          		QN8065_RXSetTH();
    383          		break;
    384          	case 10410:
    385          		QN8065_ScanNoiseFloor(10410,10600);
    386          		QN8065_RXSetTH();
    387          		break;
    388          	case 10610:
    389          		QN8065_ScanNoiseFloor(10610,10800);
    390          		QN8065_RXSetTH();
    391          		break;
    392          	default:
    393          		//delay_5ms(100); //this delay can improve user display effect
    394          		break;
    395          	}
    396          #endif
    397          #endif
    398          	//enter idle mode and disable CCA, with user write into frequency
    399          	QN8065_WriteReg(QN8065_SYSTEM1, 0x01);
    400          	//only support 100K and 200K step.
    401          	QN8065_SetCh(freq,freq+10,2);
    402          
    403          #else
    404          	QN8065_RXSetTH();
    405          
    406          	//enter idle mode and disable CCA, with user write into frequency
    407          	QN8065_WriteReg(QN8065_SYSTEM1, 0x01);
    408          
    409          	//only support 100K and 200K step.
    410          	QN8065_SetCh(freq,freq+5,1);
    411          #endif
    412          
    413          	//entering into RX mode and CCA mode,channels index decide by CCA.
    414          	QN8065_WriteReg(QN8065_SYSTEM1, 0x12);
    415          #if ((FM_CLOCK != USE_IO_12MHZ_CLK) && (FM_CLOCK != USE_SD_IO_12MHZ_CLK))
    416          	delay_5ms(10);
    417          #endif
    418          	timeOut = 60;  // time out is 300ms
    419          	while(1)
    420          	{
    421          		regValue = QN8065_ReadReg(QN8065_SYSTEM1);
    422          		//if it seeks a potential channel, the loop will be quited
    423          		if((regValue & QN8065_CHSC) == 0) break;
    424          		delay_5ms(5);   //delay 5ms
    425          		//if it was time out,chip would not normally work.
    426          		if((timeOut--) == 0) return 0;
    427          	}
    428          	//reading out the rxcca_fail flag of RXCCA status
    429          	isValidChannelFlag = (QN8065_ReadReg(QN8065_STATUS1) & QN8065_RXCCA_FAIL ? 0:1);
    430          	if(isValidChannelFlag)
    431          	{
    432          		QN8065_SetMute(0);      //ËÑµ½ÕæÌ¨ºó²»MUTE£¬³ÌÐòÀïÈÃÆä×Ô¶¯²¥·ÅÒ»Ð¡¶ÎÊ±¼ä
    433          #if QN8065_PILOT_CCA
    434          		//set pilot threshold as 1/256
    435          		QN8065_WriteReg(QN8065_CCOND2,0x91);
    436          		delay_5ms(100);
    437          		snr = QN8065_ReadReg(QN8065_SNR);
    438          #if ((FM_CLOCK != USE_IO_12MHZ_CLK) && (FM_CLOCK != USE_SD_IO_12MHZ_CLK))
    439          		if(snr< 25)  //25
    440          #else
    441          		if(snr< 13)  //13
    442          #endif
    443          		{
    444          			isValidChannelFlag = 0;
    445          			for(readCnt=10; readCnt>0; readCnt--)
    446          			{
    447          				delay_5ms(2);
    448          				stereoCount += ((QN8065_ReadReg(QN8065_STATUS1) & QN8065_ST_MO_RX) ? 0:1);
    449          				if(stereoCount >= 3)
    450          				{
    451          					isValidChannelFlag =1;
    452          					break;
    453          				}
    454          			}
    455          		}
    456          		//restore pilot threshold as 2/256
    457          		QN8065_WriteReg(QN8065_CCOND2,0x92);
    458          		return (isValidChannelFlag);
    459          #else
    460          		return 1;
    461          #endif
    462          	}
    463          	return 0;
    464          }
    465          
    466          /************************************************************************
    467          void QN8065_RXConfigAudio(u8 volume )
    468          *************************************************************************
    469          Description: config audio
    470          Parameters:
    471            volume:control the volume gain,range : 0~47(-47db~0db)
    472          Return Value:
    473              None
    474          **********************************************************************/
    475          void QN8065_RXConfigAudio(u8 option) @"QN8065_RX"
    476          {
    477          	u8 regVal;
    478          
    479          	option = option>47 ? 47:option;
    480          	regVal = QN8065_ReadReg(QN8065_VOL_CTL);
    481          	regVal = (regVal&0xc0)|(option/6)|((5-option%6)<<3);
    482          	QN8065_WriteReg(QN8065_VOL_CTL,regVal);
    483          }
    484          
    485          void qn8065_set_vol(u8 volume) @"QN8065_RX"
    486          {
    487          	if(volume == 0)
    488          	{
    489          		QN8065_SetMute(1);
    490          	}
    491          	else {
    492          		QN8065_SetMute(0);
    493          	}
    494          	QN8065_RXConfigAudio(volume_8065table[volume]);
    495          }
    496          
    497          void qn8065_off(void) @"QN8065_RX"
    498          {
    499          	QN8065_WriteReg(QN8065_SYSTEM1, 0x20);
    500          	delay_5ms(10);
    501          }
    502          
    503          u8 qn8065_seek(u16 freq) @"QN8065_RX"
    504          {
    505          	QN8065_SetMute(1);
    506          #if FM_SEEK_50K_STEP
    507          	return QN8065_RXValidCH(freq);
    508          #else
    509          	return QN8065_RXValidCH(freq*10);//qn8035 step frequency unit is 10KHZ
    510          #endif
    511          }
    512          
    513          ////////////////////////////////////////////
    514          u8 QN8065_ReadReg(u8 adr) @"QN8065_RX"
    515          {
    516          	u8  I2CReadResult;
    517          
    518          	fm_i2c_start();                 //I2CÆô¶¯
    519          
    520          	fm_i2c_send_byte(0x20);         //Ð´ÃüÁî
    521          	fm_i2c_recv_ack();
    522          
    523          	fm_i2c_send_byte(adr);          //Ð´µØÖ·
    524          	fm_i2c_recv_ack();
    525          
    526          	fm_i2c_stop();                  //I2CÍ£Ö¹
    527          	QN8065_Delay(60);
    528          
    529          	fm_i2c_start();                 //Ð´×ªÎª¶ÁÃüÁî£¬ÐèÒªÔÙ´ÎÆô¶¯I2C
    530          
    531          	fm_i2c_send_byte(0x21);         //¶ÁÃüÁî
    532          	fm_i2c_recv_ack();
    533          
    534          	I2CReadResult = fm_i2c_read_byte();
    535          	fm_i2c_send_nack();             //·¢ËÍackÃüÁî
    536          
    537          	fm_i2c_stop();                  //I2CÍ£Ö¹
    538          
    539          	QN8065_Delay(60);
    540          
    541          	return  I2CReadResult;
    542          }
    543          
    544          void QN8065_WriteReg(u8 adr, u8 value) @"QN8065_RX"
    545          {
    546          	fm_i2c_start();                 //I2CÆô¶¯
    547          
    548          	fm_i2c_send_byte(0x20);         //Ð´ÃüÁî
    549          	fm_i2c_recv_ack();
    550          
    551          	fm_i2c_send_byte(adr);          //Ð´µØÖ·
    552          	fm_i2c_recv_ack();
    553          
    554          
    555          	fm_i2c_send_byte(value);        //Ð´Êý¾Ý
    556          	fm_i2c_recv_ack();
    557          
    558          	fm_i2c_stop();                 //I2CÍ£Ö¹Ê±Ðò
    559          
    560          	QN8065_Delay(60);
    561          }
    562          
    563          u8 qn8065_online(void) @"QN8065_RX"
    564          {
    565          	u8 temp;
    566          	for(u8 i = 0; i < 3; i++)
    567          	{
    568          		temp =QN8065_ReadReg(0x06) & 0xFC;
    569          		printf("QN_id=%02x\n",temp);
    570          		if(temp == CHIPID_QN8065)
    571          		{
    572          			qn8065_init();
    573          			return 1;
    574          		}
    575          	}
    576          	return 0;
    577          }
    578          
    579          u16 GetIFCount(void) @"QN8065_RX"
    580          {
    581          	u8 r_temp;
    582          	u8 IF_CNT1;
    583          	UINT16 IF_CNT;
    584          	IF_CNT1 = QN8065_ReadReg(0x1D);
    585          	IF_CNT = QN8065_ReadReg(0x1E);
    586          	IF_CNT = IF_CNT<<8;
    587          	IF_CNT = IF_CNT + IF_CNT1;
    588          	r_temp = QN8065_ReadReg(0x11);
    589          	r_temp= r_temp & 0xfd;
    590          	QN8065_WriteReg(0x11, r_temp);
    591          	r_temp= r_temp | 0x02;
    592          	QN8065_WriteReg(0x11, r_temp);
    593          	return IF_CNT;
    594          }
    595          
    596          #endif


   Segment part sizes:

     Function/Label Bytes
     -------------- -----

 
 
 0 bytes of memory

Errors: none
Warnings: none
