##############################################################################
#                                                                            #
# IAR 8051 C/C++ Compiler V7.20H/W32                   10/Sep/2015  19:03:31 #
# Copyright 2004-2006 IAR Systems. All rights reserved.                      #
#                                                                            #
#    Core               =  plain                                             #
#    Code model         =  near                                              #
#    Data model         =  large                                             #
#    Calling convention =  extended stack reentrant                          #
#    Constant location  =  code                                              #
#    Extended stack     =  enabled                                           #
#    Dptr setup         =  1,16                                              #
#    Source file        =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\user\user_key.c                       #
#    Command line       =  -I "C:\Program Files\IAR Systems\Embedded         #
#                          Workbench 4.05 Evaluation version\8051\INC\" -I   #
#                          "C:\Program Files\IAR Systems\Embedded Workbench  #
#                          4.05 Evaluation version\8051\INC\CLIB\" -I        #
#                          "C:\Documents and Settings\Administrator\×ÀÃæ\lil #
#                          y\15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX1 #
#                          070_20150908\COMMON\" -I "C:\Documents and        #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\INC\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\config\" -I "C:\Documents and    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\api\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\fm\" -I "C:\Documents and        #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\fat\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\display\" -I "C:\Documents and   #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\displ #
#                          ay\led\" -I "C:\Documents and                     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\displ #
#                          ay\lcd\" -I "C:\Documents and                     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\task\ #
#                          " -I "C:\Documents and Settings\Administrator\×ÀÃ #
#                          æ\lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lil #
#                          y_AX1070_20150908\user\" -I "C:\Documents and     #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\mem\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\module\" -I "C:\Documents and    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\modul #
#                          e\kedir\" -I "C:\Documents and                    #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\key\" #
#                           -I "C:\Documents and Settings\Administrator\×ÀÃæ #
#                          \lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily #
#                          _AX1070_20150908\startmusic\" -D UART_DEBUG -D    #
#                          AX207X_TAG -lC "C:\Documents and                  #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\UART_ #
#                          Debug\List\" -o "C:\Documents and                 #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\UART_ #
#                          Debug\Obj\" -e -z9 --debug --core=plain           #
#                          --dptr=16,1 --data_model=large --code_model=near  #
#                          --calling_convention=ext_stack_reentrant          #
#                          --place_constants=code --nr_virtual_regs 20       #
#                          --extended_stack "C:\Documents and                #
#                          Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX #
#                          1070_20150908\15BC178B_Lily_AX1070_20150908\user\ #
#                          user_key.c"                                       #
#    List file          =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\UART_Debug\List\user_key.lst          #
#    Object file        =  C:\Documents and Settings\Administrator\×ÀÃæ\lily #
#                          \15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX10 #
#                          70_20150908\UART_Debug\Obj\user_key.r51           #
#                                                                            #
#                                                                            #
##############################################################################

C:\Documents and Settings\Administrator\×ÀÃæ\lily\15BC178B_Lily_AX1070_20150908\15BC178B_Lily_AX1070_20150908\user\user_key.c
      1          /*****************************************************************************
      2          * Module    : User
      3          * File      : user_key.c
      4          * Author    : Hanny
      5          * Email     : coldney@yahoo.com.cn
      6          * Function  : ÓÃ»§°´¼ü¶¨Òå
      7          *****************************************************************************/
      8          #include "include.h"

   \                                 In segment SFR_AN, at 0x80
   \   unsigned char volatile __sfr P0
   \                     P0:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xd1
   \   unsigned char volatile __sfr ADCCON
   \                     ADCCON:
   \   000000                DS 1

   \                                 In segment SFR_AN, at 0xd4
   \   unsigned char volatile __sfr ADCDATAH
   \                     ADCDATAH:
   \   000000                DS 1
      9          #include "touch_key.h"
     10          #include "ir.h"
     11          #include "kedir.h"
     12          
     13          
     14          extern IAR_CONST type_adc_key tbl_adkey[];
     15          extern IAR_CONST type_adc_key tbl_adkey2[];
     16          

   \                                 In segment XDATA_N, align 1, root
     17          IAR_XDATA_A type_key_ctl key_ctl;
   \                     key_ctl:
   \   000000                DS 5

   \                                 In segment XDATA_N, align 1, root
     18          IAR_XDATA_A type_scan_ctl scan_ctl;
   \                     scan_ctl:
   \   000000                DS 6
     19          
     20          #if (USE_MIXIO_AD || USE_ADKEY2)
     21          //Ê¹ÓÃÈýºÏÒ»IO×öÆÕÍ¨IO£¬²¢AD²ÉÑù(USE_KEDIRÎª0Ê±ÓÐÐ§£¬FPGAÉÏ¿ÉÓÃ)
     22          #pragma location="KEY_INIT"
     23          void mixio_adinit(void)
     24          {
     25          	//PIE05:P10; PIE03-P03; PIE02-P02; PIE00-P27;
     26          #if (KEDIR_PORT == KEDIR_P10)
     27          	P1DIR |= BIT(0);            //P10
     28          	PIE0 &= ~(BIT(5));          //P10
     29          #elif (KEDIR_PORT == KEDIR_P03)
     30          	P0DIR |= BIT(3);            //P03
     31          	PIE0 &= ~(BIT(3));          //P03
     32          #elif (KEDIR_PORT == KEDIR_P02)
     33          	P0DIR |= BIT(2);            //P02
     34          	PIE0 &= ~(BIT(2));          //P02
     35          #elif (KEDIR_PORT == KEDIR_P27)
     36          	P2DIR |= BIT(7);            //P27
     37          	PIE0 &= ~(BIT(0));          //P27
     38          #else
     39          #error "ÇëÑ¡ÔñAD²ÉÑùµÄIO"
     40          #endif
     41          
     42          	KEDIR_DISABLE_TOP();        //33K pull down resistance disable
     43          #ifdef AX207X_TAG
     44          	if(DCN == 0x00)
     45          	{
     46          		KEDIR_DISABLE_BIG_1();  //22k,2.2k pull up resistance disable
     47          		KEDIR_DISABLE_TINY_1();
     48          	}
     49          	else
     50          #endif
     51          	{
     52          		KEDIR_DISABLE_BIG();
     53          		KEDIR_DISABLE_TINY();
     54          	}
     55          	LEDCON2 = BIT(2) | (KEDIR_PORT << 3);//select mix IO, AMUX enable.00:P10; 01:P03; 10:P02; 11:P27
     56          
     57          	ADCCON = BIT(7) | BIT(3) | ADKEDIR_CHAN;
     58          }
     59          #endif
     60          
     61          #if USE_ADKEY2
     62          //µÚ¶þ×éAD°´¼ü³õÊ¼»¯º¯Êý
     63          #pragma location="KEY_INIT"
     64          void adkey2_init(void)
     65          {
     66          	mixio_adinit();  //ÈýºÏÒ»×÷ÎªÆÕ±éADKEY IO
     67          }
     68          #endif
     69          
     70          //°´¼ü³õÊ¼»¯º¯Êý
     71          #pragma location="KEY_INIT"

   \                                 In segment KEY_INIT, align 1, keep-with-next
     72          void key_init(void)
   \                     key_init:
     73          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
     74          	memset(&scan_ctl, 0, sizeof(scan_ctl));
   \   000000                ; Setup parameters for call to function my_memset
   \   000000   7C06         MOV     R4,#0x6
   \   000002   7D00         MOV     R5,#0x0
   \   000004   7900         MOV     R1,#0x0
   \   000006   7A..         MOV     R2,#(scan_ctl & 0xff)
   \   000008   7B..         MOV     R3,#((scan_ctl >> 8) & 0xff)
   \   00000A   12....       LCALL   my_memset
     75          	memset(&key_ctl, 0, sizeof(key_ctl));
   \   00000D                ; Setup parameters for call to function my_memset
   \   00000D   7C05         MOV     R4,#0x5
   \   00000F   7D00         MOV     R5,#0x0
   \   000011   7900         MOV     R1,#0x0
   \   000013   7A..         MOV     R2,#(key_ctl & 0xff)
   \   000015   7B..         MOV     R3,#((key_ctl >> 8) & 0xff)
   \   000017   12....       LCALL   my_memset
     76          
     77          	ADCBAUD = 0x24;
   \   00001A   7424         MOV     A,#0x24
   \   00001C   90300C       MOV     DPTR,#0x300c
   \   00001F   F0           MOVX    @DPTR,A
     78          #if USE_KEDIR
     79          	kedir_init();
     80          #if (USE_KEDIR_TYPE != KEDIR_IR_LED)
     81          	scan_ctl.kedir_ch = ADC_TINY;
     82          	scan_ctl.adc_ch = ADC_KEDIR;
     83          #else
     84          	//ÈýºÏÒ»Ê¹ÓÃIR & LED
     85          	key_keidr_scan();
     86          	ADCCON = BIT(3) | ADKEDIR_CHAN;
     87          	KEDIR_ADCGO();
     88          	scan_ctl.adc_ch = ADC_NULL;
     89          #endif
     90          
     91          #endif
     92          #if USE_ADKEY
     93          #if (USER_SEL == USER_AX1071_DEMO)
     94          	P4DIR |= BIT(2);                        //P42
     95          	AIPCON7 |= BIT(6);                      //P42ÉèÎªÄ£Äâ
     96          	ADCCON = BIT(7) | BIT(3) | ADKEY0_CHAN; //ADC_CONV, ADC_EN;
     97          	ADCMODE |= BIT(5);                      //P42 ADC
     98          #else
     99          	P0DIR |= BIT(1);                        //P01
    100          	PIE0 &= ~(BIT(1));                      //P01
    101          	ADCCON = BIT(7) | BIT(3) | ADKEY0_CHAN; //ADC_CONV, ADC_EN;
    102          #endif
    103          	scan_ctl.adc_ch = ADC_KEY;
    104          #endif
    105          #if USE_ADKEY2
    106          	adkey2_init();
    107          	scan_ctl.adc_ch = ADC_KEY2;
    108          #endif
    109          #ifdef AX207X_TAG
    110          #if SOFT_POWEROFF_EN
    111          	P0DIR |= BIT(1);                        //P01
    112          	PIE0 &= ~(BIT(1));                      //P01
    113          	ADCCON = BIT(7) | BIT(3) | ADKEY_POWER_CHAN; //ADC_CONV, ADC_EN;
    114          	scan_ctl.adc_ch = ADC_KEYPOWER;
    115          #endif
    116          #endif
    117          
    118          #if (BATTERY_CHECK || SOFT_POWEROFF_EN)
    119          	AIPCON0 |= BIT(6);  //LDO EN
   \   000020   903050       MOV     DPTR,#0x3050
   \   000023   E0           MOVX    A,@DPTR
   \   000024   D2E6         SETB    0xE0 /* A   */.6
   \   000026   F0           MOVX    @DPTR,A
    120          	AIPCON6 |= BIT(0);  //BAND GAP EN
   \   000027   903056       MOV     DPTR,#0x3056
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   D2E0         SETB    0xE0 /* A   */.0
   \   00002D   F0           MOVX    @DPTR,A
    121          	ADCCON = BIT(7) | BIT(3) | ADBAT_CHAN;
   \   00002E   75D18D       MOV     0xd1,#-0x73
    122          	scan_ctl.adc_ch = ADC_BAT;
   \   000031   7404         MOV     A,#0x4
   \   000033   90....       MOV     DPTR,#scan_ctl
   \   000036   F0           MOVX    @DPTR,A
    123          #endif
    124          }
   \   000037   22           RET
    125          
    126          //»ñÈ¡ADCµÄÖµ
    127          #pragma inline=forced
    128          #pragma location="SCAN_COM"
    129          bool adc_get(void)
    130          {
    131          	if(ADCCON & BIT(7))
    132          	{
    133          		return false;
    134          	}
    135          	scan_ctl.adc_val = ADCDATAH;
    136          
    137          #if USE_KEDIR
    138          	LEDCON1 &= ~BIT(3);  //clear ADC sample fininsh pending
    139          #endif
    140          
    141          	return true;
    142          }
    143          
    144          //¸ù¾ÝADKey¼ì²â°´¼üÖµ
    145          #pragma location="SCAN_COM"

   \                                 In segment SCAN_COM, align 1, keep-with-next
    146          u8 kedir_get(void)
   \                     kedir_get:
    147          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    148          	u8 knum = scan_ctl.kedir_ch * kedir_group_num();
   \   000000                ; Setup parameters for call to function kedir_group_num
   \   000000   12....       LCALL   kedir_group_num
   \   000003   90....       MOV     DPTR,#(scan_ctl + 2)
   \   000006   E0           MOVX    A,@DPTR
   \   000007   F5F0         MOV     B,A
   \   000009   E9           MOV     A,R1
   \   00000A   A4           MUL     AB
   \   00000B   FA           MOV     R2,A
    149          	u8 adc_val = scan_ctl.adc_val;
   \   00000C   90....       MOV     DPTR,#(scan_ctl + 1)
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   FB           MOV     R3,A
   \   000011   8001         SJMP    ??kedir_get_0
    150          
    151          	while(adc_val > tbl_key1[knum].adc_val)
    152          	{
    153          		knum++;
   \                     ??kedir_get_1:
   \   000013   0A           INC     R2
    154          	}
   \                     ??kedir_get_0:
   \   000014   EA           MOV     A,R2
   \   000015   C3           CLR     C
   \   000016   33           RLC     A
   \   000017   F8           MOV     R0,A
   \   000018   E4           CLR     A
   \   000019   33           RLC     A
   \   00001A   F9           MOV     R1,A
   \   00001B   E8           MOV     A,R0
   \   00001C   24..         ADD     A,#(tbl_key1 & 0xff)
   \   00001E   F582         MOV     DPL,A
   \   000020   E9           MOV     A,R1
   \   000021   34..         ADDC    A,#((tbl_key1 >> 8) & 0xff)
   \   000023   F583         MOV     DPH,A
   \   000025   E4           CLR     A
   \   000026   93           MOVC    A,@A+DPTR
   \   000027   C3           CLR     C
   \   000028   9B           SUBB    A,R3
   \   000029   40E8         JC      ??kedir_get_1
    155          	return tbl_key1[knum].key_code;
   \   00002B                REQUIRE ?Subroutine0
   \   00002B                ; // Fall through to label ?Subroutine0
    156          }

   \                                 In segment SCAN_COM, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   A3           INC     DPTR
   \   000001   E4           CLR     A
   \   000002   93           MOVC    A,@A+DPTR
   \   000003   F9           MOV     R1,A
   \   000004   22           RET
    157          
    158          #pragma location="SCAN_COM"

   \                                 In segment SCAN_COM, align 1, keep-with-next
    159          u8 adkey_get(void)
   \                     adkey_get:
    160          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    161          	u8 knum = 0;
   \   000000   7A00         MOV     R2,#0x0
    162          	u8 adc_val = scan_ctl.adc_val;
   \   000002   90....       MOV     DPTR,#(scan_ctl + 1)
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FB           MOV     R3,A
   \   000007   8001         SJMP    ??adkey_get_0
    163          
    164          	while(adc_val > tbl_adkey[knum].adc_val)
    165          	{
    166          		knum++;
   \                     ??adkey_get_1:
   \   000009   0A           INC     R2
    167          	}
   \                     ??adkey_get_0:
   \   00000A   EA           MOV     A,R2
   \   00000B   C3           CLR     C
   \   00000C   33           RLC     A
   \   00000D   F8           MOV     R0,A
   \   00000E   E4           CLR     A
   \   00000F   33           RLC     A
   \   000010   F9           MOV     R1,A
   \   000011   E8           MOV     A,R0
   \   000012   24..         ADD     A,#(tbl_adkey & 0xff)
   \   000014   F582         MOV     DPL,A
   \   000016   E9           MOV     A,R1
   \   000017   34..         ADDC    A,#((tbl_adkey >> 8) & 0xff)
   \   000019   F583         MOV     DPH,A
   \   00001B   E4           CLR     A
   \   00001C   93           MOVC    A,@A+DPTR
   \   00001D   C3           CLR     C
   \   00001E   9B           SUBB    A,R3
   \   00001F   40E8         JC      ??adkey_get_1
    168          	return tbl_adkey[knum].key_code;
   \   000021   80..         SJMP    ?Subroutine0
    169          }
    170          
    171          
    172          #pragma location="SCAN_COM"

   \                                 In segment SCAN_COM, align 1, keep-with-next
    173          u8 iokey_get(void)
   \                     iokey_get:
    174          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    175          	u8 iokey_value = NO_KEY;
   \   000000   7900         MOV     R1,#0x0
    176          	if((!KEY1_CHECK)&&(KEY2_CHECK)&&(KEY3_CHECK))		// Key1
   \   000002   A280         MOV     C,0x80.0
   \   000004   400A         JC      ??iokey_get_0
   \   000006   A281         MOV     C,0x80.1
   \   000008   5006         JNC     ??iokey_get_0
   \   00000A   A282         MOV     C,0x80.2
   \   00000C   5002         JNC     ??iokey_get_0
    177          	{
    178          		iokey_value = T_KEY_PREV;
   \   00000E   09           INC     R1
   \   00000F   22           RET
    179          	}
    180          	else if((!KEY2_CHECK)&&(KEY1_CHECK)&&(KEY3_CHECK))	// Key2
   \                     ??iokey_get_0:
   \   000010   A281         MOV     C,0x80.1
   \   000012   400B         JC      ??iokey_get_1
   \   000014   A280         MOV     C,0x80.0
   \   000016   5007         JNC     ??iokey_get_1
   \   000018   A282         MOV     C,0x80.2
   \   00001A   5003         JNC     ??iokey_get_1
    181          	{
    182          		iokey_value = T_KEY_PLAY;
   \   00001C   09           INC     R1
   \   00001D   09           INC     R1
   \   00001E   22           RET
    183          	}
    184          	else if((!KEY3_CHECK)&&(KEY2_CHECK)&&(KEY1_CHECK))	// Key3
   \                     ??iokey_get_1:
   \   00001F   A282         MOV     C,0x80.2
   \   000021   400B         JC      ??iokey_get_2
   \   000023   A281         MOV     C,0x80.1
   \   000025   5007         JNC     ??iokey_get_2
   \   000027   A280         MOV     C,0x80.0
   \   000029   5003         JNC     ??iokey_get_2
    185          	{
    186          		iokey_value = T_KEY_NEXT;
   \   00002B   09           INC     R1
   \   00002C   09           INC     R1
   \   00002D   09           INC     R1
    187          	}
    188          /*	else if((!KEY1_CHECK)&&(!KEY3_CHECK)&&(KEY2_CHECK))	// Key1 + Key3
    189          	{
    190          		iokey_value = T_KEY_PREV_NEXT;
    191          	}
    192          */
    193          	//printf("iokeyvalue:%d\n",iokey_value);
    194          	return iokey_value;
   \                     ??iokey_get_2:
   \   00002E   22           RET
    195          }
    196          
    197          
    198          #pragma location="SCAN_COM"

   \                                 In segment SCAN_COM, align 1, keep-with-next
    199          u8 adkey2_get(void)
   \                     adkey2_get:
    200          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    201          	u8 knum = 0;
   \   000000   7A00         MOV     R2,#0x0
    202          	u8 adc_val = scan_ctl.adc_val;
   \   000002   90....       MOV     DPTR,#(scan_ctl + 1)
   \   000005   E0           MOVX    A,@DPTR
   \   000006   FB           MOV     R3,A
   \   000007   8001         SJMP    ??adkey2_get_0
    203          
    204          	while(adc_val > tbl_adkey2[knum].adc_val)
    205          	{
    206          		knum++;
   \                     ??adkey2_get_1:
   \   000009   0A           INC     R2
    207          	}
   \                     ??adkey2_get_0:
   \   00000A   EA           MOV     A,R2
   \   00000B   C3           CLR     C
   \   00000C   33           RLC     A
   \   00000D   F8           MOV     R0,A
   \   00000E   E4           CLR     A
   \   00000F   33           RLC     A
   \   000010   F9           MOV     R1,A
   \   000011   E8           MOV     A,R0
   \   000012   24..         ADD     A,#(tbl_adkey2 & 0xff)
   \   000014   F582         MOV     DPL,A
   \   000016   E9           MOV     A,R1
   \   000017   34..         ADDC    A,#((tbl_adkey2 >> 8) & 0xff)
   \   000019   F583         MOV     DPH,A
   \   00001B   E4           CLR     A
   \   00001C   93           MOVC    A,@A+DPTR
   \   00001D   C3           CLR     C
   \   00001E   9B           SUBB    A,R3
   \   00001F   40E8         JC      ??adkey2_get_1
    208          	return tbl_adkey2[knum].key_code;
   \   000021   80..         SJMP    ?Subroutine0
    209          }
    210          
    211          #if SOFT_POWEROFF_EN
    212          //¸ù¾ÝADC¼ì²â
    213          #pragma location="SCAN_COM"
    214          u8 powerkey_get(void)
    215          {
    216          	u8 key;
    217          
    218          	/*AX2070ÓëAX1070µÄÈí¿ª¹ØÄ£¿é²»Í¬£º
    219          	AX2070ÉÏÐèÒªP01µÄAD²ÉÑùÀ´»ñÈ¡power¼ü×´Ì¬£¬
    220          	AX1070ÉÏWKORTC¿ÉÒÔÖ±½Ó»ñÈ¡power¼ü×´Ì¬£»*/
    221          #ifdef AX207X_TAG
    222          	if(scan_ctl.adc_val > 80)
    223          	{
    224          #else
    225          	if(irtc_read_cmd(CFG_RD) & BIT(1))
    226          	{
    227          #endif
    228          		poweroff_ctl.power_key_sta = POWERKEY_DOWN;
    229          		key = T_KEY_SOFT_POWER;
    230          		if(poweroff_ctl.wait_powerkey_up == 0)
    231          		{
    232          			poweroff_ctl.wait_powerkey_up = 1;     //¿ª»úÇ°¾ÍÊÇ°´×Å¼üµÄ
    233          		}
    234          	}
    235          	else
    236          	{
    237          		poweroff_ctl.power_key_sta = POWERKEY_UP;
    238          		poweroff_ctl.wait_powerkey_up = 2;         //°´¼ü·Å¿ª
    239          		key = NO_KEY;
    240          	}
    241          	if((poweroff_ctl.wait_powerkey_up == 1)        //²»´¦Àí¿ª»ú°´¼üÏûÏ¢
    242          #if DCIN_DET_EN
    243          	        || (poweroff_ctl.dc_in_sta == DC_UNSTABLE)  //²»´¦ÀíÍ¬°´¼üµÄDCIN²åÈëÏûÏ¢
    244          #endif
    245          	  )
    246          	{
    247          		key = NO_KEY;
    248          	}
    249          	return key;
    250          }
    251          #endif
    252          
    253          //°´¼üÊÂ¼þ
    254          #pragma location="SCAN_COM"

   \                                 In segment SCAN_COM, align 1, keep-with-next
    255          u8 key_deal(u8 key_val)
   \                     key_deal:
    256          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   \   000000   E9           MOV     A,R1
   \   000001   FA           MOV     R2,A
    257          	u8 key_return = NO_KEY;
   \   000002   7900         MOV     R1,#0x0
    258          	u8 key_return_val = NO_KEY;
   \   000004   7B00         MOV     R3,#0x0
    259          	if(key_val == NO_KEY || key_val != key_ctl.key_val)
   \   000006   6007         JZ      ??key_deal_0
   \   000008   90....       MOV     DPTR,#key_ctl
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   6A           XRL     A,R2
   \   00000D   603A         JZ      ??key_deal_1
    260          	{
    261          		if(key_ctl.key_up < KEY_UP_TIMES)
   \                     ??key_deal_0:
   \   00000F   90....       MOV     DPTR,#(key_ctl + 2)
   \   000012   E0           MOVX    A,@DPTR
   \   000013   C3           CLR     C
   \   000014   9404         SUBB    A,#0x4
   \   000016   5005         JNC     ??key_deal_2
    262          		{
    263          			key_ctl.key_up++;
   \   000018   E0           MOVX    A,@DPTR
   \   000019   04           INC     A
   \                     ??key_deal_3:
   \   00001A   F0           MOVX    @DPTR,A
   \   00001B   8068         SJMP    ??key_deal_4
    264          		}
    265          		else
    266          		{
    267          			if(key_ctl.key_cnt >= KEY_LONG_TIMES)                   //³¤°´Ì§¼ü
   \                     ??key_deal_2:
   \   00001D   90....       MOV     DPTR,#(key_ctl + 1)
   \   000020   E0           MOVX    A,@DPTR
   \   000021   FB           MOV     R3,A
   \   000022   C3           CLR     C
   \   000023   9478         SUBB    A,#0x78
   \   000025   4008         JC      ??key_deal_5
    268          			{
    269          				key_return = key_ctl.key_val | T_KEY_LONG_UP;
   \   000027   90....       MOV     DPTR,#key_ctl
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   44C0         ORL     A,#0xc0
   \   00002D   800C         SJMP    ??key_deal_6
    270          			}
    271          			else if(key_ctl.key_cnt >= KEY_SCAN_TIMES)              //¶Ì°´Ì§¼ü
   \                     ??key_deal_5:
   \   00002F   EB           MOV     A,R3
   \   000030   C3           CLR     C
   \   000031   9406         SUBB    A,#0x6
   \   000033   4007         JC      ??key_deal_7
    272          			{
    273          				key_return = key_ctl.key_val | T_KEY_SHORT_UP;
   \   000035   90....       MOV     DPTR,#key_ctl
   \   000038   E0           MOVX    A,@DPTR
   \   000039   4480         ORL     A,#0x80
   \                     ??key_deal_6:
   \   00003B   F9           MOV     R1,A
    274          			}
    275          			key_return_val = key_ctl.key_val;
   \                     ??key_deal_7:
   \   00003C   90....       MOV     DPTR,#key_ctl
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   FB           MOV     R3,A
    276          			key_ctl.key_val = key_val;
   \   000041   EA           MOV     A,R2
   \   000042   F0           MOVX    @DPTR,A
    277          			key_ctl.key_cnt = 0;
   \   000043   E4           CLR     A
   \   000044   90....       MOV     DPTR,#(key_ctl + 1)
   \   000047   80D1         SJMP    ??key_deal_3
    278          		}
    279          	}
    280          	else
    281          	{
    282          		key_ctl.key_cnt++;
   \                     ??key_deal_1:
   \   000049   90....       MOV     DPTR,#(key_ctl + 1)
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   04           INC     A
   \   00004E   F0           MOVX    @DPTR,A
    283          		if(key_ctl.key_cnt == KEY_SCAN_TIMES)                       //È¥¶¶
   \   00004F   FA           MOV     R2,A
   \   000050   7406         MOV     A,#0x6
   \   000052   6A           XRL     A,R2
   \   000053   700C         JNZ     ??key_deal_8
    284          		{
    285          			key_ctl.key_up = 0;
   \   000055   E4           CLR     A
   \   000056   90....       MOV     DPTR,#(key_ctl + 2)
   \   000059   F0           MOVX    @DPTR,A
    286          			key_return = key_ctl.key_val;
   \   00005A   90....       MOV     DPTR,#key_ctl
   \   00005D   E0           MOVX    A,@DPTR
   \                     ??key_deal_9:
   \   00005E   F9           MOV     R1,A
   \   00005F   801F         SJMP    ??key_deal_10
    287          		}
    288          		else if(key_ctl.key_cnt == KEY_LONG_TIMES)                  //³¤°´
   \                     ??key_deal_8:
   \   000061   7478         MOV     A,#0x78
   \   000063   6A           XRL     A,R2
   \   000064   7008         JNZ     ??key_deal_11
    289          		{
    290          			key_return = key_ctl.key_val | T_KEY_LONG;
   \   000066   90....       MOV     DPTR,#key_ctl
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   44A0         ORL     A,#0xa0
   \   00006C   80F0         SJMP    ??key_deal_9
    291          		}
    292          		else if(key_ctl.key_cnt == KEY_LONG_HOLD_TIMES)             //Á¬°´
   \                     ??key_deal_11:
   \   00006E   749B         MOV     A,#-0x65
   \   000070   6A           XRL     A,R2
   \   000071   700D         JNZ     ??key_deal_10
    293          		{
    294          			key_return = key_ctl.key_val | T_KEY_HOLD;
   \   000073   90....       MOV     DPTR,#key_ctl
   \   000076   E0           MOVX    A,@DPTR
   \   000077   44E0         ORL     A,#0xe0
   \   000079   F9           MOV     R1,A
    295          			key_ctl.key_cnt = KEY_LONG_TIMES;
   \   00007A   7478         MOV     A,#0x78
   \   00007C   90....       MOV     DPTR,#(key_ctl + 1)
   \   00007F   F0           MOVX    @DPTR,A
    296          		}
    297          		key_return_val = key_ctl.key_val;
   \                     ??key_deal_10:
   \   000080   90....       MOV     DPTR,#key_ctl
   \   000083   E0           MOVX    A,@DPTR
   \   000084   FB           MOV     R3,A
    298          	}
    299          	if((key_return_val & 0x60) && (key_return & 0x80))                  //32-127ÕâÐ©¼üÖµ²»Ö§³Ö³¤°´
   \                     ??key_deal_4:
   \   000085   7460         MOV     A,#0x60
   \   000087   5B           ANL     A,R3
   \   000088   6007         JZ      ??key_deal_12
   \   00008A   E9           MOV     A,R1
   \   00008B   A2E7         MOV     C,0xE0 /* A   */.7
   \   00008D   5002         JNC     ??key_deal_12
    300          	{
    301          		return NO_KEY;
   \   00008F   7900         MOV     R1,#0x0
    302          	}
    303          #if USE_KEDIR
    304          	if(!b_sys.kedir_flag)           //µÈ´ýÏµÍ³ÎÈ¶¨ºóÔÙÏìÓ¦ÈýºÏÒ»°´¼üÏûÏ¢
    305          	{
    306          		return NO_KEY;
    307          	}
    308          #endif
    309          	return key_return;
   \                     ??key_deal_12:
   \   000091   22           RET
    310          }
    311          
    312          //É¨Ãè°´¼ü
    313          #pragma location="SCAN_COM"

   \                                 In segment SCAN_COM, align 1, keep-with-next
    314          void key_scan(void)
   \                     key_scan:
    315          {
   \   000000   EE           MOV     A,R6
   \   000001   C0E0         PUSH    A
   \   000003                ; Saved register size: 1
   \   000003                ; Auto size: 0
    316          	u8 key_val = NO_KEY;
    317          //	static bool key_scan_flag = true;	// Merlin ÒÆ³ý, Ô­ÒòÊÇÕâÀï²»ÓÃ AD¹¦ÄÜ, Ã»ÓÐ³åÍ»ÎÊÌâ
    318          	
    319          	//if(key_scan_flag)
    320          	{
    321          		key_val = iokey_get();
   \   000003                ; Setup parameters for call to function iokey_get
   \   000003   12....       LCALL   iokey_get
   \   000006   E9           MOV     A,R1
   \   000007   FE           MOV     R6,A
    322          	//	if(key_val == NO_KEY)
    323          	//		key_scan_flag = false;
    324          	}
    325          	//else
    326          
    327          	if(key_val == NO_KEY)
   \   000008   7042         JNZ     ??key_scan_0
    328          	{
    329          		if(!adc_get())
   \   00000A   E5D1         MOV     A,0xd1
   \   00000C   A2E7         MOV     C,0xE0 /* A   */.7
   \   00000E   403C         JC      ??key_scan_0
   \   000010   E5D4         MOV     A,0xd4
   \   000012   90....       MOV     DPTR,#(scan_ctl + 1)
   \   000015   F0           MOVX    @DPTR,A
    330          		{
    331          			//return;
    332          		}
    333          		else switch(scan_ctl.adc_ch)
   \   000016   90....       MOV     DPTR,#scan_ctl
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for key_scan>_0`:
   \   00001D   04           DB        4
   \   00001E   01           DB        1
   \   00001F   ....         DW        ??key_scan_0
   \   000021   ....         DW        ??key_scan_1
   \   000023   ....         DW        ??key_scan_2
    334          		{
    335          #if (USE_KEDIR && (USE_KEDIR_TYPE != KEDIR_IR_LED))
    336          		case ADC_KEDIR:
    337          			key_val = kedir_get();
    338          			if(key_val == NO_KEY)
    339          			{
    340          #ifdef AX207X_TAG
    341          				if(DCN == 0x00)
    342          				{
    343          					KEDIR_SCAN_BIG_1();
    344          				}
    345          				else
    346          #endif
    347          				{
    348          					KEDIR_SCAN_BIG();
    349          				}
    350          				kedir_resume();
    351          				ADC_CH_KEDIR_NEXT();
    352          			}
    353          			else
    354          			{
    355          				ADC_CH_KEDIR_KICK();
    356          			}
    357          			break;
    358          #endif
    359          
    360          #if USE_ADKEY
    361          		case ADC_KEY:
    362          			if(ir_key_sta)
    363          			{
    364          				break;
    365          			}
    366          			key_val = adkey_get();
    367          			if(key_val == NO_KEY)
    368          			{
    369          				ADC_CH_KEY_NEXT();
    370          			}
    371          			else
    372          			{
    373          				ADC_CH_KEY_KICK();
    374          			}
    375          			break;
    376          #endif
    377          
    378          #if USE_ADKEY2
    379          		case ADC_KEY2:
    380          			if(ir_key_sta)
    381          			{
    382          				break;
    383          			}
    384          			key_val = adkey2_get();
    385          			if(key_val == NO_KEY)
    386          			{
    387          				ADC_CH_KEY2_NEXT();
    388          			}
    389          			else
    390          			{
    391          				ADC_CH_KEY2_KICK();
    392          			}
    393          			break;
    394          #endif
    395          
    396          #if (BATTERY_CHECK || SOFT_POWEROFF_EN)
    397          		case ADC_BAT:
    398          			scan_ctl.bat_val = scan_ctl.adc_val;
   \                     ??key_scan_1:
   \   000025   90....       MOV     DPTR,#(scan_ctl + 1)
   \   000028   E0           MOVX    A,@DPTR
   \   000029   90....       MOV     DPTR,#(scan_ctl + 4)
   \   00002C   F0           MOVX    @DPTR,A
    399          			ADC_CH_BAT_NEXT();
   \   00002D   7405         MOV     A,#0x5
   \   00002F   90....       MOV     DPTR,#scan_ctl
   \   000032   F0           MOVX    @DPTR,A
   \   000033   75D18E       MOV     0xd1,#-0x72
   \   000036   8014         SJMP    ??key_scan_0
    400          			break;//return;
    401          		case ADC_BAND_GAP:
    402          			scan_ctl.band_gap_val = scan_ctl.adc_val;
   \                     ??key_scan_2:
   \   000038   90....       MOV     DPTR,#(scan_ctl + 1)
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   90....       MOV     DPTR,#(scan_ctl + 5)
   \   00003F   F0           MOVX    @DPTR,A
    403          			ADC_CH_BAND_NEXT();
   \   000040   7404         MOV     A,#0x4
   \   000042   90....       MOV     DPTR,#scan_ctl
   \   000045   F0           MOVX    @DPTR,A
   \   000046   75D18D       MOV     0xd1,#-0x73
    404          			task_battery_check();
   \   000049                ; Setup parameters for call to function task_battery_check
   \   000049   12....       LCALL   task_battery_check
    405          			//key_scan_flag = true;	// Merlin ÒÆ³ý
    406          			break;//return;
    407          #endif
    408          
    409          #if USE_SDCLK_SDDET_PHONE_MUX
    410          		case ADC_SD_DECT:
    411          			scan_ctl.sddect_val = scan_ctl.adc_val;
    412          			ADC_CH_SDDECT_NEXT();
    413          			return;
    414          #endif
    415          
    416          #if (HP_DET_EN && DAC_BUF_EN)         //HPDECT(use vcmbuf)
    417          		case ADC_HP_DECT:
    418          			scan_ctl.hpdect_val = scan_ctl.adc_val;
    419          			ADC_CH_HPDECT_NEXT();
    420          			return;
    421          #endif
    422          
    423          #ifdef AX207X_TAG
    424          #if SOFT_POWEROFF_EN
    425          		case ADC_KEYPOWER:
    426          			key_val = powerkey_get();
    427          			if(key_val == NO_KEY)
    428          			{
    429          				ADC_CH_KEYPOWER_NEXT();
    430          			}
    431          			else
    432          			{
    433          				ADC_CH_KEY2_NEXT();       //²ÉÑùLDOµçÑ¹
    434          			}
    435          			break;
    436          #endif
    437          #endif
    438          		}
    439          
    440          #ifdef AX107X_TAG
    441          #if SOFT_POWEROFF_EN
    442          		if(key_val == NO_KEY)
    443          		{
    444          			key_val = powerkey_get();
    445          		}
    446          #endif
    447          #endif
    448          
    449          #if USE_IR
    450          		u8 ir_val;
    451          		if(key_val == NO_KEY || (scan_ctl.adc_val>0xE1 && scan_ctl.adc_val<0xF7))
    452          		{
    453          			ir_val = ir_process();
    454          			if(ir_val != NO_KEY)
    455          			{
    456          				key_val = ir_val;
    457          			}
    458          		}
    459          #endif
    460          
    461          #if USE_TOUCH_KEY
    462          		if(key_val == NO_KEY)
    463          		{
    464          			key_val = touch_key_scan();
    465          		}
    466          #endif
    467          	}
    468          
    469          	key_val = key_deal(key_val);                            //´¦Àí°´¼üÖµ
   \                     ??key_scan_0:
   \   00004C                ; Setup parameters for call to function key_deal
   \   00004C   EE           MOV     A,R6
   \   00004D   F9           MOV     R1,A
   \   00004E   12....       LCALL   key_deal
   \   000051   E9           MOV     A,R1
    470          
    471          	if(key_val != NO_KEY)
   \   000052   6003         JZ      ??key_scan_3
    472          	{
    473          		//printf("K:%02x\n",key_val);
    474          		put_msg(key_val);
   \   000054                ; Setup parameters for call to function put_msg
   \   000054   12....       LCALL   put_msg
    475          
    476          #if KEY_VOICE_EN
    477          		if((key_val != KL_PLAY) && (key_val != KL_MODE) && (key_val != KL_EQ) && (key_val != KL_PLAYMODE))      //ÎÞ¹¦ÄÜ°´¼ü²»ÏìÓ¦°´¼üÒô
    478          		{
    479          			if((key_val & 0x80) && !(key_val & 0x40))       //³¤°´Ê±Ö»ÓÐÒ»´Î°´¼üÒô
    480          			{
    481          				user_kick_kv();
    482          			}
    483          		}
    484          #endif
    485          	}
    486          }
   \                     ??key_scan_3:
   \   000057   D0E0         POP     A
   \   000059   FE           MOV     R6,A
   \   00005A   22           RET
    487          
    488          #if (BATTERY_CHECK || SOFT_POWEROFF_EN)
    489          //µç³ØµçÁ¿¼ì²â
    490          #pragma location="BAT_CHECK"

   \                                 In segment BAT_CHECK, align 1, keep-with-next
    491          void task_battery_check(void)
   \                     task_battery_check:
    492          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    493          	static u8  bat_count1 = 0,bat_count = 0;
    494          	static u16 r = 1000,z = 0;
    495          	static u8 bat_sta = VOL_INIT,bat_sta_bakeup = 0;
    496          
    497          	if(scan_ctl.bat_val > z)
   \   000000   90....       MOV     DPTR,#(scan_ctl + 4)
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F8           MOV     R0,A
   \   000005   90....       MOV     DPTR,#??z
   \   000008   C3           CLR     C
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   98           SUBB    A,R0
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   5008         JNC     ??task_battery_check_0
    498          	{
    499          		z = scan_ctl.bat_val;
   \   000011   90....       MOV     DPTR,#??z
   \   000014   E8           MOV     A,R0
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   \   000017   E4           CLR     A
   \   000018   F0           MOVX    @DPTR,A
    500          	}
    501          	if(scan_ctl.band_gap_val < r)
   \                     ??task_battery_check_0:
   \   000019   90....       MOV     DPTR,#(scan_ctl + 5)
   \   00001C   E0           MOVX    A,@DPTR
   \   00001D   FA           MOV     R2,A
   \   00001E   90....       MOV     DPTR,#??r
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F8           MOV     R0,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F9           MOV     R1,A
   \   000026   C3           CLR     C
   \   000027   EA           MOV     A,R2
   \   000028   98           SUBB    A,R0
   \   000029   E4           CLR     A
   \   00002A   99           SUBB    A,R1
   \   00002B   5008         JNC     ??task_battery_check_1
    502          	{
    503          		r = scan_ctl.band_gap_val;
   \   00002D   90....       MOV     DPTR,#??r
   \   000030   EA           MOV     A,R2
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   E4           CLR     A
   \   000034   F0           MOVX    @DPTR,A
    504          	}
    505          	bat_count++;
   \                     ??task_battery_check_1:
   \   000035   90....       MOV     DPTR,#??bat_count
   \   000038   E0           MOVX    A,@DPTR
   \   000039   04           INC     A
   \   00003A   F0           MOVX    @DPTR,A
    506          	if(bat_count >= 50)
   \   00003B   C3           CLR     C
   \   00003C   9432         SUBB    A,#0x32
   \   00003E   5003         JNC     $+5
   \   000040   02....       LJMP    ??task_battery_check_2
    507          	{
    508          		if(z * 123 < r * VOL_AD_31V)         //Ð¡ÓÚ3.1V
   \   000043   90....       MOV     DPTR,#??z
   \   000046   E0           MOVX    A,@DPTR
   \   000047   FA           MOV     R2,A
   \   000048   A3           INC     DPTR
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FB           MOV     R3,A
   \   00004B   EA           MOV     A,R2
   \   00004C   75F07B       MOV     B,#0x7b
   \   00004F   A4           MUL     AB
   \   000050   FA           MOV     R2,A
   \   000051   ACF0         MOV     R4,B
   \   000053   75F07B       MOV     B,#0x7b
   \   000056   EB           MOV     A,R3
   \   000057   A4           MUL     AB
   \   000058   2C           ADD     A,R4
   \   000059   FB           MOV     R3,A
   \   00005A   90....       MOV     DPTR,#??r
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   F8           MOV     R0,A
   \   00005F   A3           INC     DPTR
   \   000060   E0           MOVX    A,@DPTR
   \   000061   F9           MOV     R1,A
   \   000062   E8           MOV     A,R0
   \   000063   75F09B       MOV     B,#-0x65
   \   000066   A4           MUL     AB
   \   000067   F8           MOV     R0,A
   \   000068   ACF0         MOV     R4,B
   \   00006A   75F09B       MOV     B,#-0x65
   \   00006D   E9           MOV     A,R1
   \   00006E   A4           MUL     AB
   \   00006F   2C           ADD     A,R4
   \   000070   F9           MOV     R1,A
   \   000071   C3           CLR     C
   \   000072   EA           MOV     A,R2
   \   000073   98           SUBB    A,R0
   \   000074   EB           MOV     A,R3
   \   000075   99           SUBB    A,R1
   \   000076   5004         JNC     ??task_battery_check_3
    509          		{
    510          			bat_sta = VOL_LESS_31V;
   \   000078   7402         MOV     A,#0x2
   \   00007A   8002         SJMP    ??task_battery_check_4
    511          		}
    512          #if SOFT_POWEROFF_EN
    513          		else if(z * 123 > r * VOL_AD_44V)    //´óÓÚ4.4V
    514          		{
    515          			bat_sta = VOL_GREATER_44V;
    516          		}
    517          #endif
    518          		else
    519          		{
    520          			bat_sta = VOL_OTHER;
   \                     ??task_battery_check_3:
   \   00007C   7401         MOV     A,#0x1
   \                     ??task_battery_check_4:
   \   00007E   90....       MOV     DPTR,#??bat_sta
   \   000081   F0           MOVX    @DPTR,A
    521          		}
    522          
    523          		r = 1000;
   \   000082   90....       MOV     DPTR,#??r
   \   000085   74E8         MOV     A,#-0x18
   \   000087   F0           MOVX    @DPTR,A
   \   000088   A3           INC     DPTR
   \   000089   7403         MOV     A,#0x3
   \   00008B   F0           MOVX    @DPTR,A
    524          		z = 0;
   \   00008C   90....       MOV     DPTR,#??z
   \   00008F   E4           CLR     A
   \   000090   F0           MOVX    @DPTR,A
   \   000091   A3           INC     DPTR
   \   000092   F0           MOVX    @DPTR,A
    525          		bat_count = 0;
   \   000093   90....       MOV     DPTR,#??bat_count
   \   000096   F0           MOVX    @DPTR,A
    526          
    527          		if(bat_sta_bakeup != bat_sta)
   \   000097   90....       MOV     DPTR,#??bat_sta_bakeup
   \   00009A   E0           MOVX    A,@DPTR
   \   00009B   FA           MOV     R2,A
   \   00009C   90....       MOV     DPTR,#??bat_sta
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   6A           XRL     A,R2
   \   0000A1   600B         JZ      ??task_battery_check_5
    528          		{
    529          			bat_sta_bakeup = bat_sta;
   \   0000A3   E0           MOVX    A,@DPTR
   \   0000A4   90....       MOV     DPTR,#??bat_sta_bakeup
   \   0000A7   F0           MOVX    @DPTR,A
    530          			bat_count1 = 0;
   \   0000A8   E4           CLR     A
   \   0000A9   90....       MOV     DPTR,#??bat_count1
   \   0000AC   F0           MOVX    @DPTR,A
   \   0000AD   22           RET
    531          		}
    532          		else
    533          		{
    534          			bat_count1++;
   \                     ??task_battery_check_5:
   \   0000AE   90....       MOV     DPTR,#??bat_count1
   \   0000B1   E0           MOVX    A,@DPTR
   \   0000B2   04           INC     A
   \   0000B3   F0           MOVX    @DPTR,A
    535          		}
    536          #if SOFT_POWEROFF_EN
    537          		if(sys_ctl.bat_sta == VOL_INIT)     //ÉÏµçµÚÒ»´Î
    538          		{
    539          			sys_ctl.bat_sta = bat_sta;
    540          			return;
    541          		}
    542          #endif
    543          		if(bat_count1 >= 5)
   \   0000B4   C3           CLR     C
   \   0000B5   9405         SUBB    A,#0x5
   \   0000B7   400A         JC      ??task_battery_check_2
    544          		{
    545          			bat_count1 = 0;
   \   0000B9   E4           CLR     A
   \   0000BA   F0           MOVX    @DPTR,A
    546          			sys_ctl.bat_sta = bat_sta;
   \   0000BB   90....       MOV     DPTR,#??bat_sta
   \   0000BE   E0           MOVX    A,@DPTR
   \   0000BF   90....       MOV     DPTR,#(sys_ctl + 5)
   \   0000C2   F0           MOVX    @DPTR,A
    547          		}
    548          
    549          #if TASK_POWEROFF_EN
    550          		if(sys_ctl.bat_sta == VOL_LESS_31V)
    551          		{
    552          			if(task_ctl.work_sta != TASK_POWEROFF)
    553          			{
    554          				task_ctl.work_sta = TASK_POWEROFF;   //µÍµç¹Ø»ú
    555          				printf("µÍµç¹Ø»ú.\n");
    556          			}
    557          		}
    558          #endif
    559          	}
    560          }
   \                     ??task_battery_check_2:
   \   0000C3   22           RET

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
   \                     ??bat_count1:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
   \                     ??bat_count:
   \   000000                DS 1

   \                                 In segment XDATA_I, align 1, keep-with-next
   \                     ??r:
   \   000000                DS 2
   \   000002                REQUIRE `?<Initializer for r>`
   \   000002                REQUIRE __INIT_XDATA_I

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
   \                     ??z:
   \   000000                DS 2

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
   \                     ??bat_sta:
   \   000000                DS 1

   \                                 In segment XDATA_Z, align 1, keep-with-next
   \   000000                REQUIRE __INIT_XDATA_Z
   \                     ??bat_sta_bakeup:
   \   000000                DS 1

   \                                 In segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for r>`:
   \   000000   E803         DW 1000
    561          #endif

   Maximum stack usage in bytes:

     Function                EXT_STACK PSTACK XSTACK
     --------                --------- ------ ------
     adkey2_get                     0      0      0
     adkey_get                      0      0      0
     iokey_get                      1      0      0
     kedir_get                      1      0      0
       -> kedir_group_num           0      0      0
     key_deal                       1      0      0
     key_init                       0      0      0
       -> my_memset                 0      0      0
       -> my_memset                 0      0      0
     key_scan                       1      0      0
       -> iokey_get                 2      0      0
       -> task_battery_check        2      0      0
       -> key_deal                  2      0      0
       -> put_msg                   2      0      0
     task_battery_check             1      0      0


   Segment part sizes:

     Function/Label       Bytes
     --------------       -----
     P0                      1
     ADCCON                  1
     ADCDATAH                1
     key_ctl                 5
     scan_ctl                6
     key_init               56
     kedir_get              43
     ?Subroutine0            5
     adkey_get              35
     iokey_get              47
     adkey2_get             35
     key_deal              146
     key_scan               91
     task_battery_check    196
     bat_count1              1
     bat_count               1
     r                       2
     z                       2
     bat_sta                 1
     bat_sta_bakeup          1
     ?<Initializer for r>    2

 
 196 bytes in segment BAT_CHECK
  56 bytes in segment KEY_INIT
 402 bytes in segment SCAN_COM
   3 bytes in segment SFR_AN
   2 bytes in segment XDATA_I
   2 bytes in segment XDATA_ID
  11 bytes in segment XDATA_N
   6 bytes in segment XDATA_Z
 
 656 bytes of CODE  memory
   0 bytes of DATA  memory (+ 3 bytes shared)
  19 bytes of XDATA memory

Errors: none
Warnings: none
